---
phase: 40-plugin-installation-in-volume
plan: 02
type: execute
wave: 2
depends_on: ["40-01"]
files_modified:
  - src/aishell/docker/volume.clj
  - src/aishell/cli.clj
autonomous: true

must_haves:
  truths:
    - "aishell build --with-tmux --with-claude installs TPM and declared plugins into harness volume"
    - "aishell update refreshes plugin installations along with harness tools"
    - "Plugins are world-readable (chmod -R a+rX) for non-root container user"
    - "Empty plugins list skips TPM installation entirely"
    - "Volume population without --with-tmux skips all tmux plugin work"
  artifacts:
    - path: "src/aishell/docker/volume.clj"
      provides: "build-tpm-install-command function and populate-volume config integration"
      contains: "build-tpm-install-command"
    - path: "src/aishell/cli.clj"
      provides: "Config threading to populate-volume in build and update commands"
      contains: "populate-volume.*config"
  key_links:
    - from: "src/aishell/cli.clj handle-build"
      to: "vol/populate-volume"
      via: "passes config map as additional argument"
      pattern: "populate-volume.*volume-name.*state.*config"
    - from: "src/aishell/docker/volume.clj populate-volume"
      to: "build-tpm-install-command"
      via: "called when :with-tmux in state and plugins in config"
      pattern: "build-tpm-install-command"
    - from: "src/aishell/docker/volume.clj build-tpm-install-command"
      to: "TPM bin/install_plugins"
      via: "shell command string with TMUX_PLUGIN_MANAGER_PATH"
      pattern: "TMUX_PLUGIN_MANAGER_PATH=/tools/tmux/plugins"
---

<objective>
Install TPM and declared plugins into harness volume during aishell build and update.

Purpose: PLUG-01, PLUG-02, PLUG-03 require plugin declarations in config to trigger TPM installation and non-interactive plugin fetching during volume population. This extends the existing volume population pipeline.
Output: Working plugin installation integrated into build and update flows.
</objective>

<execution_context>
@/home/jonasrodrigues/.claude/get-shit-done/workflows/execute-plan.md
@/home/jonasrodrigues/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/40-plugin-installation-in-volume/40-RESEARCH.md
@.planning/phases/40-plugin-installation-in-volume/40-01-SUMMARY.md
@src/aishell/docker/volume.clj
@src/aishell/cli.clj
@src/aishell/run.clj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add TPM install command builder to volume.clj and extend populate-volume</name>
  <files>src/aishell/docker/volume.clj</files>
  <action>
Add a new function `build-tpm-install-command` to volume.clj:

```clojure
(defn build-tpm-install-command
  "Build shell command for installing TPM and plugins into /tools/tmux.
   Returns shell command string or nil if no plugins declared."
  [plugins]
  (when (seq plugins)
    (let [plugin-lines (str/join "\\n"
                         (map #(str "set -g @plugin '" % "'") plugins))]
      (str "mkdir -p /tools/tmux/plugins"
           " && git clone --depth 1 https://github.com/tmux-plugins/tpm /tools/tmux/plugins/tpm"
           " && printf '%s\\n' \"" plugin-lines "\" > /tmp/plugins.conf"
           " && TMUX_PLUGIN_MANAGER_PATH=/tools/tmux/plugins /tools/tmux/plugins/tpm/bin/install_plugins"
           " && chmod -R a+rX /tools/tmux"))))
```

Key details:
- Uses `printf` with double-quotes to handle the plugin lines (single quotes inside plugin declarations)
- Uses `/tmp/plugins.conf` as temp config (cleaned up when container is removed via --rm)
- Sets TMUX_PLUGIN_MANAGER_PATH for non-standard install path
- chmod for non-root container user access
- Returns nil when plugins list is empty (caller skips)

Modify `build-install-commands` to accept an optional second argument `opts` (a map with `:state` and `:config` keys):

Actually, cleaner approach: DON'T modify build-install-commands. Instead, modify `populate-volume` to accept config and conditionally append tmux installation.

Change `populate-volume` signature from `[volume-name state & [opts]]` to `[volume-name state & [opts]]` (keep same), but the opts map now also accepts `:config` key.

In populate-volume, after building `install-commands` from `build-install-commands`, check if `:with-tmux` is true in state AND if config has `[:tmux :plugins]`. If so, call `build-tpm-install-command` and append to the install command string with ` && `.

```clojure
(let [install-commands (build-install-commands state)
      tmux-plugins (when (:with-tmux state)
                     (get-in (:config opts) [:tmux :plugins]))
      tmux-install (build-tpm-install-command tmux-plugins)
      full-commands (str install-commands
                        (when tmux-install (str " && " tmux-install)))
      ...]
  ;; Use full-commands instead of install-commands in the docker run cmd
  )
```

The rest of populate-volume stays the same, just use `full-commands` where `install-commands` was used.

Important: The `:config` key in opts is optional. When not provided (backward compat), tmux install is simply skipped. This keeps ensure-harness-volume in run.clj working without changes for now (it already loads config separately).
  </action>
  <verify>
Run `bb -cp src -e "(require 'aishell.docker.volume) (println (aishell.docker.volume/build-tpm-install-command [\"tmux-plugins/tmux-sensible\"]))"` - should print the shell command string containing git clone, install_plugins, and chmod.
Run `bb -cp src -e "(require 'aishell.docker.volume) (println (aishell.docker.volume/build-tpm-install-command []))"` - should print nil.
Run `bb -cp src -e "(require 'aishell.docker.volume) (println (aishell.docker.volume/build-tpm-install-command nil))"` - should print nil.
  </verify>
  <done>
build-tpm-install-command generates correct shell command for TPM + plugin installation. populate-volume conditionally includes tmux plugin installation when :with-tmux state flag is set and config has plugins.
  </done>
</task>

<task type="auto">
  <name>Task 2: Thread config to populate-volume in build and update commands</name>
  <files>src/aishell/cli.clj</files>
  <action>
In cli.clj, modify two locations where `vol/populate-volume` is called to pass config:

1. **handle-build** (around line 212): Load config and pass it to populate-volume.
   - After the state-map is built (~line 189), load config: `cfg (config/load-config project-dir)` where `project-dir` is `(System/getProperty "user.dir")`
   - Add `project-dir` binding before state-map: `project-dir (System/getProperty "user.dir")`
   - Change the populate-volume call from:
     `(vol/populate-volume volume-name state-map {:verbose (:verbose opts)})`
     to:
     `(vol/populate-volume volume-name state-map {:verbose (:verbose opts) :config cfg})`

2. **handle-update** (around line 326): Load config and pass it similarly.
   - Add config loading: `cfg (config/load-config (System/getProperty "user.dir"))`
   - Change the populate-volume call from:
     `(vol/populate-volume volume-name state {:verbose (:verbose opts)})`
     to:
     `(vol/populate-volume volume-name state {:verbose (:verbose opts) :config cfg})`

3. **ensure-harness-volume in run.clj**: Also needs config threading for lazy volume population at runtime. Modify `run.clj` `ensure-harness-volume` to accept config and pass it through.
   - Change `ensure-harness-volume` from `[state]` to `[state config]`
   - In the two populate-volume calls inside ensure-harness-volume, add `{:config config}` as opts
   - Update both callers in run.clj (run-container and run-exec) to pass config:
     - In run-container: `(ensure-harness-volume state)` becomes `(ensure-harness-volume state cfg)` (cfg is already loaded at line 141)
     - In run-exec: `(ensure-harness-volume state)` becomes `(ensure-harness-volume state cfg)` (cfg is already loaded)

   Wait - ensure-harness-volume is called BEFORE cfg is loaded in run-container. Look at lines 124 vs 141. Need to move ensure-harness-volume call after cfg loading, or load cfg earlier.

   Actually, looking more carefully at run-container: `harness-volume-name` is computed at line 124, but cfg is loaded at line 141. The simplest fix is to load cfg before ensure-harness-volume. Move the cfg loading (currently at line 141) up to before the ensure-harness-volume call. The cfg is just `(config/load-config project-dir)` which has no side effects.

   For run-exec: similarly, ensure cfg is loaded before ensure-harness-volume.

Important: Also add `:config` to the files_modified for run.clj. Update the require in cli.clj to include config if not already present (check - it's not currently required in cli.clj, but config is loaded via `config/load-config`... actually cli.clj doesn't require aishell.config. It needs to be added to the require).

Actually, checking cli.clj requires - it does NOT require aishell.config. Add it:
```clojure
[aishell.config :as config]
```
  </action>
  <verify>
Verify the code compiles: `bb -cp src -e "(require 'aishell.cli)"` - should not error.
Verify build works end-to-end: Run `aishell build --with-claude --with-tmux --verbose` and confirm the output shows TPM git clone and plugin installation after npm install (if tmux.plugins is declared in config).
Verify update works: Run `aishell update --verbose` and confirm plugin installation is included.
  </verify>
  <done>
Config threaded to all populate-volume call sites (handle-build, handle-update, ensure-harness-volume). When --with-tmux is enabled and tmux.plugins are declared in config, TPM and plugins are installed during volume population. When --with-tmux is not set, volume population is unchanged.
  </done>
</task>

</tasks>

<verification>
- `bb -cp src -e "(require 'aishell.cli)"` compiles without error
- `bb -cp src -e "(require 'aishell.docker.volume) (println (aishell.docker.volume/build-tpm-install-command [\"tmux-plugins/tmux-sensible\"]))"` outputs valid shell command
- build-tpm-install-command returns nil for empty/nil plugins
- populate-volume includes tmux install when :with-tmux true and config has plugins
- populate-volume skips tmux install when :with-tmux false or no plugins in config
</verification>

<success_criteria>
- PLUG-01: tmux.plugins list in config.yaml is read and used during build
- PLUG-02: TPM cloned to /tools/tmux/plugins/tpm during volume population
- PLUG-03: Declared plugins installed non-interactively via bin/install_plugins
- aishell update refreshes plugin installations (PLUG-03 for update path)
- Empty plugins or no --with-tmux gracefully skips all tmux plugin work
</success_criteria>

<output>
After completion, create `.planning/phases/40-plugin-installation-in-volume/40-02-SUMMARY.md`
</output>
