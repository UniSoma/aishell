---
phase: 40-plugin-installation-in-volume
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/aishell/docker/volume.clj
  - src/aishell/cli.clj
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "aishell build --with-tmux triggers volume repopulation even when only tmux config changed"
    - "TPM and declared plugins exist at /tools/tmux/plugins/ after aishell build --with-tmux"
    - "aishell update succeeds idempotently when /tools/tmux/plugins/tpm already exists"
    - "Multiple plugins install correctly on repeated aishell update"
  artifacts:
    - path: "src/aishell/docker/volume.clj"
      provides: "Volume hash includes tmux state; TPM clone is idempotent"
      contains: "with-tmux"
    - path: "src/aishell/cli.clj"
      provides: "Build path triggers populate-volume when tmux enabled"
      contains: "with-tmux"
  key_links:
    - from: "src/aishell/cli.clj"
      to: "vol/populate-volume"
      via: "build guard includes :with-tmux check"
      pattern: "with-tmux"
    - from: "src/aishell/docker/volume.clj"
      to: "compute-harness-hash"
      via: "normalize-harness-config includes tmux state"
      pattern: "with-tmux"
---

<objective>
Fix two UAT failures in Phase 40: (1) volume hash excludes tmux config causing build to skip plugin installation, and (2) TPM git clone lacks idempotency guard causing update failures.

Purpose: Close 3 UAT gaps (tests 3, 4, 9) so that `aishell build --with-tmux` installs plugins into the volume and `aishell update` works reliably on repeat runs.
Output: Patched volume.clj and cli.clj with passing UAT scenarios.
</objective>

<execution_context>
@/home/jonasrodrigues/.claude/get-shit-done/workflows/execute-plan.md
@/home/jonasrodrigues/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/40-plugin-installation-in-volume/40-02-SUMMARY.md
@src/aishell/docker/volume.clj
@src/aishell/cli.clj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Include tmux state in volume hash and fix build guard</name>
  <files>src/aishell/docker/volume.clj, src/aishell/cli.clj</files>
  <action>
Two changes are needed:

**volume.clj - Include tmux in hash computation:**

1. In `normalize-harness-config`: After computing the harness pairs vector, append tmux state to the hash input. The function should also include `:with-tmux` and the plugin list from the state map. Modify the function to accept an optional second argument (config map) OR change the approach: include `:with-tmux` flag directly in the hash input alongside the harness pairs.

   Simplest approach: After line 50 (`vec`), append tmux state to the vector. Change the function to also consider tmux:
   ```clojure
   (defn normalize-harness-config
     [state]
     (let [harness-pairs (->> harness-keys
                              (filter #(get state (keyword (str "with-" (name %)))))
                              (map (fn [harness-kw]
                                     (let [version-key (keyword (str (name harness-kw) "-version"))
                                           version (get state version-key)]
                                       [harness-kw (or version "latest")])))
                              (sort-by first)
                              vec)
           tmux-state (when (:with-tmux state)
                        [:tmux {:plugins (vec (sort (or (:tmux-plugins state) [])))}])]
       (cond-> harness-pairs
         tmux-state (conj tmux-state))))
   ```

   This means the hash changes when :with-tmux is toggled or plugins change.

2. In `compute-harness-hash`: No changes needed -- it already calls `normalize-harness-config`.

**cli.clj - Fix build guard and pass plugin list in state-map:**

3. In `handle-build` (line 198): The `when` guard that triggers volume population currently only checks harness flags:
   ```clojure
   (when (some #(get state-map %) [:with-claude :with-opencode :with-codex :with-gemini])
   ```
   Change this to ALSO check `:with-tmux`:
   ```clojure
   (when (some #(get state-map %) [:with-claude :with-opencode :with-codex :with-gemini :with-tmux])
   ```
   This ensures that when ONLY tmux is enabled (no AI harnesses), the volume is still created and populated.

4. In `handle-build`: Add `:tmux-plugins` to `state-map` so it flows into the hash:
   After the existing state-map definition (around line 192), add:
   ```clojure
   :tmux-plugins (when with-tmux
                   (get-in cfg [:tmux :plugins]))
   ```
   This ensures the plugin list is part of the hash computation.

5. In `handle-update` (line 315): Same guard fix -- add `:with-tmux` to the harnesses-enabled? check:
   ```clojure
   harnesses-enabled? (some #(get state %) [:with-claude :with-opencode :with-codex :with-gemini :with-tmux])
   ```

**IMPORTANT:** The `build-install-commands` function in volume.clj generates NPM-related commands. When only tmux is enabled (no AI harnesses), the npm export/chmod commands still run but are harmless (mkdir + chmod on empty /tools/npm is fine). No changes needed there.
  </action>
  <verify>
1. Read the modified files and confirm:
   - `normalize-harness-config` includes tmux state in output when `:with-tmux` is true
   - `handle-build` guard includes `:with-tmux`
   - `state-map` includes `:tmux-plugins`
   - `handle-update` harnesses-enabled? includes `:with-tmux`
2. Run `bb -e "(require '[aishell.docker.volume :as v]) (println (v/normalize-harness-config {:with-tmux true :tmux-plugins [\"tmux-plugins/tmux-sensible\"]}))"` to confirm tmux appears in normalized config
3. Run `bb -e "(require '[aishell.docker.volume :as v]) (println (v/compute-harness-hash {:with-tmux true :tmux-plugins [\"tmux-plugins/tmux-sensible\"]})) (println (v/compute-harness-hash {:with-tmux false}))"` to confirm different hashes
  </verify>
  <done>
- normalize-harness-config includes :with-tmux and plugin list in hash input
- handle-build guard triggers volume population when :with-tmux is true (even without AI harnesses)
- handle-update guard triggers volume repopulation when :with-tmux is true
- Different tmux plugin configurations produce different volume hashes
  </done>
</task>

<task type="auto">
  <name>Task 2: Make TPM git clone idempotent</name>
  <files>src/aishell/docker/volume.clj</files>
  <action>
In `build-tpm-install-command` (line 200), the bare `git clone` fails when `/tools/tmux/plugins/tpm` already exists (happens on `aishell update` which does delete+recreate of volume, but also on any retry scenario).

Replace the git clone line with an idempotency guard. Use a shell conditional that checks if the directory exists:

```clojure
(str "mkdir -p /tools/tmux/plugins"
     " && if [ -d /tools/tmux/plugins/tpm ]; then"
     " git -C /tools/tmux/plugins/tpm pull --ff-only 2>/dev/null || true"
     "; else"
     " git clone --depth 1 https://github.com/tmux-plugins/tpm /tools/tmux/plugins/tpm"
     "; fi"
     " && printf '%s\\n' \"" plugin-lines "\" > /tmp/plugins.conf"
     " && TMUX_PLUGIN_MANAGER_PATH=/tools/tmux/plugins /tools/tmux/plugins/tpm/bin/install_plugins"
     " && chmod -R a+rX /tools/tmux")
```

This approach:
- If TPM dir exists: `git pull --ff-only` to update (or silently succeed if offline)
- If TPM dir missing: clone as before
- Plugin installation via `bin/install_plugins` handles individual plugin idempotency (TPM's own tool manages this)

WHY not `rm -rf` first: `aishell update` already deletes+recreates the volume, so the directory won't exist on update. But for `aishell build` which only repopulates on hash change, or for retry scenarios, the directory could exist. Using pull-if-exists is safer than deleting.
  </action>
  <verify>
1. Read `build-tpm-install-command` and confirm the idempotency guard is present
2. Run `bb -e "(require '[aishell.docker.volume :as v]) (println (v/build-tpm-install-command [\"tmux-plugins/tmux-sensible\"]))"` and verify the output contains the `if [ -d` guard
3. Confirm the command string is valid shell syntax (no unmatched quotes or brackets)
  </verify>
  <done>
- build-tpm-install-command generates shell command with existence check before git clone
- Running the command twice does not produce a fatal error
- TPM is updated (git pull) if already present, cloned if missing
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `aishell build --with-tmux` with plugins in config triggers volume creation AND population (not skipped)
2. Hash differs between `{:with-tmux true :tmux-plugins ["tmux-plugins/tmux-sensible"]}` and `{:with-tmux false}`
3. `build-tpm-install-command` output contains idempotency guard
4. All existing tests/checks still pass
</verification>

<success_criteria>
- UAT test 3 (TPM installed during build) can now pass -- build path triggers populate-volume when :with-tmux is true
- UAT test 4 (declared plugins installed during build) can now pass -- same root cause as test 3
- UAT test 9 (multiple plugins on repeated update) can now pass -- git clone is idempotent
- No regression in existing harness-only (no tmux) build/update paths
</success_criteria>

<output>
After completion, create `.planning/phases/40-plugin-installation-in-volume/40-03-SUMMARY.md`
</output>
