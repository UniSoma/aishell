---
phase: 38-volume-cleanup-documentation
plan: 02
type: execute
wave: 2
depends_on: ["38-01"]
files_modified:
  - src/aishell/cli.clj
  - src/aishell/docker/volume.clj
autonomous: true

must_haves:
  truths:
    - "User can list all harness volumes with active/orphaned status"
    - "User can prune orphaned volumes with confirmation prompt"
    - "In-use volumes are skipped during prune with warning"
    - "Prune can be bypassed with --yes flag for scripting"
    - "Empty volume list shows helpful message"
  artifacts:
    - path: "src/aishell/docker/volume.clj"
      provides: "list-harness-volumes, volume-in-use? functions"
      contains: "list-harness-volumes"
    - path: "src/aishell/cli.clj"
      provides: "handle-volumes, handle-volumes-list, handle-volumes-prune functions"
      contains: "handle-volumes"
    - path: "src/aishell/cli.clj"
      provides: "volumes command in dispatch"
      contains: "\"volumes\""
  key_links:
    - from: "src/aishell/cli.clj"
      to: "src/aishell/docker/volume.clj"
      via: "vol/list-harness-volumes for list, vol/remove-volume for prune"
      pattern: "list-harness-volumes"
    - from: "src/aishell/cli.clj"
      to: "src/aishell/state.clj"
      via: "state/read-state for orphan detection"
      pattern: "read-state.*harness-volume-name"
---

<objective>
Implement `aishell volumes` command with list and prune subcommands for harness volume lifecycle management.

Purpose: Users need visibility into harness volumes and a way to clean up orphaned volumes from old configurations. This prevents disk usage accumulation from volume churn.

Output: New `aishell volumes` command (default: list), `aishell volumes prune` subcommand with confirmation, orphan detection based on state.edn reference.
</objective>

<execution_context>
@/home/jonasrodrigues/.claude/get-shit-done/workflows/execute-plan.md
@/home/jonasrodrigues/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/38-volume-cleanup-documentation/38-CONTEXT.md
@.planning/phases/38-volume-cleanup-documentation/38-RESEARCH.md
@src/aishell/cli.clj
@src/aishell/docker/volume.clj
@src/aishell/state.clj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add volume list and in-use detection functions to volume.clj</name>
  <files>src/aishell/docker/volume.clj</files>
  <action>
  Add three new public functions to `src/aishell/docker/volume.clj`:

  1. `list-harness-volumes` - List all aishell harness volumes with metadata:
     ```clojure
     (defn list-harness-volumes
       "List all aishell harness volumes with metadata.
        Returns vector of maps with :name, :hash, :harnesses keys."
       []
       (try
         (let [{:keys [exit out]} (p/shell {:continue true :out :string :err :string}
                                           "docker" "volume" "ls"
                                           "--filter" "name=aishell-harness-"
                                           "--format" "{{.Name}}")
               names (when (zero? exit)
                       (remove str/blank? (str/split-lines out)))]
           (vec (map (fn [vol-name]
                       {:name vol-name
                        :hash (get-volume-label vol-name "aishell.harness.hash")
                        :harnesses (get-volume-label vol-name "aishell.harnesses")})
                     names)))
         (catch Exception _ [])))
     ```

  2. `volume-in-use?` - Check if volume is mounted by any container:
     ```clojure
     (defn volume-in-use?
       "Check if volume is mounted by any running or stopped container."
       [volume-name]
       (try
         (let [{:keys [exit out]} (p/shell {:continue true :out :string :err :string}
                                           "docker" "ps" "-a"
                                           "--filter" (str "volume=" volume-name)
                                           "--format" "{{.Names}}")]
           (and (zero? exit) (not (str/blank? out))))
         (catch Exception _ false)))
     ```

  3. `get-volume-size` - Get volume disk usage:
     ```clojure
     (defn get-volume-size
       "Get size of Docker volume. Returns formatted string or 'N/A'."
       [volume-name]
       (try
         (let [{:keys [exit out]} (p/shell {:continue true :out :string :err :string}
                                           "docker" "system" "df" "-v"
                                           "--format" "table {{.Name}}\t{{.Size}}")
               lines (when (zero? exit) (str/split-lines out))
               match (some #(when (str/starts-with? % volume-name) %) lines)]
           (if match
             (str/trim (second (str/split match #"\t")))
             "N/A"))
         (catch Exception _ "N/A")))
     ```

  4. Update `create-volume` to also store harness names as a label. Modify the call sites in cli.clj to pass an "aishell.harnesses" label containing a comma-separated list of enabled harness names. This is done in the CALLER (cli.clj), not in volume.clj itself â€” volume.clj already accepts arbitrary labels. This note is for awareness only.
  </action>
  <verify>
  - `bb -e '(load-file "src/aishell/docker/volume.clj")'` compiles without errors
  - `grep "list-harness-volumes" src/aishell/docker/volume.clj` returns a match
  - `grep "volume-in-use?" src/aishell/docker/volume.clj` returns a match
  - `grep "get-volume-size" src/aishell/docker/volume.clj` returns a match
  </verify>
  <done>
  - list-harness-volumes returns vector of volume metadata maps
  - volume-in-use? detects containers using a volume
  - get-volume-size returns formatted disk usage string
  </done>
</task>

<task type="auto">
  <name>Task 2: Add volumes command with list and prune to cli.clj</name>
  <files>src/aishell/cli.clj</files>
  <action>
  Add the `aishell volumes` command to `src/aishell/cli.clj`:

  1. Add `handle-volumes-list` function:
     - Read state with `state/read-state`
     - Get all volumes with `vol/list-harness-volumes`
     - If empty: print "No harness volumes found.\n\nVolumes are created automatically during 'aishell build' when harnesses are enabled."
     - If volumes exist: compute status for each (compare :name against (:harness-volume-name state)), format as table using `pp/print-table` with columns [:NAME :STATUS :SIZE :HARNESSES]
     - Table rows: `{:NAME vol-name, :STATUS (if (= vol-name current-vol) "active" "orphaned"), :SIZE (vol/get-volume-size vol-name), :HARNESSES (or harnesses-label "unknown")}`
     - After table: print "\nTo remove orphaned volumes: aishell volumes prune"

  2. Add `handle-volumes-prune` function:
     - Read state with `state/read-state`
     - Get all volumes, filter to orphaned ones (name != (:harness-volume-name state) AND starts-with "aishell-harness-")
     - If no orphaned: print "No orphaned volumes to prune."
     - If orphaned exist:
       - Print "The following volumes will be removed:"
       - List each: "  - {volume-name}"
       - Prompt for confirmation: check if (:yes opts) or prompt-yn "Remove these volumes?"
       - For each orphaned volume: check volume-in-use? first. If in use, print "Skipping {name} (in use by container)". If not in use, call vol/remove-volume and print "Removed {name}".
       - Print "Prune complete." or "Prune cancelled."
     - Helper `prompt-yn`: print message + " (y/n): ", flush, read-line, compare to "y"

  3. Add `print-volumes-help` function:
     - Usage: `aishell volumes [SUBCOMMAND]`
     - Subcommands: list (default), prune
     - prune options: --yes (skip confirmation)

  4. Add `handle-volumes` dispatcher function:
     - Parse first arg: nil or "list" -> handle-volumes-list
     - "prune" -> handle-volumes-prune (parse --yes flag)
     - "--help" or "-h" -> print-volumes-help
     - Anything else -> error with suggestion

  5. Wire into dispatch in the `dispatch` function (the case statement):
     - Add `"volumes"` case: `(handle-volumes (vec (rest clean-args)))`

  6. Add "aishell.harnesses" label to volume creation in handle-build and handle-update:
     - Compute harness list: filter enabled harnesses from state-map, join with ","
     - Add to labels map: `"aishell.harnesses" harness-list-str`

  7. Update print-help to add volumes command:
     ```
     (println (str "  " output/CYAN "volumes" output/NC "    Manage harness volumes"))
     ```
     Place it after the "ps" line.

  8. Add volumes-prune-spec:
     ```clojure
     (def volumes-prune-spec
       {:yes {:alias :y :coerce :boolean :desc "Skip confirmation prompt"}})
     ```
  </action>
  <verify>
  - `bb -e '(load-file "src/aishell/cli.clj")'` compiles without errors
  - `grep "handle-volumes" src/aishell/cli.clj` returns matches for list and prune
  - `grep '"volumes"' src/aishell/cli.clj` shows volumes in dispatch case
  - `grep "aishell.harnesses" src/aishell/cli.clj` shows harness label in create-volume calls
  </verify>
  <done>
  - `aishell volumes` (or `aishell volumes list`) shows table with NAME, STATUS, SIZE, HARNESSES columns
  - `aishell volumes prune` shows orphaned volumes and prompts for confirmation
  - `aishell volumes prune --yes` skips confirmation
  - In-use volumes are skipped with warning during prune
  - Empty volume list shows helpful message
  - Harness names stored as volume label during build/update for display in list
  </done>
</task>

</tasks>

<verification>
1. `bb -e '(load-file "src/aishell/docker/volume.clj")'` compiles
2. `bb -e '(load-file "src/aishell/cli.clj")'` compiles
3. volumes command accessible from CLI dispatch
4. list shows table with active/orphaned status
5. prune has confirmation prompt and --yes bypass
6. In-use detection prevents removing mounted volumes
7. Harness names stored as volume labels during build
</verification>

<success_criteria>
- `aishell volumes` displays formatted table of harness volumes with status
- `aishell volumes prune` removes orphaned volumes with safety checks
- Volume labels include harness names for human-readable list output
- In-use volumes protected from accidental deletion
</success_criteria>

<output>
After completion, create `.planning/phases/38-volume-cleanup-documentation/38-02-SUMMARY.md`
</output>
