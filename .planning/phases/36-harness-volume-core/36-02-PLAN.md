---
phase: 36-harness-volume-core
plan: 02
type: execute
wave: 2
depends_on: ["36-01"]
files_modified:
  - src/aishell/docker/volume.clj
autonomous: true

must_haves:
  truths:
    - "Volume can be created with metadata labels for hash and version tracking"
    - "Volume existence can be checked by name"
    - "Volume label values can be read for staleness detection"
    - "Harness tools install into volume via npm install -g --prefix in temporary container"
    - "Installed tools have world-readable permissions (chmod a+rX)"
  artifacts:
    - path: "src/aishell/docker/volume.clj"
      provides: "Volume creation, inspection, and population functions"
      exports: ["volume-exists?", "get-volume-label", "create-volume", "populate-volume"]
  key_links:
    - from: "src/aishell/docker/volume.clj"
      to: "docker volume create"
      via: "babashka.process/shell"
      pattern: "docker.*volume.*create"
    - from: "src/aishell/docker/volume.clj"
      to: "docker run --rm"
      via: "babashka.process/shell for npm install"
      pattern: "docker.*run.*--rm"
---

<objective>
Create volume population logic that installs harness npm packages into Docker named volumes with proper metadata labels and permissions.

Purpose: This provides the mechanism to install harness tools (claude-code, codex, gemini-cli) into Docker named volumes (HVOL-01), with labels for staleness detection (BUILD-03) and permissions for non-root execution.

Output: Additional functions in `aishell.docker.volume` for volume lifecycle management and npm package installation.
</objective>

<execution_context>
@/home/jonasrodrigues/.claude/get-shit-done/workflows/execute-plan.md
@/home/jonasrodrigues/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/36-harness-volume-core/36-RESEARCH.md
@.planning/phases/36-harness-volume-core/36-01-SUMMARY.md
@src/aishell/docker/volume.clj
@src/aishell/docker/build.clj
@src/aishell/state.clj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add volume inspection functions</name>
  <files>src/aishell/docker/volume.clj</files>
  <action>
Add to `src/aishell/docker/volume.clj` (after existing functions from 36-01).

Add requires: `[babashka.process :as p]`, `[clojure.string :as str]`

Implement:

1. `volume-exists?` - Check if Docker volume exists by name.
   - Run `docker volume inspect {name}` with `:continue true`
   - Return true if exit code is 0, false otherwise
   - Catch exceptions and return false

2. `get-volume-label` - Get a specific label value from a Docker volume.
   - Run `docker volume inspect --format '{{index .Labels "label-key"}}' volume-name`
   - Return trimmed string value if exit 0, nil otherwise
   - Catch exceptions and return nil

3. `create-volume` - Create Docker volume with metadata labels.
   - Takes volume-name (string) and labels (map like `{"aishell.harness.hash" "abc123", "aishell.harness.version" "2.8.0"}`)
   - Build command: `docker volume create --label key=value ... volume-name`
   - Use `mapcat` to expand labels map into `["--label" "key=value"]` pairs
   - Run via `p/shell`, throw on failure
   - Return volume-name on success

Add docstrings to all functions.
  </action>
  <verify>
Use nREPL to verify `volume-exists?` returns false for a non-existent volume:

```clojure
(require '[aishell.docker.volume :as vol] :reload)

;; Should return false for non-existent volume
(assert (false? (vol/volume-exists? "aishell-test-nonexistent-12345")))
```

The `create-volume` and `get-volume-label` functions will be verified in Task 2 during the integration test.
  </verify>
  <done>
  - `volume-exists?` correctly checks Docker volume existence
  - `get-volume-label` reads label values from volumes
  - `create-volume` creates volumes with metadata labels
  - All functions handle errors gracefully (no exceptions bubble up for non-existent volumes)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add volume population function</name>
  <files>src/aishell/docker/volume.clj</files>
  <action>
Add to `src/aishell/docker/volume.clj`:

Add requires: `[aishell.docker.build :as build]`, `[aishell.docker.spinner :as spinner]`, `[aishell.output :as output]`

Implement `populate-volume` function:

Takes: `volume-name` (string), `state` (state map from state.edn), and optional `opts` map with `:verbose` key.

Logic:
1. Build a shell command string that will run inside a temporary container:
   - `export NPM_CONFIG_PREFIX=/tools/npm`
   - For each enabled harness in state, add `npm install -g {package}@{version}`:
     - `:with-claude` true -> `npm install -g @anthropic-ai/claude-code@{:claude-version or "latest"}`
     - `:with-opencode` true -> skip (opencode is a Go binary, not npm - stays in foundation)
     - `:with-codex` true -> `npm install -g @openai/codex@{:codex-version or "latest"}`
     - `:with-gemini` true -> `npm install -g @anthropic-ai/claude-code` ... wait.

   Correct npm package names (verify from existing codebase patterns):
   - Claude Code: `@anthropic-ai/claude-code`
   - Codex: `@openai/codex`
   - Gemini CLI: `@anthropic-ai/claude-code` ... no.

   IMPORTANT: Check the actual npm package names. Look at the existing Dockerfile templates or build code. The packages are:
   - Claude Code: the npm package name (check templates or prior code)
   - Codex: the npm package name
   - Gemini: the npm package name

   Since Phase 35 stripped harness installs from the foundation Dockerfile, check git history or the research doc. From the research doc: `npm install -g claude-code@2.0.22 codex@0.89.0 gemini-cli@latest`. So the package names are:
   - `claude-code` (for Claude Code)
   - `codex` (for Codex CLI - note: might be `@openai/codex` now)
   - `gemini-cli` (for Gemini CLI - note: might be `@anthropic-ai/claude-code` ... no, it's `@anthropic-ai/claude-code` is Claude)

   Actually, use a helper map to map harness keys to npm package names:
   ```clojure
   (def harness-npm-packages
     "Map of harness key to npm package name."
     {:claude "claude-code"
      :codex "codex"
      :gemini "gemini-cli"})
   ```
   Note: opencode is NOT an npm package (it's a Go binary installed differently), so it's excluded.

2. Build the npm install commands string:
   ```
   export NPM_CONFIG_PREFIX=/tools/npm && \
   npm install -g claude-code@2.0.22 codex@0.89.0 && \
   chmod -R a+rX /tools
   ```

3. Run the population container:
   ```
   docker run --rm -v {volume-name}:/tools {foundation-image-tag} sh -c "{install-commands}"
   ```
   Use `build/foundation-image-tag` for the image.

4. Output handling:
   - If `:verbose` in opts, use `:inherit` for stdout/stderr
   - Otherwise, wrap in `spinner/with-spinner "Populating harness volume"`
   - On failure (non-zero exit), call `output/error` with message

5. Return `{:success true :volume volume-name}` on success.

Also implement a helper function `build-install-commands` that takes the state map and returns the shell command string. This makes it testable without Docker.

Do NOT include opencode in the npm package map - it's a Go binary that stays in the foundation image or is installed differently.
  </action>
  <verify>
Use nREPL to verify:

```clojure
(require '[aishell.docker.volume :as vol] :reload)

;; Test build-install-commands produces correct shell string
(let [cmds (vol/build-install-commands
             {:with-claude true :claude-version "2.0.22"
              :with-codex true :codex-version "0.89.0"
              :with-gemini false :gemini-version nil})]
  (assert (clojure.string/includes? cmds "NPM_CONFIG_PREFIX=/tools/npm"))
  (assert (clojure.string/includes? cmds "claude-code@2.0.22"))
  (assert (clojure.string/includes? cmds "codex@0.89.0"))
  (assert (not (clojure.string/includes? cmds "gemini")))
  (assert (clojure.string/includes? cmds "chmod -R a+rX /tools")))

;; Test with latest versions (nil version)
(let [cmds (vol/build-install-commands
             {:with-claude true :claude-version nil})]
  (assert (clojure.string/includes? cmds "claude-code@latest")))
```

Full integration test (creates actual Docker volume - run only if Docker available):

```clojure
;; Integration: create volume, populate, check label
(let [state {:with-claude true :claude-version "2.0.22"}
      hash-val (vol/compute-harness-hash state)
      vname (vol/volume-name hash-val)]
  ;; Clean up if exists from prior test
  (when (vol/volume-exists? vname)
    (babashka.process/shell "docker" "volume" "rm" vname))
  ;; Create with labels
  (vol/create-volume vname {"aishell.harness.hash" hash-val})
  (assert (vol/volume-exists? vname))
  (assert (= hash-val (vol/get-volume-label vname "aishell.harness.hash")))
  ;; Clean up
  (babashka.process/shell "docker" "volume" "rm" vname)
  (println "Integration test passed"))
```

Note: Skip the full `populate-volume` integration test here (takes minutes to download npm packages). The `build-install-commands` unit test covers the logic. Full population will be tested during Phase 37 integration.
  </verify>
  <done>
  - `volume-exists?` returns correct boolean for existing/non-existing volumes
  - `get-volume-label` retrieves label values from Docker volumes
  - `create-volume` creates Docker volumes with metadata labels
  - `build-install-commands` generates correct npm install command string with proper package names and versions
  - `populate-volume` runs Docker container to install harness tools into volume
  - Permissions set with `chmod -R a+rX /tools` for non-root execution
  - OpenCode excluded from npm installation (Go binary, not npm package)
  </done>
</task>

</tasks>

<verification>
1. Namespace loads cleanly with all new functions
2. `build-install-commands` produces correct shell commands for various harness combinations
3. `volume-exists?` returns false for non-existent volumes
4. `create-volume` + `get-volume-label` round-trip works (create volume with label, read it back)
5. `populate-volume` function exists and accepts correct arguments
</verification>

<success_criteria>
- Volume CRUD operations work against Docker daemon
- Install command generation is correct for all harness combinations
- Volume labels store harness hash for staleness detection
- Permissions handling included in population script
- OpenCode correctly excluded from npm installation
</success_criteria>

<output>
After completion, create `.planning/phases/36-harness-volume-core/36-02-SUMMARY.md`
</output>
