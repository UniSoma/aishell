---
phase: 36-harness-volume-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/aishell/docker/volume.clj
autonomous: true

must_haves:
  truths:
    - "Same harness flags and versions always produce the same hash"
    - "Different harness flags or versions produce different hashes"
    - "Volume name follows pattern aishell-harness-{12-char-hash}"
    - "Disabled harnesses are excluded from hash computation"
    - "Harness order does not affect hash (deterministic sorting)"
  artifacts:
    - path: "src/aishell/docker/volume.clj"
      provides: "Harness hash computation and volume naming"
      exports: ["normalize-harness-config", "compute-harness-hash", "volume-name"]
  key_links:
    - from: "src/aishell/docker/volume.clj"
      to: "src/aishell/docker/hash.clj"
      via: "hash/compute-hash for SHA-256"
      pattern: "hash/compute-hash"
---

<objective>
Implement deterministic harness hash computation that derives a stable volume name from harness flags and versions.

Purpose: Volume names must be deterministic so that projects with identical harness combinations share the same volume (HVOL-03, HVOL-06, BUILD-03). The hash must be independent of map iteration order, disabled harnesses, and foundation image changes.

Output: New `aishell.docker.volume` namespace with `normalize-harness-config`, `compute-harness-hash`, and `volume-name` functions.
</objective>

<execution_context>
@/home/jonasrodrigues/.claude/get-shit-done/workflows/execute-plan.md
@/home/jonasrodrigues/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/36-harness-volume-core/36-RESEARCH.md
@src/aishell/docker/hash.clj
@src/aishell/state.clj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create volume namespace with harness hash computation</name>
  <files>src/aishell/docker/volume.clj</files>
  <action>
Create `src/aishell/docker/volume.clj` with namespace `aishell.docker.volume`.

Require: `[aishell.docker.hash :as hash]`

Implement three public functions:

1. `normalize-harness-config` - Takes a state map (same shape as state.edn: `{:with-claude true, :claude-version "2.0.22", :with-opencode false, ...}`) and returns a sorted, canonical representation suitable for hashing.

   Logic:
   - Extract harness entries: claude, opencode, codex, gemini
   - For each harness, include ONLY if the `:with-{name}` key is truthy
   - For included harnesses, capture the version (`:${name}-version`) or "latest" if nil
   - Sort by harness name alphabetically
   - Return as a sorted vector of pairs: `[[:claude "2.0.22"] [:codex "latest"]]`

   This ensures:
   - Disabled harnesses don't affect hash (BUILD-03)
   - Map iteration order doesn't matter (deterministic)
   - Same flags/versions always produce same canonical form

2. `compute-harness-hash` - Takes a state map, normalizes it, serializes with `pr-str`, and passes to `hash/compute-hash`. Returns 12-char hex string.

3. `volume-name` - Takes a hash string, returns `"aishell-harness-{hash}"` (HVOL-03 naming pattern).

IMPORTANT: The input is the state map from `state/read-state`, NOT a nested map. The state schema is flat:
```clojure
{:with-claude true
 :claude-version "2.0.22"
 :with-opencode false
 :opencode-version nil
 :with-codex true
 :codex-version "0.89.0"
 :with-gemini false
 :gemini-version nil
 ...}
```

Add docstrings to all functions explaining inputs, outputs, and determinism guarantees.
  </action>
  <verify>
Use nREPL to verify:

```clojure
(require '[aishell.docker.volume :as vol])

;; Test 1: normalize produces sorted pairs, excludes disabled
(assert (= [[:claude "2.0.22"] [:codex "0.89.0"]]
           (vol/normalize-harness-config
             {:with-claude true :claude-version "2.0.22"
              :with-opencode false :opencode-version nil
              :with-codex true :codex-version "0.89.0"
              :with-gemini false :gemini-version nil})))

;; Test 2: nil version becomes "latest"
(assert (= [[:claude "latest"]]
           (vol/normalize-harness-config
             {:with-claude true :claude-version nil
              :with-opencode false})))

;; Test 3: same config always same hash
(let [state {:with-claude true :claude-version "2.0.22" :with-codex true :codex-version "0.89.0"}]
  (assert (= (vol/compute-harness-hash state)
             (vol/compute-harness-hash state))))

;; Test 4: different config different hash
(assert (not= (vol/compute-harness-hash {:with-claude true :claude-version "2.0.22"})
              (vol/compute-harness-hash {:with-claude true :claude-version "2.0.23"})))

;; Test 5: volume name format
(assert (clojure.string/starts-with?
          (vol/volume-name "abc123def456") "aishell-harness-"))

;; Test 6: order independence - these should produce same hash
(assert (= (vol/compute-harness-hash {:with-codex true :codex-version "1.0"
                                       :with-claude true :claude-version "2.0"})
           (vol/compute-harness-hash {:with-claude true :claude-version "2.0"
                                       :with-codex true :codex-version "1.0"})))
```
  </verify>
  <done>
  - `normalize-harness-config` correctly extracts enabled harnesses with versions, sorted alphabetically
  - `compute-harness-hash` returns deterministic 12-char hex hash
  - `volume-name` returns `aishell-harness-{hash}` string
  - Same input always produces same output regardless of map key order
  - Disabled harnesses are excluded from computation
  </done>
</task>

</tasks>

<verification>
1. Load namespace in nREPL without errors
2. All 6 test assertions pass
3. Hash is exactly 12 characters of hex
4. Volume name matches `aishell-harness-{12-char-hex}` pattern
</verification>

<success_criteria>
- `aishell.docker.volume` namespace loads cleanly
- Harness hash is deterministic (same input = same output)
- Disabled harnesses excluded from hash
- Map key order does not affect hash
- Volume naming follows `aishell-harness-{hash}` pattern
</success_criteria>

<output>
After completion, create `.planning/phases/36-harness-volume-core/36-01-SUMMARY.md`
</output>
