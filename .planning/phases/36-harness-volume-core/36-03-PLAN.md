---
phase: 36-harness-volume-core
plan: 03
type: execute
wave: 2
depends_on: ["36-01"]
files_modified:
  - src/aishell/docker/run.clj
  - src/aishell/docker/templates.clj
autonomous: true

must_haves:
  truths:
    - "Harness volume is mounted read-only at /tools in the container"
    - "PATH inside container includes /tools/npm/bin before existing PATH"
    - "NODE_PATH is set to /tools/npm/lib/node_modules inside container"
    - "Volume mount only added when harness volume name is provided (not nil)"
    - "PATH/NODE_PATH configured in entrypoint script with directory existence check"
  artifacts:
    - path: "src/aishell/docker/run.clj"
      provides: "Harness volume mount and env args in docker run command"
    - path: "src/aishell/docker/templates.clj"
      provides: "PATH/NODE_PATH configuration in entrypoint script"
  key_links:
    - from: "src/aishell/docker/run.clj"
      to: "docker run -v"
      via: "volume mount argument in build-docker-args-internal"
      pattern: "-v.*:/tools"
    - from: "src/aishell/docker/templates.clj"
      to: "entrypoint PATH setup"
      via: "/tools/npm/bin in PATH"
      pattern: "/tools/npm/bin"
---

<objective>
Wire harness volume mount into docker run arguments and configure PATH/NODE_PATH in the entrypoint script so volume-mounted harness tools are executable at runtime.

Purpose: This completes the runtime side of volume-based harness injection (HVOL-02). Containers must be able to find and execute harness binaries (claude, codex, gemini) from the mounted volume without any changes to how users invoke commands.

Output: Updated `docker/run.clj` with volume mount arguments and updated `templates.clj` entrypoint with PATH/NODE_PATH configuration.
</objective>

<execution_context>
@/home/jonasrodrigues/.claude/get-shit-done/workflows/execute-plan.md
@/home/jonasrodrigues/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/36-harness-volume-core/36-RESEARCH.md
@.planning/phases/36-harness-volume-core/36-01-SUMMARY.md
@src/aishell/docker/run.clj
@src/aishell/docker/templates.clj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add harness volume mount to docker run arguments</name>
  <files>src/aishell/docker/run.clj</files>
  <action>
Modify `src/aishell/docker/run.clj` to support harness volume mounting.

1. Add a new private function `build-harness-volume-args`:
   ```clojure
   (defn- build-harness-volume-args
     "Build -v flag for harness volume mount.
      Mounts volume read-only at /tools.
      Returns empty vector if volume-name is nil."
     [volume-name]
     (if volume-name
       ["-v" (str volume-name ":/tools:ro")]
       []))
   ```

2. Add a new private function `build-harness-env-args`:
   ```clojure
   (defn- build-harness-env-args
     "Build -e flags for harness tool PATH/NODE_PATH configuration.
      These are always added when a harness volume is mounted.
      The entrypoint also handles PATH setup, but these ensure
      the environment is correct even for non-bash entry points."
     [volume-name]
     (if volume-name
       ["-e" "HARNESS_VOLUME=true"]
       []))
   ```
   Note: We set HARNESS_VOLUME=true as a signal to the entrypoint rather than trying to set PATH via `-e` (which doesn't expand `$PATH` properly). The actual PATH modification happens in the entrypoint script (Task 2).

3. Update `build-docker-args-internal` to accept `:harness-volume-name` in its parameter map.

   Add the volume mount and env args BEFORE the config mounts section (so harness volume is mounted before user-specified mounts). Insert after the "Disable autoupdater" block and before "Config: mounts":

   ```clojure
   ;; Harness volume mount (volume-mounted harness tools)
   (into (build-harness-volume-args harness-volume-name))
   (into (build-harness-env-args harness-volume-name))
   ```

4. Update `build-docker-args` function signature to accept and pass `:harness-volume-name`:
   - Add `:harness-volume-name` to the destructured keys
   - Pass it through to `build-docker-args-internal`

5. Update `build-docker-args-for-exec` similarly:
   - Add `:harness-volume-name` to the destructured keys
   - Pass it through to `build-docker-args-internal`

IMPORTANT: Do NOT modify how callers invoke these functions yet. The callers (run.clj, etc.) will be updated in Phase 37 when lazy population is wired in. For now, the parameter is optional and defaults to nil (no volume mount).
  </action>
  <verify>
Use nREPL to verify:

```clojure
(require '[aishell.docker.run :as dr] :reload)

;; Test: build-docker-args with harness volume produces -v flag
(let [args (dr/build-docker-args
             {:project-dir "/tmp/test"
              :image-tag "aishell:foundation"
              :config nil
              :git-identity {:name "Test" :email "test@test.com"}
              :harness-volume-name "aishell-harness-abc123"})]
  (assert (some #(= % "aishell-harness-abc123:/tools:ro") args)
          "Should contain volume mount"))

;; Test: build-docker-args without harness volume has no /tools mount
(let [args (dr/build-docker-args
             {:project-dir "/tmp/test"
              :image-tag "aishell:foundation"
              :config nil
              :git-identity {:name "Test" :email "test@test.com"}})]
  (assert (not-any? #(clojure.string/includes? (str %) "/tools") args)
          "Should not contain /tools mount"))

;; Test: build-docker-args-for-exec also supports harness volume
(let [args (dr/build-docker-args-for-exec
             {:project-dir "/tmp/test"
              :image-tag "aishell:foundation"
              :config nil
              :git-identity {:name "Test" :email "test@test.com"}
              :tty? true
              :harness-volume-name "aishell-harness-abc123"})]
  (assert (some #(= % "aishell-harness-abc123:/tools:ro") args)
          "Exec should also contain volume mount"))
```
  </verify>
  <done>
  - `build-docker-args` accepts optional `:harness-volume-name` parameter
  - When provided, adds `-v volume-name:/tools:ro` to docker run args
  - When nil/absent, no volume mount is added (backward compatible)
  - `build-docker-args-for-exec` also supports the parameter
  - HARNESS_VOLUME env var signals entrypoint to configure PATH
  </done>
</task>

<task type="auto">
  <name>Task 2: Add PATH/NODE_PATH configuration to entrypoint script</name>
  <files>src/aishell/docker/templates.clj</files>
  <action>
Modify the `entrypoint-script` string in `src/aishell/docker/templates.clj` to configure PATH and NODE_PATH for volume-mounted harness tools.

Add the following block AFTER the existing `export PATH="$HOME/.local/bin:/usr/local/bin:$PATH"` line and BEFORE the `export DISABLE_INSTALLATION_CHECKS=1` line:

```bash
# Volume-mounted harness tools PATH configuration (Phase 36)
# HARNESS_VOLUME is set by docker run -e when a harness volume is mounted
if [ -d "/tools/npm/bin" ]; then
  export PATH="/tools/npm/bin:$PATH"
  export NODE_PATH="/tools/npm/lib/node_modules"
fi
```

This approach:
- Uses directory existence check (`-d`) rather than env var check for robustness
- Adds /tools/npm/bin to the FRONT of PATH so harness tools are found first
- Sets NODE_PATH for Node.js module resolution
- Has <1ms overhead (single stat call)
- Is safe when no volume is mounted (directory won't exist, block is skipped)

The PATH order becomes: `/tools/npm/bin` -> `$HOME/.local/bin` -> `/usr/local/bin` -> system PATH

This is correct because:
- Harness tools in /tools/npm/bin should take precedence (they are the versions user requested)
- User's local bin is next (for user-installed tools)
- System tools are last (fallback)
  </action>
  <verify>
Verify the entrypoint script string contains the PATH configuration:

```clojure
(require '[aishell.docker.templates :as tmpl] :reload)

;; Verify PATH configuration block exists
(assert (clojure.string/includes? tmpl/entrypoint-script "/tools/npm/bin"))
(assert (clojure.string/includes? tmpl/entrypoint-script "NODE_PATH=/tools/npm/lib/node_modules"))
(assert (clojure.string/includes? tmpl/entrypoint-script "if [ -d \"/tools/npm/bin\" ]"))

;; Verify PATH order: /tools/npm/bin should appear AFTER $HOME/.local/bin line
;; but BEFORE DISABLE_INSTALLATION_CHECKS
(let [tools-idx (clojure.string/index-of tmpl/entrypoint-script "/tools/npm/bin")
      local-bin-idx (clojure.string/index-of tmpl/entrypoint-script "$HOME/.local/bin")
      disable-idx (clojure.string/index-of tmpl/entrypoint-script "DISABLE_INSTALLATION_CHECKS")]
  (assert (> tools-idx local-bin-idx) "tools PATH should be after .local/bin line")
  (assert (< tools-idx disable-idx) "tools PATH should be before DISABLE_INSTALLATION_CHECKS"))
```
  </verify>
  <done>
  - Entrypoint script configures PATH with /tools/npm/bin prepended
  - NODE_PATH set to /tools/npm/lib/node_modules
  - Configuration only activates when /tools/npm/bin directory exists
  - PATH order is correct: harness tools -> user local -> system
  - No impact when no harness volume is mounted
  </done>
</task>

</tasks>

<verification>
1. `docker/run.clj` loads cleanly with new functions
2. `templates.clj` loads cleanly with updated entrypoint
3. Docker args include volume mount when harness-volume-name provided
4. Docker args omit volume mount when harness-volume-name is nil
5. Entrypoint script contains PATH/NODE_PATH configuration
6. Entrypoint PATH configuration is conditional on /tools/npm/bin existence
</verification>

<success_criteria>
- Volume mount argument `-v name:/tools:ro` correctly added to docker run
- Both `build-docker-args` and `build-docker-args-for-exec` support harness volume
- Entrypoint configures PATH to include /tools/npm/bin
- Entrypoint configures NODE_PATH for module resolution
- No changes when harness-volume-name is nil (backward compatible)
- Existing callers continue working without modification
</success_criteria>

<output>
After completion, create `.planning/phases/36-harness-volume-core/36-03-SUMMARY.md`
</output>
