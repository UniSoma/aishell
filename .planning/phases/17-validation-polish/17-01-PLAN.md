---
phase: 17-validation-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/aishell/cli.clj
  - src/aishell/docker/build.clj
  - src/aishell/state.clj
autonomous: true

must_haves:
  truths:
    - "User can run `aishell build --force` to bypass Docker cache"
    - "User can run `aishell update` to rebuild with latest versions"
    - "Update preserves existing build flags (--with-claude version, etc.)"
    - "Dockerfile hash is stored in state.edn after build"
  artifacts:
    - path: "src/aishell/cli.clj"
      provides: "update command handler and build --force flag"
      contains: "handle-update"
    - path: "src/aishell/docker/build.clj"
      provides: "--no-cache support when force is true"
      contains: "--no-cache"
    - path: "src/aishell/state.clj"
      provides: "Dockerfile hash in state schema"
      contains: "dockerfile-hash"
  key_links:
    - from: "src/aishell/cli.clj:handle-update"
      to: "src/aishell/docker/build.clj:build-base-image"
      via: "calls with :force true"
      pattern: ":force true"
    - from: "src/aishell/cli.clj:handle-build"
      to: "src/aishell/state.clj:write-state"
      via: "writes :dockerfile-hash"
      pattern: ":dockerfile-hash"
---

<objective>
Implement build --force flag and update command for image rebuilding.

Purpose: Enable users to force rebuild (bypassing Docker cache) and update to latest harness versions while preserving their build configuration.

Output: Updated cli.clj with update command and --force flag, build.clj with --no-cache support, state.clj with dockerfile-hash storage.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-validation-polish/17-CONTEXT.md
@.planning/phases/17-validation-polish/17-RESEARCH.md

@src/aishell/cli.clj
@src/aishell/docker/build.clj
@src/aishell/state.clj
@src/aishell/docker/hash.clj
@src/aishell/docker/templates.clj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add --force flag to build and pass --no-cache to Docker</name>
  <files>
    - src/aishell/cli.clj
    - src/aishell/docker/build.clj
  </files>
  <action>
  1. In cli.clj, add `:force` to build-spec:
     ```clojure
     :force {:coerce :boolean :desc "Force rebuild (bypass Docker cache)"}
     ```

  2. In cli.clj handle-build, pass force flag to build:
     - Change `:force true` (currently hardcoded) to `:force (:force opts)`
     - This lets user control cache behavior

  3. In build.clj run-build, add force? parameter:
     - Update signature to accept force? parameter
     - When force? is true, add "--no-cache" to docker build command:
       ```clojure
       (when force? ["--no-cache"])
       ```

  4. In build.clj build-base-image:
     - Pass :force to run-build calls
     - Update the three run-build call sites (verbose, quiet, spinner modes)

  5. Update print-build-help in cli.clj to include --force in examples:
     ```clojure
     (println (str "  " output/CYAN "aishell build --force" output/NC "               Force rebuild"))
     ```
  </action>
  <verify>
  - `./aishell build --help` shows --force flag
  - `./aishell build --force --verbose` shows Docker using --no-cache
  </verify>
  <done>
  - build-spec includes :force with boolean coercion
  - Docker build includes --no-cache when force is true
  - Help output documents the flag
  </done>
</task>

<task type="auto">
  <name>Task 2: Store dockerfile-hash in state.edn during build</name>
  <files>
    - src/aishell/cli.clj
    - src/aishell/state.clj
  </files>
  <action>
  1. In state.clj, update docstring to include :dockerfile-hash in schema:
     ```clojure
     ;; State schema:
     ;; {:with-claude true
     ;;  :with-opencode false
     ;;  ...
     ;;  :dockerfile-hash "abc123def456"}  ; 12-char SHA-256 hash
     ```

  2. In cli.clj handle-build, after successful build:
     - Import aishell.docker.hash and aishell.docker.templates at top
     - Compute dockerfile hash: `(hash/compute-hash templates/base-dockerfile)`
     - Add :dockerfile-hash to state write:
       ```clojure
       (state/write-state
         {:with-claude (:enabled? claude-config)
          ...
          :dockerfile-hash (hash/compute-hash templates/base-dockerfile)})
       ```

  3. Add requires to cli.clj:
     ```clojure
     [aishell.docker.hash :as hash]
     [aishell.docker.templates :as templates]
     ```
  </action>
  <verify>
  - `./aishell build --with-claude`
  - `cat ~/.aishell/state.edn` shows :dockerfile-hash key with 12-char value
  </verify>
  <done>
  - state.edn includes :dockerfile-hash after every build
  - Hash is computed from templates/base-dockerfile
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement update command</name>
  <files>
    - src/aishell/cli.clj
  </files>
  <action>
  1. Create handle-update function in cli.clj:
     ```clojure
     (defn handle-update [{:keys [opts]}]
       ;; Read existing state
       (let [state (state/read-state)]
         ;; Must have prior build
         (when-not state
           (output/error "No previous build found. Run: aishell build"))

         ;; Show what we're updating
         (println "Updating with preserved configuration...")
         (when (:with-claude state)
           (println (str "  Claude Code: " (or (:claude-version state) "latest"))))
         (when (:with-opencode state)
           (println (str "  OpenCode: " (or (:opencode-version state) "latest"))))

         ;; Rebuild with same config + force (always --no-cache for update)
         (let [result (build/build-base-image
                        {:with-claude (:with-claude state)
                         :with-opencode (:with-opencode state)
                         :claude-version (:claude-version state)
                         :opencode-version (:opencode-version state)
                         :verbose (:verbose opts)
                         :force true})]  ; Always force for update

           ;; Update state with new build-time and hash
           (state/write-state
             (assoc state
                    :image-tag (:image result)
                    :build-time (str (java.time.Instant/now))
                    :dockerfile-hash (hash/compute-hash templates/base-dockerfile))))))
     ```

  2. Add update command to dispatch-table:
     ```clojure
     {:cmds ["update"] :fn handle-update :spec {:verbose {:alias :v :coerce :boolean}} :restrict true}
     ```
     Place it after build but before the empty cmds catch-all.

  3. Note: "update" is already in output.clj known-commands (line 19), so command suggestions work.
  </action>
  <verify>
  - `./aishell build --with-claude` (initial build)
  - `./aishell update` rebuilds with same --with-claude flag
  - `cat ~/.aishell/state.edn` shows updated :build-time
  </verify>
  <done>
  - `aishell update` reads state and rebuilds with preserved flags
  - Update always uses --no-cache (force rebuild)
  - State is updated with new build-time and dockerfile-hash
  </done>
</task>

</tasks>

<verification>
1. Build force flag:
   - `./aishell build --help` shows --force option
   - `./aishell build --force --verbose 2>&1 | grep -i cache` shows --no-cache being used

2. Dockerfile hash storage:
   - `./aishell build --with-claude`
   - `cat ~/.aishell/state.edn | grep dockerfile-hash` shows 12-char hash

3. Update command:
   - `./aishell update` without prior build shows "No previous build found"
   - `./aishell build --with-claude=2.0.22`
   - `./aishell update` rebuilds with Claude Code 2.0.22
   - Build output shows "--no-cache" behavior (network fetches even if cached)
</verification>

<success_criteria>
- [ ] `aishell build --force` bypasses Docker cache
- [ ] `aishell update` rebuilds with preserved configuration
- [ ] state.edn includes :dockerfile-hash after build
- [ ] No regressions in existing build behavior
</success_criteria>

<output>
After completion, create `.planning/phases/17-validation-polish/17-01-SUMMARY.md`
</output>
