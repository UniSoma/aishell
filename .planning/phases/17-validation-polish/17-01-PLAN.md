---
phase: 17-validation-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/aishell/cli.clj
  - src/aishell/docker/build.clj
  - src/aishell/state.clj
autonomous: true

must_haves:
  truths:
    - "User can run `aishell build --force` to bypass Docker cache"
    - "User can run `aishell update` to rebuild with latest versions"
    - "Update preserves existing build flags (--with-claude version, etc.)"
    - "Build configuration (including dockerfile hash) persists for stale image detection"
    - "Invalid version strings (e.g., 1.0; rm -rf /) are rejected with clear error"
  artifacts:
    - path: "src/aishell/cli.clj"
      provides: "update command handler and build --force flag"
      contains: "handle-update"
    - path: "src/aishell/docker/build.clj"
      provides: "--no-cache support when force is true"
      contains: "--no-cache"
    - path: "src/aishell/state.clj"
      provides: "Dockerfile hash in state schema"
      contains: "dockerfile-hash"
  key_links:
    - from: "src/aishell/cli.clj:handle-update"
      to: "src/aishell/docker/build.clj:build-base-image"
      via: "calls with :force true"
      pattern: ":force true"
    - from: "src/aishell/cli.clj:handle-build"
      to: "src/aishell/state.clj:write-state"
      via: "writes :dockerfile-hash"
      pattern: ":dockerfile-hash"
  design_notes:
    - "update = force rebuild with preserved state (per 17-CONTEXT.md line 54), NOT a 'check for updates' command"
---

<objective>
Implement build --force flag and update command for image rebuilding.

Purpose: Enable users to force rebuild (bypassing Docker cache) and update to latest harness versions while preserving their build configuration.

Output: Updated cli.clj with update command and --force flag, build.clj with --no-cache support, state.clj with dockerfile-hash storage.

Note: "update" means force rebuild with preserved state (not a version check command) — this matches the design decision in 17-CONTEXT.md.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-validation-polish/17-CONTEXT.md
@.planning/phases/17-validation-polish/17-RESEARCH.md

@src/aishell/cli.clj
@src/aishell/docker/build.clj
@src/aishell/state.clj
@src/aishell/docker/hash.clj
@src/aishell/docker/templates.clj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify version validation rejects malicious inputs (VAL-01)</name>
  <files>
    - (none - verification only)
  </files>
  <action>
  Version validation already exists in cli.clj:18-33 (validate-version function with dangerous-chars pattern).
  This task verifies the existing implementation meets VAL-01 requirements.

  Test the following malicious version strings and confirm rejection:
  1. Shell injection attempts:
     - `./aishell build --with-claude="1.0; rm -rf /"` - semicolon injection
     - `./aishell build --with-claude="1.0 && echo pwned"` - command chaining
     - `./aishell build --with-claude='$(whoami)'` - command substitution
     - `./aishell build --with-claude="\`id\`"` - backtick substitution

  2. Invalid format (non-semver):
     - `./aishell build --with-claude="abc"` - not a version
     - `./aishell build --with-claude="1.0"` - missing patch version

  3. Valid versions (should succeed):
     - `./aishell build --with-claude=2.0.22` - exact semver
     - `./aishell build --with-claude=1.0.0-beta.1` - prerelease

  All malicious inputs should exit with "Invalid Claude Code version" error.
  Valid inputs should proceed to build (or fail on Docker if not installed).
  </action>
  <verify>
  - `./aishell build --with-claude="1.0; rm -rf /" 2>&1 | grep -q "Invalid"` returns 0 (found error)
  - `./aishell build --with-claude='$(whoami)' 2>&1 | grep -q "Invalid"` returns 0 (found error)
  - `./aishell build --with-claude=2.0.22 2>&1 | head -1` does NOT contain "Invalid" (proceeds to build)
  </verify>
  <done>
  - Shell metacharacters (;, &, |, $, backticks) are rejected with clear error message
  - Non-semver formats are rejected with format guidance
  - Valid semver versions are accepted
  - VAL-01 requirement confirmed met by existing implementation
  </done>
</task>

<task type="auto">
  <name>Task 2: Add --force flag to build and pass --no-cache to Docker</name>
  <files>
    - src/aishell/cli.clj
    - src/aishell/docker/build.clj
  </files>
  <action>
  1. In cli.clj, add `:force` to build-spec:
     ```clojure
     :force {:coerce :boolean :desc "Force rebuild (bypass Docker cache)"}
     ```

  2. In cli.clj handle-build, pass force flag to build:
     - Change `:force true` (currently hardcoded) to `:force (:force opts)`
     - This lets user control cache behavior

  3. In build.clj run-build (line 70), update signature to accept force? parameter:
     Current: `(defn- run-build [build-dir tag args verbose?]`
     New:     `(defn- run-build [build-dir tag args verbose? force?]`

  4. In run-build, add --no-cache when force? is true:
     ```clojure
     (let [cmd (vec (concat ["docker" "build" "-t" tag]
                            (when force? ["--no-cache"])
                            (when verbose? ["--progress=plain"])
                            args
                            ["."]))]
     ```

  5. Update ALL THREE run-build call sites in build-base-image to pass force flag:
     - Line 131 (verbose mode):   `(run-build build-dir base-image-tag docker-args true force)`
     - Line 134 (quiet mode):     `(run-build build-dir base-image-tag docker-args false force)`
     - Line 138 (spinner mode):   `(run-build build-dir base-image-tag docker-args false force)`
     (where `force` comes from the opts destructuring on line 108)

  6. Update print-build-help in cli.clj to include --force in examples:
     ```clojure
     (println (str "  " output/CYAN "aishell build --force" output/NC "               Force rebuild"))
     ```
  </action>
  <verify>
  - `./aishell build --help` shows --force flag
  - `./aishell build --force --verbose` shows Docker using --no-cache
  </verify>
  <done>
  - build-spec includes :force with boolean coercion
  - run-build signature includes force? parameter
  - Docker build includes --no-cache when force is true
  - All three run-build call sites pass force flag
  - Help output documents the flag
  </done>
</task>

<task type="auto">
  <name>Task 3: Store dockerfile-hash in state.edn during build</name>
  <files>
    - src/aishell/cli.clj
    - src/aishell/state.clj
  </files>
  <action>
  1. In state.clj, update docstring to include :dockerfile-hash in schema:
     ```clojure
     ;; State schema:
     ;; {:with-claude true
     ;;  :with-opencode false
     ;;  ...
     ;;  :dockerfile-hash "abc123def456"}  ; 12-char SHA-256 hash
     ```

  2. In cli.clj handle-build, after successful build:
     - Import aishell.docker.hash and aishell.docker.templates at top
     - Compute dockerfile hash: `(hash/compute-hash templates/base-dockerfile)`
     - Add :dockerfile-hash to state write:
       ```clojure
       (state/write-state
         {:with-claude (:enabled? claude-config)
          ...
          :dockerfile-hash (hash/compute-hash templates/base-dockerfile)})
       ```

  3. Add requires to cli.clj:
     ```clojure
     [aishell.docker.hash :as hash]
     [aishell.docker.templates :as templates]
     ```
  </action>
  <verify>
  - `./aishell build --with-claude`
  - `cat ~/.aishell/state.edn` shows :dockerfile-hash key with 12-char value
  </verify>
  <done>
  - state.edn includes :dockerfile-hash after every build
  - Hash is computed from templates/base-dockerfile
  </done>
</task>

<task type="auto">
  <name>Task 4: Implement update command</name>
  <files>
    - src/aishell/cli.clj
  </files>
  <action>
  1. Create handle-update function in cli.clj:
     ```clojure
     (defn handle-update [{:keys [opts]}]
       ;; Read existing state
       (let [state (state/read-state)]
         ;; Must have prior build
         (when-not state
           (output/error "No previous build found. Run: aishell build"))

         ;; Show what we're updating
         (println "Updating with preserved configuration...")
         (when (:with-claude state)
           (println (str "  Claude Code: " (or (:claude-version state) "latest"))))
         (when (:with-opencode state)
           (println (str "  OpenCode: " (or (:opencode-version state) "latest"))))

         ;; Rebuild with same config + force (always --no-cache for update)
         (let [result (build/build-base-image
                        {:with-claude (:with-claude state)
                         :with-opencode (:with-opencode state)
                         :claude-version (:claude-version state)
                         :opencode-version (:opencode-version state)
                         :verbose (:verbose opts)
                         :force true})]  ; Always force for update

           ;; Update state with new build-time and hash
           (state/write-state
             (assoc state
                    :image-tag (:image result)
                    :build-time (str (java.time.Instant/now))
                    :dockerfile-hash (hash/compute-hash templates/base-dockerfile))))))
     ```

  2. Add update command to dispatch-table:
     ```clojure
     {:cmds ["update"] :fn handle-update :spec {:verbose {:alias :v :coerce :boolean}} :restrict true}
     ```
     Place it after build but before the empty cmds catch-all.

  3. Note: "update" is already in output.clj known-commands (line 19), so command suggestions work.

  Design note: "update" = force rebuild with preserved state. This is NOT a "check for updates"
  command — it always rebuilds. This matches the design decision in 17-CONTEXT.md line 54.
  </action>
  <verify>
  - `./aishell build --with-claude` (initial build)
  - `./aishell update` rebuilds with same --with-claude flag
  - `cat ~/.aishell/state.edn` shows updated :build-time
  </verify>
  <done>
  - `aishell update` reads state and rebuilds with preserved flags
  - Update always uses --no-cache (force rebuild)
  - State is updated with new build-time and dockerfile-hash
  </done>
</task>

</tasks>

<verification>
1. Version validation (VAL-01):
   - `./aishell build --with-claude="1.0; rm -rf /"` exits with "Invalid Claude Code version" error
   - `./aishell build --with-claude=2.0.22` proceeds to build (no Invalid error)

2. Build force flag:
   - `./aishell build --help` shows --force option
   - `./aishell build --force --verbose 2>&1 | grep -i cache` shows --no-cache being used

3. Dockerfile hash storage:
   - `./aishell build --with-claude`
   - `cat ~/.aishell/state.edn | grep dockerfile-hash` shows 12-char hash

4. Update command:
   - `./aishell update` without prior build shows "No previous build found"
   - `./aishell build --with-claude=2.0.22`
   - `./aishell update` rebuilds with Claude Code 2.0.22
   - Build output shows "--no-cache" behavior (network fetches even if cached)
</verification>

<success_criteria>
- [ ] Version validation rejects shell metacharacters with clear error (VAL-01)
- [ ] `aishell build --force` bypasses Docker cache
- [ ] `aishell update` rebuilds with preserved configuration
- [ ] state.edn includes :dockerfile-hash after build
- [ ] No regressions in existing build behavior
</success_criteria>

<output>
After completion, create `.planning/phases/17-validation-polish/17-01-SUMMARY.md`
</output>
