---
phase: 30-container-utilities-naming
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/aishell/docker/naming.clj
  - src/aishell/docker/hash.clj
  - src/aishell/cli.clj
  - src/aishell/run.clj
  - src/aishell/output.clj
autonomous: true

must_haves:
  truths:
    - "container-name function produces deterministic aishell-{8-char-hash}-{name} format"
    - "Same project directory always produces same hash regardless of path form (symlinks, trailing slashes)"
    - "Docker query functions (container-exists?, container-running?, list-project-containers) return correct state"
    - "Default container name equals the harness name (claude, opencode, codex, gemini)"
    - "User can pass --name flag to override container name on harness commands"
    - "Name length validated against 63-character Docker limit"
  artifacts:
    - path: "src/aishell/docker/naming.clj"
      provides: "Container naming utilities and Docker query functions"
      exports: ["project-hash", "container-name", "container-exists?", "container-running?", "remove-container-if-stopped!", "ensure-name-available!", "list-project-containers", "validate-container-name!"]
    - path: "src/aishell/docker/hash.clj"
      provides: "Updated compute-hash to accept optional length parameter"
      exports: ["compute-hash"]
  key_links:
    - from: "src/aishell/docker/naming.clj"
      to: "src/aishell/docker/hash.clj"
      via: "hash/compute-hash for SHA-256"
      pattern: "hash/compute-hash"
    - from: "src/aishell/docker/naming.clj"
      to: "babashka.fs"
      via: "fs/canonicalize for path normalization"
      pattern: "fs/canonicalize"
    - from: "src/aishell/run.clj"
      to: "src/aishell/docker/naming.clj"
      via: "require for name resolution"
      pattern: "naming/container-name"
    - from: "src/aishell/cli.clj"
      to: "src/aishell/run.clj"
      via: "--name flag passed through opts map"
      pattern: ":container-name"
---

<objective>
Create the container naming utility namespace and wire the --name CLI flag into the harness command flow.

Purpose: This is the foundation layer for v2.6.0. All subsequent phases (31-34) depend on these utilities for container naming, state queries, and conflict resolution. Without this, named containers, attach, and ps commands cannot work.

Output: `src/aishell/docker/naming.clj` with all naming and Docker query functions, plus `--name` flag support in CLI dispatch.
</objective>

<execution_context>
@/home/jonasrodrigues/.claude/get-shit-done/workflows/execute-plan.md
@/home/jonasrodrigues/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-container-utilities-naming/30-RESEARCH.md

Key source files to read before implementing:
@src/aishell/docker/hash.clj — existing SHA-256 pattern to reuse (compute-hash returns 12-char hex)
@src/aishell/docker.clj — existing Docker query patterns (exit code checks, p/shell with :continue true)
@src/aishell/docker/run.clj — build-docker-args and build-docker-args-for-exec (where --name flag will eventually be added in Phase 32)
@src/aishell/run.clj — run-container orchestration (where name resolution will be added)
@src/aishell/cli.clj — dispatch function (where --name flag parsing goes)
@src/aishell/output.clj — error/warn functions
@src/aishell/util.clj — utility patterns (get-home, expand-path)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create naming.clj namespace with all utility functions</name>
  <files>
    src/aishell/docker/naming.clj
    src/aishell/docker/hash.clj
  </files>
  <action>
Create `src/aishell/docker/naming.clj` with the following functions. Follow existing codebase patterns exactly (docstrings, require style, error handling with p/shell + :continue true).

**Namespace requires:**
```clojure
(ns aishell.docker.naming
  "Container naming and Docker state query utilities.
   Generates deterministic container names from project paths and provides
   functions to query Docker container state."
  (:require [babashka.fs :as fs]
            [babashka.process :as p]
            [clojure.string :as str]
            [aishell.docker.hash :as hash]
            [aishell.output :as output]))
```

**Functions to implement:**

1. `(project-hash project-dir)` - Canonicalize path with `(str (fs/canonicalize project-dir))`, then call `(subs (hash/compute-hash canonical) 0 8)` to get 8-char hex hash. The existing `hash/compute-hash` returns 12 chars, so just take first 8.

2. `(validate-container-name! name)` - Validate the user-provided name portion (not full container name). Must match `^[a-zA-Z0-9][a-zA-Z0-9_.-]*$` (Docker naming rules). Check that full name `aishell-XXXXXXXX-{name}` does not exceed 63 chars, meaning name portion max is 46 chars. Call `output/error` on failure (which exits).

3. `(container-name project-dir name)` - Generate `(str "aishell-" (project-hash project-dir) "-" name)`. Call `validate-container-name!` on the name portion first.

4. `(container-exists? container-name)` - Use `(p/shell {:out :string :err :string :continue true} "docker" "inspect" container-name)`, return `(zero? exit)`. Wrap in try/catch returning false.

5. `(container-running? container-name)` - Use `docker ps --filter "name=^{name}$" --format "{{.Names}}"`. Check exit is zero AND output exactly matches container-name. Use `(str/trim out)` for comparison. Wrap in try/catch returning false.

6. `(remove-container-if-stopped! container-name)` - Return `:running` if `container-running?`, `:removed` if `container-exists?` (run `docker rm -f`), or `:not-found`.

7. `(ensure-name-available! container-name harness-name)` - Case on `remove-container-if-stopped!` result. `:running` -> `output/error` with message showing attach and force-stop options. `:removed` -> println "Removed stopped container: {name}". `:not-found` -> nil (proceed).

8. `(list-project-containers project-dir)` - Use `docker ps -a --filter "name=^aishell-{hash}-" --format "{{.Names}}\t{{.Status}}\t{{.CreatedAt}}"`. Parse tab-separated output into vector of `{:name :status :created}` maps. Return empty vector on error or no output.

**Important implementation notes:**
- Do NOT modify `hash/compute-hash` signature. It already returns 12 chars which is fine -- just `subs` to 8 in `project-hash`.
- Use `fs/canonicalize` (not `fs/absolutize`) for symlink resolution.
- Use `^` and `$` anchors in Docker `--filter name=` to avoid substring matching.
- For `container-running?`, the `--format "{{.Names}}"` returns ONLY the name field, making exact comparison reliable.
- For `remove-container-if-stopped!`, the `-f` flag on `docker rm` handles edge cases where container is in "removing" state.
  </action>
  <verify>
Run `bb -e "(require '[aishell.docker.naming :as naming]) (println (naming/project-hash \".\")) (println (naming/container-name \".\" \"claude\"))"` from the project root. Should print an 8-char hex string and a container name in `aishell-XXXXXXXX-claude` format.

Verify determinism: Run the same command twice and confirm identical output.

Verify validation: `bb -e "(require '[aishell.docker.naming :as naming]) (naming/validate-container-name! \"claude\")"` should succeed. `bb -e "(require '[aishell.docker.naming :as naming]) (naming/validate-container-name! \"\")"` should error.
  </verify>
  <done>
naming.clj exists with all 8 functions. project-hash returns deterministic 8-char hex. container-name produces aishell-{hash}-{name} format. Docker query functions compile and handle errors gracefully. Name validation rejects invalid names and names that would exceed 63-char limit.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire --name flag into CLI dispatch and run-container</name>
  <files>
    src/aishell/cli.clj
    src/aishell/run.clj
    src/aishell/output.clj
  </files>
  <action>
**In `src/aishell/cli.clj`:**

1. Add `aishell.docker.naming` to the require vector:
   ```clojure
   [aishell.docker.naming :as naming]
   ```

2. Modify the `dispatch` function to extract `--name` from args before pass-through. The `--name` flag must be extracted BEFORE the harness command args are passed through (same pattern as `--unsafe`).

   In the `dispatch` function, after extracting `--unsafe` and `clean-args`, add `--name` extraction:
   ```clojure
   ;; Extract --name flag (--name VALUE format)
   ;; Must be extracted before pass-through to harness
   container-name-override (let [idx (.indexOf (vec clean-args) "--name")]
                             (when (and (>= idx 0) (< (inc idx) (count clean-args)))
                               (nth clean-args (inc idx))))
   clean-args (if container-name-override
                (let [idx (.indexOf (vec clean-args) "--name")]
                  (into (subvec (vec clean-args) 0 idx)
                        (subvec (vec clean-args) (+ idx 2))))
                clean-args)
   ```

3. Pass the container name to `run/run-container` via the opts map. Update each harness dispatch case to include `:container-name container-name-override` in the opts map:
   ```clojure
   "claude" (run/run-container "claude" (vec (rest clean-args))
              {:unsafe unsafe? :container-name container-name-override})
   ```
   Do this for all harness commands (claude, opencode, codex, gemini, gitleaks) and for the shell default path.

**In `src/aishell/run.clj`:**

1. Add `aishell.docker.naming` to the require vector:
   ```clojure
   [aishell.docker.naming :as naming]
   ```

2. In `run-container`, after resolving `project-dir`, compute the container name. Add this in the `let` block after `project-dir`:
   ```clojure
   ;; Resolve container name: --name override or harness name (or "shell" for shell mode)
   container-name-str (let [name-part (or (:container-name opts) cmd "shell")]
                        (naming/container-name project-dir name-part))
   ```

   Note: This computes the name but does NOT yet add `--name` to docker args. That happens in Phase 32 when detached mode is implemented. For now, just compute and log it for verification.

3. Add a verbose log line after computing the name:
   ```clojure
   _ (output/verbose (str "Container name: " container-name-str))
   ```

**In `src/aishell/output.clj`:**

Add "attach" and "ps" to the `known-commands` set for future command suggestion support:
```clojure
(def known-commands #{"build" "update" "check" "exec" "attach" "ps"
                      "claude" "opencode" "codex" "gemini" "gitleaks"})
```

**Important:**
- Do NOT add `--name` to the docker run args vector yet. Phase 32 handles that.
- Do NOT add `--name` to `build-spec` or any CLI spec -- it's extracted manually before dispatch (same as `--unsafe`).
- The `--name` flag extraction must handle the case where `--name` appears before the command: `aishell --name reviewer claude` and after: `aishell claude --name reviewer`. Since we extract before dispatch, both should work. However, to keep it simple and consistent with `--unsafe`, extract from the full args list before command routing.
- For shell mode (no command), the default name is "shell".
- For gitleaks, the default name is "gitleaks".
  </action>
  <verify>
Run `bb -cp src -m aishell.core -- --version` to confirm CLI still works (no require errors).

Test --name extraction: Run with verbose to see container name resolution:
```bash
# Should show "Container name: aishell-XXXXXXXX-claude" in verbose mode
bb -cp src -e "(binding [aishell.output/*verbose* true] (println \"test\"))"
```

Verify that harness commands still pass through args correctly by checking dispatch doesn't break:
```bash
bb -cp src -m aishell.core -- --help
```
  </verify>
  <done>
--name flag is extracted from CLI args before harness dispatch. Container name is resolved in run-container using naming/container-name with default=harness-name or --name override. Known commands updated with "attach" and "ps". All existing CLI functionality preserved (--help, --version, harness dispatch, --unsafe).
  </done>
</task>

</tasks>

<verification>
1. Deterministic naming: Run `bb -cp src -e "(require '[aishell.docker.naming :as n]) (println (n/container-name \".\" \"claude\"))"` twice from same directory -- output must be identical.

2. Path normalization: Run from project root using both absolute and relative paths:
   ```bash
   bb -cp src -e "(require '[aishell.docker.naming :as n]) (println (n/project-hash \".\"))"
   bb -cp src -e "(require '[aishell.docker.naming :as n]) (println (n/project-hash \"$(pwd)\"))"
   ```
   Both must produce the same hash.

3. Name validation: Invalid names are rejected:
   ```bash
   bb -cp src -e "(require '[aishell.docker.naming :as n]) (n/validate-container-name! \"valid-name\")"  # succeeds
   bb -cp src -e "(require '[aishell.docker.naming :as n]) (n/validate-container-name! \"has spaces\")"  # errors
   ```

4. CLI integration: `aishell --help` still works. No require errors on startup.

5. Docker queries: `container-exists?` and `container-running?` return false for non-existent container names (no crashes).
</verification>

<success_criteria>
- naming.clj exists with project-hash, container-name, validate-container-name!, container-exists?, container-running?, remove-container-if-stopped!, ensure-name-available!, list-project-containers
- Same directory always produces same 8-char hex hash (deterministic)
- Container name format: aishell-{8-char-hash}-{name}
- --name CLI flag extracted and passed to run-container
- Default name = harness name (claude/opencode/codex/gemini) or "shell"
- Name validation rejects invalid Docker names and names exceeding 46 chars
- All existing CLI functionality preserved (no regressions)
- Docker query functions handle errors gracefully (return false/empty, never crash)
</success_criteria>

<output>
After completion, create `.planning/phases/30-container-utilities-naming/30-01-SUMMARY.md`
</output>
