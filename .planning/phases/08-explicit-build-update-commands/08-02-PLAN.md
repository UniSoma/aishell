---
phase: 08-explicit-build-update-commands
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - aishell
autonomous: true

must_haves:
  truths:
    - "aishell build --with-claude builds image with Claude Code"
    - "aishell build --with-opencode builds image with OpenCode"
    - "aishell build with no flags builds base image only"
    - "Build flags are saved to state file after successful build"
    - "aishell update rebuilds with flags from last build"
    - "aishell update merges new flags with existing state"
    - "Update uses --no-cache by default"
  artifacts:
    - path: "aishell"
      provides: "build and update subcommands"
      contains: "do_build"
    - path: "~/.local/state/aishell/builds/*.state"
      provides: "persisted build configuration"
      contains: "BUILD_WITH_CLAUDE"
  key_links:
    - from: "aishell do_build"
      to: "write_state_file"
      via: "function call after docker build"
      pattern: "write_state_file.*project"
    - from: "aishell do_update"
      to: "read_state_file"
      via: "function call to load existing state"
      pattern: "read_state_file.*state_file"
---

<objective>
Implement explicit build and update subcommands with state persistence.

Purpose: Users explicitly trigger builds, state is saved for update command
Output: Working `aishell build` and `aishell update` commands with flag persistence
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-explicit-build-update-commands/08-CONTEXT.md
@.planning/phases/08-explicit-build-update-commands/08-RESEARCH.md
@aishell
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement do_build subcommand</name>
  <files>aishell</files>
  <action>
Refactor the existing `ensure_image()` logic into a new `do_build()` function:

1. Create `do_build()` function that:
   - Accepts command line args for --with-claude, --with-opencode, --claude-version, --opencode-version, --no-cache, --verbose
   - Parse these args within the function (local arg parsing)
   - Get project_dir from pwd
   - Show build preview using show_build_preview() before starting
   - Build the Docker image (extract/reuse existing build logic from ensure_image)
   - Use --no-cache when --rebuild or --no-cache flag passed
   - Compute image tag using compute_image_tag()
   - After successful build, call write_state_file() to persist:
     * with_claude, with_opencode, claude_version, opencode_version, image_tag
   - Print success message: "Build complete. Image: {tag}"

2. Update usage() to document the build subcommand:
   ```
   Commands:
       build       Build the container image (required before other commands)
       update      Rebuild with latest versions using saved configuration
       claude      Run Claude Code (requires build with --with-claude)
       opencode    Run OpenCode (requires build with --with-opencode)
       (none)      Enter interactive shell (requires build)
   ```

3. Add `build` case to argument parsing:
   - In parse_args or main, detect `build` as first positional argument
   - Set HARNESS_CMD="build" and capture remaining args

4. Add `build` dispatch in main():
   ```bash
   if [[ "$HARNESS_CMD" == "build" ]]; then
       do_build "${HARNESS_ARGS[@]}"
       exit 0
   fi
   ```

Key behaviors:
- Build ALWAYS runs docker build (no "image exists" skip)
- Build with no flags creates base image (allows shell access)
- Cache is used by default, --no-cache disables it
- State is written AFTER successful build only
  </action>
  <verify>
Run: `bash -n aishell` to verify no syntax errors.
Run: `./aishell build --help 2>&1 | head -5` - should show usage or build help.
Verify build case exists: `grep -E "build\)" aishell`
  </verify>
  <done>
do_build() function implemented, build subcommand dispatches to it, state written after build
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor do_update to use state file</name>
  <files>aishell</files>
  <action>
Refactor the existing `do_update()` function to:

1. Load existing state:
   - Get project_dir from pwd
   - Get state_file path using get_state_file()
   - Call read_state_file() to load BUILD_* variables
   - If no state file exists, call error_no_build() (create this function) and exit

2. Merge new flags with existing state:
   - Parse command line args passed to update (--with-claude, --with-opencode, --claude-version, --opencode-version)
   - New flags ADD to existing (don't replace)
   - Example: existing BUILD_WITH_CLAUDE=true, new --with-opencode, result: both true
   - Version flags override existing versions for that harness

3. Show update preview:
   - Call show_build_preview() with is_update=true
   - Show merged state (what will be rebuilt)

4. Perform rebuild:
   - Always use --no-cache (update means "get latest")
   - Build with merged flags
   - Reuse build logic (docker build command)

5. Save updated state:
   - Write merged state to state file after successful build
   - Update timestamp

6. Create `error_no_build()` helper function:
   - Print: "Error: No previous build found for this project."
   - Print suggestions: "To build with Claude Code: aishell build --with-claude"
   - Exit with code 1

Key behaviors:
- Update without prior build = error with guidance
- Update with new flags = merge with existing
- Update always uses --no-cache
- State is updated after successful rebuild
  </action>
  <verify>
Run: `bash -n aishell` to verify no syntax errors.
Verify state reading: `grep "read_state_file" aishell | grep -v "^#"`
Verify no-cache in update: `grep -A5 "do_update" aishell | grep "no-cache"`
  </verify>
  <done>
do_update() reads state file, merges flags, rebuilds with --no-cache, writes updated state
  </done>
</task>

<task type="auto">
  <name>Task 3: Remove auto-build from run commands</name>
  <files>aishell</files>
  <action>
Modify the run flow to require explicit prior build:

1. Remove or disable `ensure_image()` call before docker run:
   - The current flow calls ensure_image() which auto-builds
   - Replace with a check: verify state file exists and image exists
   - If no state file: call error_no_build() and exit
   - If state file exists but image missing: suggest rebuild

2. Simplify `ensure_image_with_extension()`:
   - Remove the ensure_image() call at the start
   - Load state file to get IMAGE_TO_RUN (stored as BUILD_IMAGE_TAG)
   - Check if image exists with docker image inspect
   - If image doesn't exist: error with "Image not found. Run: aishell build ..."
   - Still handle extensions (.aishell/Dockerfile) but base on stored image

3. Add `verify_build_exists()` function:
   - Get state file for current project
   - If state file missing: return 1
   - Read state file
   - Check if BUILD_IMAGE_TAG image exists
   - Return 0 if all good, 1 if not

4. Update main() flow:
   - Before docker run commands (shell, claude, opencode), call verify_build_exists()
   - This replaces the current auto-build behavior
   - Build subcommand still works independently

Key behaviors:
- `aishell` without prior build = error with guidance
- `aishell claude` without --with-claude in build = error with guidance (next plan)
- No more automatic image building on run
  </action>
  <verify>
Run: `bash -n aishell` to verify no syntax errors.
Verify ensure_image not called in run path: `grep -n "ensure_image" aishell` - should only be in build context
  </verify>
  <done>
Run commands require prior build, auto-build behavior removed, helpful errors when build missing
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. `bash -n aishell` - No syntax errors
2. `./aishell build --with-claude` - Builds image, creates state file
3. `ls ~/.local/state/aishell/builds/` - State file exists with hash name
4. `cat ~/.local/state/aishell/builds/*.state` - Contains BUILD_WITH_CLAUDE=true
5. `./aishell update` - Rebuilds with saved flags (--no-cache)
6. Without build, `./aishell` shows error with build instructions
</verification>

<success_criteria>
- build subcommand creates image and persists state
- update subcommand loads state, merges flags, rebuilds with --no-cache
- Run commands fail with helpful error when no prior build
- State file contains all build configuration
- Usage help updated with new command structure
</success_criteria>

<output>
After completion, create `.planning/phases/08-explicit-build-update-commands/08-02-SUMMARY.md`
</output>
