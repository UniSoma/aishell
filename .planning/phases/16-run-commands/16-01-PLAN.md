---
phase: 16-run-commands
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/aishell/config.clj
autonomous: true

must_haves:
  truths:
    - "Config module can load .aishell/config.yaml from project directory"
    - "Config module falls back to ~/.aishell/config.yaml if project config missing"
    - "Config module returns nil if no config exists"
    - "Invalid YAML syntax causes immediate error exit"
    - "Unknown config keys trigger warning but don't fail"
  artifacts:
    - path: "src/aishell/config.clj"
      provides: "YAML config loading with validation"
      exports: ["load-config", "validate-config", "config-source"]
  key_links:
    - from: "src/aishell/config.clj"
      to: "clj-yaml.core"
      via: "yaml/parse-string"
      pattern: "yaml/parse-string"
    - from: "src/aishell/config.clj"
      to: "src/aishell/util.clj"
      via: "path utilities"
      pattern: "util/get-home"
---

<objective>
Create the config module for loading and validating per-project YAML configuration.

Purpose: Replaces bash run.conf with YAML config. Projects define mounts, env, ports, docker_args, and pre_start in `.aishell/config.yaml`. Global fallback at `~/.aishell/config.yaml` supports shared defaults.

Output: Working `config.clj` module with load-config, validate-config, and config-source functions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/16-run-commands/16-RESEARCH.md
@.planning/phases/16-run-commands/16-CONTEXT.md
@src/aishell/util.clj
@src/aishell/output.clj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create config.clj with YAML loading</name>
  <files>src/aishell/config.clj</files>
  <action>
Create `src/aishell/config.clj` with the following:

1. Namespace with requires:
```clojure
(ns aishell.config
  "Per-project configuration loading from YAML.
   Supports .aishell/config.yaml in project dir with global fallback."
  (:require [clj-yaml.core :as yaml]
            [babashka.fs :as fs]
            [aishell.util :as util]
            [aishell.output :as output]))
```

2. Define known config keys for validation:
```clojure
(def known-keys
  "Valid config keys. Unknown keys trigger warning."
  #{:mounts :env :ports :docker_args :pre_start})
```

3. Config file path functions:
```clojure
(defn project-config-path
  "Path to project config: PROJECT_DIR/.aishell/config.yaml"
  [project-dir]
  (str (fs/path project-dir ".aishell" "config.yaml")))

(defn global-config-path
  "Path to global config: ~/.aishell/config.yaml"
  []
  (str (fs/path (util/get-home) ".aishell" "config.yaml")))
```

4. Validation function:
```clojure
(defn validate-config
  "Validate config map. Warns on unknown keys. Returns config unchanged."
  [config source-path]
  (when config
    (let [config-keys (set (keys config))
          unknown (clojure.set/difference config-keys known-keys)]
      (when (seq unknown)
        (output/warn (str "Unknown config keys in " source-path ": "
                         (clojure.string/join ", " (map name unknown))
                         "\nValid keys: mounts, env, ports, docker_args, pre_start")))))
  config)
```

5. Main loading function with project-first, global-fallback strategy:
```clojure
(defn load-config
  "Load config.yaml with project-first, global-fallback strategy.

   Lookup order:
   1. PROJECT_DIR/.aishell/config.yaml (if exists)
   2. ~/.aishell/config.yaml (if project config missing)
   3. nil (if neither exists)

   Exits with error on invalid YAML syntax.
   Warns on unknown keys but continues."
  [project-dir]
  (let [project-path (project-config-path project-dir)
        global-path (global-config-path)]
    (cond
      ;; Project config exists - use it
      (fs/exists? project-path)
      (try
        (-> (slurp project-path)
            yaml/parse-string
            (validate-config project-path))
        (catch Exception e
          (output/error (str "Invalid YAML in " project-path ": " (.getMessage e)))))

      ;; Fall back to global config
      (fs/exists? global-path)
      (try
        (-> (slurp global-path)
            yaml/parse-string
            (validate-config global-path))
        (catch Exception e
          (output/error (str "Invalid YAML in " global-path ": " (.getMessage e)))))

      ;; No config - return nil
      :else nil)))
```

6. Helper to check if config loaded from project (for verbose output):
```clojure
(defn config-source
  "Return which config was loaded: :project, :global, or nil"
  [project-dir]
  (let [project-path (project-config-path project-dir)
        global-path (global-config-path)]
    (cond
      (fs/exists? project-path) :project
      (fs/exists? global-path) :global
      :else nil)))
```
  </action>
  <verify>
```bash
cd /home/jonasrodrigues/projects/harness

# Test loading - should work without errors
bb -e '(require (quote [aishell.config :as config])) (println (config/load-config "."))'

# Test with no config - should return nil
rm -f .aishell/config.yaml ~/.aishell/config.yaml 2>/dev/null
bb -e '(require (quote [aishell.config :as config])) (println "Result:" (config/load-config "."))'

# Test config-source function
bb -e '(require (quote [aishell.config :as config])) (println "Source:" (config/config-source "."))'

# Test YAML parsing with sample config
mkdir -p /tmp/cfg-test/.aishell
echo 'mounts: ["~/.ssh"]' > /tmp/cfg-test/.aishell/config.yaml
bb -e '(require (quote [aishell.config :as config])) (println (:mounts (config/load-config "/tmp/cfg-test")))'

# Test unknown key warning
cat > /tmp/cfg-test/.aishell/config.yaml << 'EOF'
mounts:
  - ~/.ssh
unknown_key: value
EOF
bb -e '(require (quote [aishell.config :as config])) (config/load-config "/tmp/cfg-test")' 2>&1 | grep -q "Unknown config keys"

# Test invalid YAML (should error)
cat > /tmp/cfg-test/.aishell/config.yaml << 'EOF'
mounts: [
  invalid yaml without closing bracket
EOF
bb -e '(require (quote [aishell.config :as config])) (config/load-config "/tmp/cfg-test")' 2>&1

# Clean up
rm -rf /tmp/cfg-test
```
  </verify>
  <done>
- config.clj exists with load-config, validate-config, and config-source functions
- load-config returns nil when no config exists
- config-source returns :project, :global, or nil
- clj-yaml.core parses YAML correctly
- YAML with mounts, env, ports, docker_args, pre_start parses correctly
- env map has nil for passthrough keys, values for literal keys
- Unknown keys trigger warning to stderr
- Invalid YAML causes error exit
  </done>
</task>

</tasks>

<verification>
```bash
cd /home/jonasrodrigues/projects/harness

# 1. Module loads without error
bb -e '(require (quote [aishell.config :as config])) (println "Config module loaded")'

# 2. load-config returns nil when no config
rm -f .aishell/config.yaml 2>/dev/null
bb -e '(require (quote [aishell.config :as config])) (assert (nil? (config/load-config ".")) "Should be nil")'

# 3. Project config takes precedence (create both, should use project)
mkdir -p .aishell ~/.aishell
echo 'mounts: ["project"]' > .aishell/config.yaml
echo 'mounts: ["global"]' > ~/.aishell/config.yaml
bb -e '(require (quote [aishell.config :as config])) (assert (= ["project"] (:mounts (config/load-config "."))) "Project should win")'
rm .aishell/config.yaml

# 4. Falls back to global
bb -e '(require (quote [aishell.config :as config])) (assert (= ["global"] (:mounts (config/load-config "."))) "Should fallback to global")'
rm ~/.aishell/config.yaml

# 5. config-source function works
bb -e '(require (quote [aishell.config :as config])) (println "Source:" (config/config-source "."))'
```
</verification>

<success_criteria>
- config.clj exists with namespace aishell.config
- load-config loads from project .aishell/config.yaml first
- load-config falls back to ~/.aishell/config.yaml if project config missing
- load-config returns nil if neither exists
- config-source returns :project, :global, or nil to indicate which config was loaded
- Invalid YAML causes error exit with clear message
- Unknown config keys trigger warning but continue
- YAML parsing handles mounts (vector), env (map), ports (vector), docker_args (string), pre_start (string)
</success_criteria>

<output>
After completion, create `.planning/phases/16-run-commands/16-01-SUMMARY.md`
</output>
