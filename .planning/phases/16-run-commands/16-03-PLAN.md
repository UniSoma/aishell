---
phase: 16-run-commands
plan: 03
type: execute
wave: 2
depends_on: ["16-01", "16-02"]
files_modified:
  - src/aishell/cli.clj
  - src/aishell/run.clj
autonomous: true

must_haves:
  truths:
    - "User can run ./aishell and enter shell in container"
    - "User can run ./aishell claude and Claude Code starts"
    - "User can run ./aishell opencode and OpenCode starts"
    - "Running without build shows clear error message"
    - "Running claude without --with-claude build shows error"
    - "Extra args pass through to harness (e.g., ./aishell claude --model opus)"
    - "Container is destroyed on exit (--rm flag)"
  artifacts:
    - path: "src/aishell/run.clj"
      provides: "Run command orchestration"
      exports: ["run-container"]
    - path: "src/aishell/cli.clj"
      provides: "CLI dispatch for shell/claude/opencode"
      contains: "handle-run"
  key_links:
    - from: "src/aishell/cli.clj"
      to: "src/aishell/run.clj"
      via: "run/run-container call"
      pattern: "run/run-container"
    - from: "src/aishell/run.clj"
      to: "src/aishell/config.clj"
      via: "config/load-config"
      pattern: "config/load-config"
    - from: "src/aishell/run.clj"
      to: "src/aishell/docker/run.clj"
      via: "docker.run/build-docker-args"
      pattern: "docker.run/build-docker-args"
    - from: "src/aishell/run.clj"
      to: "babashka.process/exec"
      via: "process replacement"
      pattern: "p/exec"
---

<objective>
Wire CLI dispatch for shell, claude, and opencode commands, integrating config loading and docker execution.

Purpose: This is the user-facing run functionality. Users run `./aishell` for shell, `./aishell claude` for Claude Code, or `./aishell opencode` for OpenCode. The container is ephemeral, project is mounted, and configuration is applied.

Output: Working run commands that launch containers with full configuration support.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/16-run-commands/16-RESEARCH.md
@.planning/phases/16-run-commands/16-CONTEXT.md
@.planning/phases/16-run-commands/16-01-SUMMARY.md
@.planning/phases/16-run-commands/16-02-SUMMARY.md
@src/aishell/cli.clj
@src/aishell/state.clj
@src/aishell/docker.clj
@src/aishell/config.clj
@src/aishell/docker/run.clj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create run.clj orchestration module</name>
  <files>src/aishell/run.clj</files>
  <action>
Create `src/aishell/run.clj` that orchestrates the run flow:

```clojure
(ns aishell.run
  "Run command orchestration.
   Handles shell, claude, and opencode execution in containers."
  (:require [babashka.process :as p]
            [aishell.docker :as docker]
            [aishell.docker.run :as docker-run]
            [aishell.config :as config]
            [aishell.state :as state]
            [aishell.output :as output]))

(defn- verify-harness-available
  "Check that harness was included in build. Exit with error if not."
  [harness-name state-key state]
  (when-not (get state state-key)
    (output/error
      (str (case harness-name
             "claude" "Claude Code"
             "opencode" "OpenCode")
           " not installed. Run: aishell build --with-"
           harness-name))))

(defn run-container
  "Run docker container for shell or harness.

   Arguments:
   - cmd: nil (shell), \"claude\", or \"opencode\"
   - harness-args: Extra arguments to pass to harness (vector)"
  [cmd harness-args]
  ;; Check Docker available
  (docker/check-docker!)

  ;; Read state (contains build info)
  (let [state (state/read-state)]
    ;; Verify build exists
    (when-not state
      (output/error-no-build))

    ;; Verify image exists
    (let [image-tag (or (:image-tag state) "aishell:base")]
      (when-not (docker/image-exists? image-tag)
        (output/error (str "Image not found: " image-tag
                          "\nRun: aishell build")))

      ;; Verify harness if requested
      (case cmd
        "claude" (verify-harness-available "claude" :with-claude state)
        "opencode" (verify-harness-available "opencode" :with-opencode state)
        nil)

      ;; Load config
      (let [project-dir (System/getProperty "user.dir")
            cfg (config/load-config project-dir)
            git-id (docker-run/read-git-identity project-dir)

            ;; Verbose output (when we add --verbose support)
            _ (when cfg
                (output/verbose (str "Loaded config from: "
                                    (name (config/config-source project-dir)))))
            _ (when (and (:name git-id) (:email git-id))
                (output/verbose (str "Git identity: " (:name git-id)
                                    " <" (:email git-id) ">")))

            ;; Build docker args
            docker-args (docker-run/build-docker-args
                          {:project-dir project-dir
                           :image-tag image-tag
                           :config cfg
                           :git-identity git-id})

            ;; Determine command to run in container
            container-cmd (case cmd
                            "claude"
                            (into ["claude" "--dangerously-skip-permissions"]
                                  harness-args)

                            "opencode"
                            (into ["opencode"] harness-args)

                            ;; Default: bash shell
                            ["/bin/bash"])]

        ;; Execute - replaces current process
        (apply p/exec (concat docker-args container-cmd))))))
```

Key points:
- Uses `p/exec` which replaces the Babashka process with Docker (proper Unix exec semantics)
- Claude always gets `--dangerously-skip-permissions` (container IS the sandbox)
- Extra args pass through to harness
- Shell is default when cmd is nil
  </action>
  <verify>
```bash
cd /home/jonasrodrigues/projects/harness

# Test module loads
bb -e '(require (quote [aishell.run :as run])) (println "Module loaded")'
```
  </verify>
  <done>
- run.clj exists with namespace aishell.run
- run-container function orchestrates the complete flow
- Harness verification checks state for :with-claude/:with-opencode
  </done>
</task>

<task type="auto">
  <name>Task 2: Update cli.clj with run command dispatch</name>
  <files>src/aishell/cli.clj</files>
  <action>
Update `src/aishell/cli.clj` to add run commands:

1. Add require at top:
```clojure
[aishell.run :as run]
```

2. Add handler for run commands (claude, opencode):
```clojure
(defn handle-run
  "Handle run commands: claude, opencode, or shell (default)."
  [{:keys [opts args]} cmd]
  (if (:help opts)
    (case cmd
      "claude" (do
                 (println (str output/BOLD "Usage:" output/NC " aishell claude [ARGS...]"))
                 (println)
                 (println "Run Claude Code in container.")
                 (println)
                 (println "All arguments are passed to Claude Code.")
                 (println)
                 (println (str output/BOLD "Examples:" output/NC))
                 (println (str "  " output/CYAN "aishell claude" output/NC "                  Start Claude Code"))
                 (println (str "  " output/CYAN "aishell claude --model opus" output/NC "     Use specific model")))
      "opencode" (do
                   (println (str output/BOLD "Usage:" output/NC " aishell opencode [ARGS...]"))
                   (println)
                   (println "Run OpenCode in container.")
                   (println)
                   (println "All arguments are passed to OpenCode.")))
    ;; Run the command
    (run/run-container cmd (vec args))))
```

3. Update handle-default to run shell when no command given (and no flags):
```clojure
(defn handle-default [{:keys [opts args]}]
  (cond
    (:version opts)
    (if (:json opts)
      (core/print-version-json)
      (core/print-version))

    (:help opts)
    (print-help)

    ;; Unknown command - check for typos
    (seq args)
    (output/error-unknown-command (first args))

    ;; No command, no flags - run shell
    :else
    (run/run-container nil [])))
```

4. Update dispatch-table to include claude and opencode:
```clojure
(def dispatch-table
  [{:cmds ["build"] :fn handle-build :spec build-spec :restrict true}
   {:cmds ["claude"] :fn #(handle-run % "claude") :spec {:help {:alias :h :coerce :boolean}}}
   {:cmds ["opencode"] :fn #(handle-run % "opencode") :spec {:help {:alias :h :coerce :boolean}}}
   {:cmds [] :spec global-spec :fn handle-default}])
```

Note: claude and opencode don't use `:restrict true` because they accept arbitrary pass-through args for the harness.
  </action>
  <verify>
```bash
cd /home/jonasrodrigues/projects/harness

# Test help for commands
./aishell claude --help | grep -q "Run Claude Code"
./aishell opencode --help | grep -q "Run OpenCode"

# Test dispatch (will fail at Docker check if no build, but proves dispatch works)
./aishell 2>&1 | head -3
./aishell claude 2>&1 | head -3
./aishell opencode 2>&1 | head -3
```
  </verify>
  <done>
- `aishell claude --help` shows Claude-specific help
- `aishell opencode --help` shows OpenCode-specific help
- `aishell` (no args, no flags) runs shell
- `aishell claude` dispatches to claude command
- `aishell opencode` dispatches to opencode command
  </done>
</task>

<task type="auto">
  <name>Task 3: End-to-end testing</name>
  <files>src/aishell/cli.clj, src/aishell/run.clj</files>
  <action>
Test the complete flow with real containers. This requires a prior build.

1. Ensure image is built:
```bash
cd /home/jonasrodrigues/projects/harness
./aishell build --with-claude
```

2. Test shell access:
```bash
# Should enter container and exit
echo "exit" | ./aishell
```

3. Test that project is mounted at same path:
```bash
# Inside container, pwd should match host pwd
./aishell -c "pwd"
# Or: echo "pwd && exit" | ./aishell
```

4. Test claude command (if installed):
```bash
# Should show Claude starting (then Ctrl+C to exit)
timeout 5 ./aishell claude || true
```

5. Test error cases:

5a. No build:
```bash
rm -f ~/.aishell/state.edn
./aishell 2>&1 | grep -q "No image built"
```

5b. Claude not installed:
```bash
echo '{:with-claude false :with-opencode false :image-tag "aishell:base"}' > ~/.aishell/state.edn
./aishell claude 2>&1 | grep -q "not installed"
```

5c. Unknown command still errors:
```bash
./aishell badcmd 2>&1 | grep -q "Unknown command"
```

6. Restore valid state for further testing:
```bash
./aishell build --with-claude
```

If any tests fail, debug and fix the issue.
  </action>
  <verify>
```bash
cd /home/jonasrodrigues/projects/harness

# Build first
./aishell build

# Test shell executes (just check it starts Docker)
timeout 2 ./aishell 2>&1 || echo "Timeout expected - interactive shell"

# Test error when no build
rm -f ~/.aishell/state.edn
./aishell 2>&1 | grep -q "No image built" && echo "No-build error OK"

# Rebuild for clean state
./aishell build
```
  </verify>
  <done>
- `./aishell` enters shell in container
- `./aishell claude` runs Claude Code (if built with --with-claude)
- `./aishell opencode` runs OpenCode (if built with --with-opencode)
- Running without build shows "No image built" error
- Running claude without --with-claude build shows "not installed" error
- Container is ephemeral (exits and disappears)
  </done>
</task>

</tasks>

<verification>
```bash
cd /home/jonasrodrigues/projects/harness

# 1. Help works for all commands
./aishell --help | grep -q "Enter interactive shell"
./aishell claude --help | grep -q "Claude Code"
./aishell opencode --help | grep -q "OpenCode"

# 2. Build required messages
rm -f ~/.aishell/state.edn
./aishell 2>&1 | grep -q "No image built"
./aishell claude 2>&1 | grep -q "No image built"

# 3. After build, run works
./aishell build
timeout 2 bash -c 'echo exit | ./aishell' 2>&1 || echo "Shell ran"

# 4. Harness verification
echo '{:with-claude false :with-opencode false :image-tag "aishell:base"}' > ~/.aishell/state.edn
./aishell claude 2>&1 | grep -q "not installed"
./aishell opencode 2>&1 | grep -q "not installed"

# 5. Unknown command still works
./aishell badcmd 2>&1 | grep -q "Unknown command"

# 6. Rebuild clean state
./aishell build --with-claude
```
</verification>

<success_criteria>
- run.clj exists with run-container function
- cli.clj dispatches to run for shell, claude, opencode
- `./aishell` (no args) enters shell in container
- `./aishell claude` runs Claude Code with --dangerously-skip-permissions
- `./aishell opencode` runs OpenCode
- `./aishell claude --model opus` passes args through to Claude
- Running without build shows "No image built" error
- Running claude without --with-claude shows "Claude Code not installed" error
- Running opencode without --with-opencode shows "OpenCode not installed" error
- Container is destroyed on exit (--rm flag working)
- Project is mounted at same path as host
- Git identity is available in container
- Config (mounts, env, ports, docker_args, pre_start) is applied
</success_criteria>

<output>
After completion, create `.planning/phases/16-run-commands/16-03-SUMMARY.md`
</output>
