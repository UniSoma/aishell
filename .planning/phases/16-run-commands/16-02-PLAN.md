---
phase: 16-run-commands
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/aishell/docker/run.clj
autonomous: true

must_haves:
  truths:
    - "Docker run args include project mount at same path as host"
    - "Docker run args include git identity env vars when available"
    - "Container is ephemeral and interactive (destroyed on exit, TTY attached)"
    - "Mount paths with ~ and $HOME are expanded correctly"
    - "Env vars with nil value are passthrough, with value are literal"
    - "Ports are validated for format before adding to args"
    - "PRE_START is passed via -e PRE_START=command (entrypoint executes it)"
  artifacts:
    - path: "src/aishell/docker/run.clj"
      provides: "Docker run argument construction"
      exports: ["build-docker-args", "read-git-identity"]
  key_links:
    - from: "src/aishell/docker/run.clj"
      to: "src/aishell/util.clj"
      via: "expand-path for mount expansion"
      pattern: "util/expand-path"
    - from: "src/aishell/docker/run.clj"
      to: "babashka.process"
      via: "shell for git config and id commands"
      pattern: "p/shell"
---

<objective>
Create the docker run argument builder that constructs the full docker run command vector.

Purpose: Translates configuration (mounts, env, ports, docker_args, pre_start) plus runtime info (git identity, UID/GID) into a vector of docker arguments. This is the core of running containers correctly.

Output: Working `docker/run.clj` module with build-docker-args and helper functions.

Note: PRE_START is passed as an environment variable. The Phase 14 entrypoint template already handles PRE_START execution - it runs `sh -c "$PRE_START" > /tmp/pre-start.log 2>&1 &` in the background before exec'ing the main command. This plan only needs to pass the env var; entrypoint execution is already implemented.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/16-run-commands/16-RESEARCH.md
@.planning/phases/16-run-commands/16-CONTEXT.md
@src/aishell/util.clj
@src/aishell/output.clj
@src/aishell/docker.clj
@src/aishell/docker/templates.clj (lines 174-179 show PRE_START handling in entrypoint)
@aishell (bash implementation lines 640-800 for reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create docker/run.clj with core argument building</name>
  <files>src/aishell/docker/run.clj</files>
  <action>
Create `src/aishell/docker/run.clj` with the following:

1. Namespace with requires:
```clojure
(ns aishell.docker.run
  "Docker run argument construction.
   Builds the full docker run command vector from config and runtime info."
  (:require [babashka.process :as p]
            [babashka.fs :as fs]
            [clojure.string :as str]
            [aishell.util :as util]
            [aishell.output :as output]))
```

2. Git identity reading (from host):
```clojure
(defn read-git-identity
  "Read git identity from host configuration.
   Returns {:name \"...\" :email \"...\"} with nil values if not set."
  [project-dir]
  (letfn [(git-config [key]
            (try
              (let [{:keys [exit out]}
                    (p/shell {:out :string :err :string :continue true :dir project-dir}
                             "git" "config" key)]
                (when (zero? exit)
                  (let [val (str/trim out)]
                    (when-not (str/blank? val) val))))
              (catch Exception _ nil)))]
    {:name (git-config "user.name")
     :email (git-config "user.email")}))
```

3. UID/GID reading:
```clojure
(defn- get-uid []
  (-> (p/shell {:out :string} "id" "-u") :out str/trim))

(defn- get-gid []
  (-> (p/shell {:out :string} "id" "-g") :out str/trim))
```

4. Mount argument building (supports source-only and source:dest):
```clojure
(defn- build-mount-args
  "Build -v flags from mounts config.

   Supports:
   - source-only: ~/.ssh (mounts at same path)
   - source:dest: /host/path:/container/path

   Expands ~ and $HOME in paths. Warns if source doesn't exist."
  [mounts]
  (when (seq mounts)
    (->> mounts
         (mapcat
           (fn [mount]
             (let [mount-str (str mount)
                   [source dest] (if (str/includes? mount-str ":")
                                   (str/split mount-str #":" 2)
                                   [mount-str mount-str])
                   source (util/expand-path source)
                   dest (util/expand-path dest)]
               (if (fs/exists? source)
                 ["-v" (str source ":" dest)]
                 (do
                   (output/warn (str "Mount source does not exist: " source))
                   []))))))))
```

5. Environment argument building (docker-compose style):
```clojure
(defn- build-env-args
  "Build -e flags from env config.

   In YAML, env is a map:
   - key with nil value: passthrough from host (VAR:)
   - key with value: literal (VAR: value)

   Skips passthrough vars not set on host with warning."
  [env-map]
  (when (seq env-map)
    (->> env-map
         (mapcat
           (fn [[k v]]
             (let [key-name (name k)]
               (if (nil? v)
                 ;; Passthrough: only add if set on host
                 (if-let [host-val (System/getenv key-name)]
                   ["-e" key-name]
                   (do
                     (output/warn (str "Skipping unset host variable: " key-name))
                     []))
                 ;; Literal value
                 ["-e" (str key-name "=" v)])))))))
```

6. Port argument building with validation:
```clojure
(def port-pattern
  "Valid port format: [IP:]HOST:CONTAINER[/PROTOCOL]"
  #"^((\d{1,3}\.){3}\d{1,3}:)?\d+:\d+(/[a-z]+)?$")

(defn- build-port-args
  "Build -p flags from ports config.

   Validates format: HOST:CONTAINER or IP:HOST:CONTAINER
   Examples: 8080:80, 127.0.0.1:8080:80, 8080:80/udp"
  [ports]
  (when (seq ports)
    (->> ports
         (mapcat
           (fn [port]
             (let [port-str (str port)]
               (if (re-matches port-pattern port-str)
                 ["-p" port-str]
                 (output/error (str "Invalid port mapping: " port-str
                                   "\nExpected format: HOST_PORT:CONTAINER_PORT or IP:HOST_PORT:CONTAINER_PORT"
                                   "\nExamples: 8080:80, 127.0.0.1:8080:80, 8080:80/udp")))))))))
```

7. Docker args tokenization (for docker_args string):
```clojure
(defn- tokenize-docker-args
  "Split docker_args string into individual args.
   Simple whitespace split - complex quoting not supported (documented limitation)."
  [docker-args-str]
  (when (and docker-args-str (not (str/blank? docker-args-str)))
    (str/split (str/trim docker-args-str) #"\s+")))
```

8. Config mounts for harnesses (Claude, OpenCode configs):
```clojure
(defn- build-harness-config-mounts
  "Build mount args for harness configuration directories.
   Only mounts directories that exist on host."
  []
  (let [home (util/get-home)
        config-paths [[(str home "/.claude") (str home "/.claude")]
                      [(str home "/.claude.json") (str home "/.claude.json")]
                      [(str home "/.config/opencode") (str home "/.config/opencode")]
                      [(str home "/.local/share/opencode") (str home "/.local/share/opencode")]]]
    (->> config-paths
         (filter (fn [[src _]] (fs/exists? src)))
         (mapcat (fn [[src dst]] ["-v" (str src ":" dst)])))))
```

9. API key environment passthrough:
```clojure
(def api-key-vars
  "Environment variables to pass through for API access."
  ["ANTHROPIC_API_KEY"
   "OPENAI_API_KEY"
   "GEMINI_API_KEY"
   "GROQ_API_KEY"
   "GITHUB_TOKEN"
   "AWS_ACCESS_KEY_ID"
   "AWS_SECRET_ACCESS_KEY"
   "AWS_REGION"
   "AWS_PROFILE"
   "AZURE_OPENAI_API_KEY"
   "AZURE_OPENAI_ENDPOINT"
   "GOOGLE_CLOUD_PROJECT"
   "GOOGLE_APPLICATION_CREDENTIALS"])

(defn- build-api-env-args
  "Build -e flags for API keys that are set on host."
  []
  (->> api-key-vars
       (filter #(System/getenv %))
       (mapcat (fn [var] ["-e" (str var "=" (System/getenv var))]))))
```
  </action>
  <verify>
```bash
cd /home/jonasrodrigues/projects/harness

# Test module loads
bb -e '(require (quote [aishell.docker.run :as run])) (println "Module loaded")'

# Test git identity reading
bb -e '(require (quote [aishell.docker.run :as run])) (println (run/read-git-identity "."))'
```
  </verify>
  <done>
- docker/run.clj exists with namespace aishell.docker.run
- read-git-identity returns map with :name and :email
- build-mount-args, build-env-args, build-port-args helpers exist
  </done>
</task>

<task type="auto">
  <name>Task 2: Add main build-docker-args function</name>
  <files>src/aishell/docker/run.clj</files>
  <action>
Add the main build-docker-args function that assembles all arguments:

```clojure
(defn build-docker-args
  "Build complete docker run argument vector.

   Arguments:
   - project-dir: Absolute path to project
   - image-tag: Docker image to run
   - config: Parsed config map from config.clj (or nil)
   - git-identity: {:name \"...\" :email \"...\"} from read-git-identity

   Returns vector starting with [\"docker\" \"run\" ...] ready for p/exec.

   Note: PRE_START is passed as -e PRE_START=command. The entrypoint script
   (from Phase 14) handles execution: runs in background, logs to /tmp/pre-start.log."
  [{:keys [project-dir image-tag config git-identity]}]
  (let [uid (get-uid)
        gid (get-gid)
        home (util/get-home)]
    (-> ["docker" "run"
         "--rm" "-it" "--init"
         ;; Project mount at same path
         "-v" (str project-dir ":" project-dir)
         "-w" project-dir
         ;; User identity for entrypoint
         "-e" (str "LOCAL_UID=" uid)
         "-e" (str "LOCAL_GID=" gid)
         "-e" (str "LOCAL_HOME=" home)
         ;; Terminal settings
         "-e" (str "TERM=" (or (System/getenv "TERM") "xterm-256color"))
         "-e" (str "COLORTERM=" (or (System/getenv "COLORTERM") "truecolor"))]

        ;; Git identity
        (cond-> (:name git-identity)
          (into ["-e" (str "GIT_AUTHOR_NAME=" (:name git-identity))
                 "-e" (str "GIT_COMMITTER_NAME=" (:name git-identity))]))
        (cond-> (:email git-identity)
          (into ["-e" (str "GIT_AUTHOR_EMAIL=" (:email git-identity))
                 "-e" (str "GIT_COMMITTER_EMAIL=" (:email git-identity))]))

        ;; Harness config mounts (Claude, OpenCode configs)
        (into (build-harness-config-mounts))

        ;; API keys
        (into (build-api-env-args))

        ;; Disable autoupdater in container
        (into ["-e" "DISABLE_AUTOUPDATER=1"])

        ;; Config: mounts
        (cond-> (:mounts config)
          (into (build-mount-args (:mounts config))))

        ;; Config: env
        (cond-> (:env config)
          (into (build-env-args (:env config))))

        ;; Config: ports
        (cond-> (:ports config)
          (into (build-port-args (:ports config))))

        ;; Config: pre_start (passed to entrypoint via env var)
        ;; Entrypoint handles execution: sh -c "$PRE_START" > /tmp/pre-start.log 2>&1 &
        (cond-> (:pre_start config)
          (into ["-e" (str "PRE_START=" (:pre_start config))]))

        ;; Config: docker_args (must be before image)
        (cond-> (:docker_args config)
          (into (tokenize-docker-args (:docker_args config))))

        ;; Image tag (must be last before command)
        (conj image-tag))))
```

This produces a vector like:
```
["docker" "run" "--rm" "-it" "--init"
 "-v" "/home/user/project:/home/user/project"
 "-w" "/home/user/project"
 "-e" "LOCAL_UID=1000"
 ...
 "aishell:base"]
```

The caller appends the command (e.g., "/bin/bash" or "claude").
  </action>
  <verify>
```bash
cd /home/jonasrodrigues/projects/harness

# Test build-docker-args produces valid vector
bb -e '
(require (quote [aishell.docker.run :as run]))
(let [args (run/build-docker-args
             {:project-dir "/tmp/test"
              :image-tag "aishell:base"
              :config nil
              :git-identity {:name "Test" :email "test@test.com"}})]
  (println "Args count:" (count args))
  (println "First 5:" (take 5 args))
  (println "Last 3:" (take-last 3 args))
  (assert (= "docker" (first args)))
  (assert (= "aishell:base" (last args)))
  (println "OK"))
'

# Test with full config including PRE_START
bb -e '
(require (quote [aishell.docker.run :as run]))
(require (quote [clojure.string :as str]))
(let [config {:mounts ["~/.ssh"]
              :env {:EDITOR nil :DEBUG 1}
              :ports ["3000:3000"]
              :docker_args "--cap-add=SYS_PTRACE"
              :pre_start "echo hello"}
      args (run/build-docker-args
             {:project-dir "/home/user/project"
              :image-tag "aishell:base"
              :config config
              :git-identity {:name "Test User" :email "test@example.com"}})
      args-str (str/join " " args)]
  (assert (str/includes? args-str "--rm") "Should have --rm")
  (assert (str/includes? args-str "-it") "Should have -it")
  (assert (str/includes? args-str "--init") "Should have --init")
  (assert (str/includes? args-str "PRE_START=echo hello") "Should have PRE_START")
  (println "All checks passed"))
'
```
  </verify>
  <done>
- build-docker-args returns vector starting with ["docker" "run" ...]
- Vector includes --rm, -it, --init flags for ephemeral interactive container
- Vector includes project mount at same path
- Vector includes git identity when provided
- Vector includes PRE_START env var when config has pre_start
- Vector includes image tag as last element
  </done>
</task>

</tasks>

<verification>
```bash
cd /home/jonasrodrigues/projects/harness

# 1. Module loads
bb -e '(require (quote [aishell.docker.run :as run])) (println "OK")'

# 2. read-git-identity works
bb -e '(require (quote [aishell.docker.run :as run])) (let [{:keys [name email]} (run/read-git-identity ".")] (println "Name:" name "Email:" email))'

# 3. build-docker-args produces valid vector
bb -e '
(require (quote [aishell.docker.run :as run]))
(let [args (run/build-docker-args {:project-dir "/tmp" :image-tag "test" :config nil :git-identity nil})]
  (assert (= "docker" (first args)))
  (assert (= "test" (last args)))
  (println "Vector valid"))
'

# 4. Config elements included (PRE_START passed as env var)
bb -e '
(require (quote [aishell.docker.run :as run]))
(require (quote [clojure.string :as str]))
(let [args (run/build-docker-args {:project-dir "/tmp" :image-tag "test" :config {:pre_start "cmd"} :git-identity nil})
      args-str (str/join " " args)]
  (assert (str/includes? args-str "PRE_START=cmd"))
  (println "PRE_START included"))
'

# 5. Verify entrypoint handles PRE_START (Phase 14 already implemented this)
grep -A3 'PRE_START' src/aishell/docker/templates.clj | head -5
```
</verification>

<success_criteria>
- docker/run.clj exists with namespace aishell.docker.run
- read-git-identity reads user.name and user.email from git config
- build-docker-args returns vector starting with ["docker" "run" ...]
- Docker args include --rm, -it, --init (container is ephemeral and interactive)
- Project mounted at same path as host (-v project:project)
- Git identity passed as env vars (GIT_AUTHOR_NAME, GIT_COMMITTER_NAME, etc.)
- Harness configs (~/.claude, ~/.config/opencode) mounted if exist
- API keys passed through from host
- Config mounts expand ~ and $HOME correctly
- Config env handles passthrough (nil) and literal values
- Config ports validated for format
- Config docker_args tokenized and included before image
- Config pre_start passed as PRE_START env var (entrypoint executes it in background)
- Image tag is last element before command
</success_criteria>

<output>
After completion, create `.planning/phases/16-run-commands/16-02-SUMMARY.md`
</output>
