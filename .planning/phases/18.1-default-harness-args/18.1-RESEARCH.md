# Phase 18.1: Default Harness Arguments in Config - Research

**Researched:** 2026-01-22
**Domain:** Clojure/Babashka YAML config handling, CLI argument merging
**Confidence:** HIGH

## Summary

This phase extends the existing `config.yaml` structure to support per-harness default arguments that are automatically prepended to user-provided CLI arguments. The implementation builds directly on v2.0's YAML config foundation (`src/aishell/config.clj`) and the harness invocation flow in `src/aishell/run.clj`.

The standard approach is straightforward: add `harness_args` as a known config key, parse it as a map of harness names to argument lists, validate harness names against known values, and prepend defaults to CLI args at invocation time. The merge behavior follows the established pattern from the `extends` key (Phase quick-004): lists concatenate with defaults first, allowing CLI args to override by position.

Clojure's native data structures make this clean - YAML parses to ordered maps and lists, validation is a simple set check, and argument merging is `(concat defaults cli-args)`. The existing verbose output pattern (`output/verbose`) provides a natural place to show applied defaults when `-v` is used.

**Primary recommendation:** Add `:harness_args` to `known-keys`, parse as `{:harness-name [args]}`, validate harness names on load (warn for unknown), and prepend defaults in `run-container` before building the container command.

## Standard Stack

### Core (Babashka Built-ins)

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| clj-yaml.core | built-in | YAML parsing | Built into Babashka, already used for config.yaml (src/aishell/config.clj) |
| clojure.core | built-in | Data manipulation (concat, into, vec) | Native Clojure - lists, maps, sets, sequence operations |
| clojure.string | built-in | String utilities | Already used throughout codebase for joins, splits |
| babashka.fs | built-in | File system checks | Already used in config.clj for fs/exists? |

### Supporting

None needed - all functionality covered by existing stack.

### Alternatives Considered

| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| List-of-strings in YAML | Space-separated string | List format is more explicit, avoids shell quoting issues, matches existing YAML patterns (mounts, ports) |
| Validation on parse | Lazy validation on use | Early validation (on parse) gives better UX - user sees warnings when config is loaded, not mid-invocation |

## Architecture Patterns

### Recommended Integration Points

```
Config Loading Flow (src/aishell/config.clj):
1. load-yaml-config parses YAML
2. validate-config checks known-keys (ADD :harness_args here)
3. merge-configs handles global+project merge (ADD harness_args merge rule)
4. Return config map

Harness Invocation Flow (src/aishell/run.clj):
1. run-container receives cmd ("claude"/"opencode") and harness-args
2. Load config via (config/load-config project-dir)
3. INJECT: Extract defaults from (:harness_args cfg)
4. INJECT: Merge defaults with harness-args (concat defaults cli-args)
5. Build container-cmd with merged args
6. Execute via p/exec
```

### Pattern 1: Known Keys Extension

**What:** Extend `known-keys` set in config.clj to include new config keys
**When to use:** Adding any new top-level config.yaml key
**Example:**

```clojure
;; Source: src/aishell/config.clj:9-11
(def known-keys
  "Valid config keys. Unknown keys trigger warning."
  #{:mounts :env :ports :docker_args :pre_start :extends})

;; ADD :harness_args to this set
(def known-keys
  "Valid config keys. Unknown keys trigger warning."
  #{:mounts :env :ports :docker_args :pre_start :extends :harness_args})
```

### Pattern 2: List Concatenation for Merge

**What:** Concatenate global and project lists with global first
**When to use:** Merging list-type config keys (mounts, ports, docker_args, harness_args)
**Example:**

```clojure
;; Source: src/aishell/config.clj:48-54 (existing merge pattern)
;; List keys - concatenate
(contains? list-keys k)
(let [global-val (get global-config k)
      project-val (get project-config k)]
  (if (or global-val project-val)
    (assoc acc k (vec (concat (or global-val []) (or project-val []))))
    acc))

;; For harness_args (map of lists), concatenate per-harness:
;; Global: {:claude ["--plugin=a"]}
;; Project: {:claude ["--plugin=b"] :opencode ["--model=x"]}
;; Result: {:claude ["--plugin=a" "--plugin=b"] :opencode ["--model=x"]}
```

### Pattern 3: Harness Name Validation

**What:** Validate harness names against known set, warn for unknown
**When to use:** User-provided strings that must match known values
**Example:**

```clojure
;; Source: Pattern from output.clj:19 (known-commands)
(def known-harnesses #{"claude" "opencode"})

(defn validate-harness-args
  "Warn if harness_args contains unknown harness names."
  [harness-args-map source-path]
  (when harness-args-map
    (let [config-harnesses (set (keys harness-args-map))
          unknown (clojure.set/difference config-harnesses known-harnesses)]
      (when (seq unknown)
        (output/warn (str "Unknown harness names in " source-path
                         " harness_args: "
                         (clojure.string/join ", " unknown)))))))
```

### Pattern 4: Argument Prepending

**What:** Prepend default args to CLI args so CLI can override by position
**When to use:** Merging default and user-provided arguments
**Example:**

```clojure
;; Source: Pattern from run.clj:118-119 (into for args)
;; Current: (into ["claude" "--dangerously-skip-permissions"] harness-args)

;; With defaults:
(let [defaults (get-in cfg [:harness_args (keyword cmd)])
      merged-args (vec (concat defaults harness-args))]
  (into ["claude" "--dangerously-skip-permissions"] merged-args))

;; Example:
;; defaults = ["--plugin" "context7"]
;; harness-args = ["--verbose"]
;; merged-args = ["--plugin" "context7" "--verbose"]
;; Result: ["claude" "--dangerously-skip-permissions" "--plugin" "context7" "--verbose"]
```

### Pattern 5: Verbose Output for Applied Defaults

**What:** Show applied defaults only in verbose mode
**When to use:** Debugging/transparency without cluttering normal output
**Example:**

```clojure
;; Source: run.clj:89-95 (existing verbose output pattern)
_ (when cfg
    (output/verbose (str "Loaded config from: "
                        (name (config/config-source project-dir)))))

;; ADD verbose output for applied defaults:
_ (when (and cfg (seq defaults))
    (output/verbose (str "Applying default args for " cmd ": "
                        (clojure.string/join " " defaults))))
```

### Pattern 6: String-to-List Auto-Conversion

**What:** Convert single string values to single-element lists (DX convenience)
**When to use:** YAML config values that should be lists but might be provided as strings
**Example:**

```clojure
;; YAML: harness_args:
;;         claude: "--single-arg"

;; Parsed: {:harness_args {:claude "--single-arg"}}

;; Normalize function:
(defn normalize-harness-arg
  "Convert string to single-element list, pass lists through."
  [arg-val]
  (cond
    (nil? arg-val) []
    (string? arg-val) [arg-val]
    (sequential? arg-val) (vec arg-val)
    :else (do
            (output/warn (str "Invalid harness_args value type: " (type arg-val)))
            [])))

;; Result: {:harness_args {:claude ["--single-arg"]}}
```

### Anti-Patterns to Avoid

- **Validating harness names only on use:** Validate when config is loaded so user sees warnings immediately, not mid-invocation
- **Placing defaults after CLI args:** Prepend so CLI can override by position (e.g., last `--model` flag wins)
- **Silent normalization:** When auto-converting string to list, consider whether to warn or silently accept
- **Forgetting keyword conversion:** YAML keys parse as keywords (`:claude`), CLI cmd is string (`"claude"`) - use `(keyword cmd)` for lookup

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| YAML parsing | Custom parser | clj-yaml.core (built-in) | Already used, handles all YAML edge cases, ordered maps |
| List merging | Manual loop | concat + vec | Built-in, handles nil gracefully, clear semantics |
| Harness name validation | Pattern matching | Set operations (clojure.set/difference) | Clean, functional, matches existing validation pattern |
| Argument type normalization | Case/cond | Sequential? + string? checks | Standard Clojure idiom for type dispatch |

**Key insight:** Clojure's built-in sequence operations (concat, into, vec) and set operations (difference, intersection) handle all the data manipulation cleanly. Don't reach for loops or imperative patterns.

## Common Pitfalls

### Pitfall 1: Keyword vs String Mismatch

**What goes wrong:** YAML keys parse as keywords (`:claude`), but harness cmd is string (`"claude"`). Lookup fails silently.
**Why it happens:** YAML parser converts keys to keywords by default
**How to avoid:** Use `(keyword cmd)` when looking up harness args: `(get-in cfg [:harness_args (keyword cmd)])`
**Warning signs:** Config loads fine but defaults never apply; no errors, just silent failure

### Pitfall 2: Nil Handling in Concatenation

**What goes wrong:** `(concat nil user-args)` works, but `(concat undefined-key user-args)` throws NPE
**Why it happens:** Forgot to handle missing config key
**How to avoid:** Use `(or defaults [])` to ensure defaults is always a seq: `(concat (or defaults []) user-args)`
**Warning signs:** Works when harness_args exists, crashes when missing

### Pitfall 3: Forgetting extends Merge Behavior

**What goes wrong:** Project harness_args fully replaces global instead of concatenating
**Why it happens:** Not treating harness_args as a list-type key in merge-configs
**How to avoid:** harness_args is a MAP of LISTS - merge the map, then concatenate per-harness lists. Add special handling to merge-configs.
**Warning signs:** Global defaults lost when project config has harness_args

### Pitfall 4: Validation Timing

**What goes wrong:** Warnings about unknown harness appear every time container runs
**Why it happens:** Validation in run-container instead of load-yaml-config
**How to avoid:** Validate in config.clj during load, not in run.clj during execution
**Warning signs:** Same warning repeats on every `aishell claude` invocation

### Pitfall 5: Merge Semantics for Map-of-Lists

**What goes wrong:** Simple list merge (concat global project) doesn't work for harness_args because it's a map
**Why it happens:** harness_args is different from mounts/ports (flat lists) - it's a map where values are lists
**How to avoid:** Add harness_args to a new category: map-of-lists. Merge the map keys, then concatenate lists per key.
**Warning signs:** Type error when trying to concat maps, or losing per-harness granularity

```clojure
;; WRONG: treating harness_args like a simple list
(concat global-harness-args project-harness-args)  ;; Can't concat maps!

;; RIGHT: merge map keys, concatenate per-key lists
(defn merge-harness-args [global-args project-args]
  (merge-with (fn [g p] (vec (concat (or g []) (or p []))))
              global-args
              project-args))

;; Example:
;; Global: {:claude ["--a"]}
;; Project: {:claude ["--b"] :opencode ["--c"]}
;; Result: {:claude ["--a" "--b"] :opencode ["--c"]}
```

## Code Examples

Verified patterns for implementation:

### Config Loading with Validation

```clojure
;; Source: Extending src/aishell/config.clj patterns

(def known-keys
  "Valid config keys. Unknown keys trigger warning."
  #{:mounts :env :ports :docker_args :pre_start :extends :harness_args})

(def known-harnesses
  "Valid harness names for harness_args validation."
  #{"claude" "opencode"})

(defn normalize-harness-args
  "Normalize harness_args map: convert string values to single-element lists."
  [harness-args-map]
  (when harness-args-map
    (into {}
          (map (fn [[k v]]
                 [k (cond
                      (string? v) [v]
                      (sequential? v) (vec v)
                      :else [])])
               harness-args-map))))

(defn validate-harness-names
  "Warn if harness_args contains unknown harness names."
  [harness-args-map source-path]
  (when harness-args-map
    (let [config-harnesses (set (map name (keys harness-args-map)))
          unknown (clojure.set/difference config-harnesses known-harnesses)]
      (when (seq unknown)
        (output/warn (str "Unknown harness names in " source-path
                         " harness_args: "
                         (clojure.string/join ", " unknown)))))))

(defn validate-config
  "Validate config map. Warns on unknown keys and harness names."
  [config source-path]
  (when config
    ;; Existing validation for unknown keys
    (let [config-keys (set (keys config))
          unknown (clojure.set/difference config-keys known-keys)]
      (when (seq unknown)
        (output/warn (str "Unknown config keys in " source-path ": "
                         (clojure.string/join ", " (map name unknown))))))
    ;; NEW: Validate harness names in harness_args
    (when-let [harness-args (:harness_args config)]
      (validate-harness-names harness-args source-path)))
  config)
```

### Config Merging for harness_args

```clojure
;; Source: Extending src/aishell/config.clj merge-configs

(defn merge-harness-args
  "Merge harness_args maps: merge keys, concatenate per-harness lists.
   Global defaults come first (can be overridden by position)."
  [global-args project-args]
  (merge-with (fn [global-list project-list]
                (vec (concat (or global-list [])
                            (or project-list []))))
              global-args
              project-args))

(defn merge-configs
  "Merge global-config and project-config with defined strategy."
  [global-config project-config]
  (let [list-keys #{:mounts :ports :docker_args}
        map-keys #{:env}
        scalar-keys #{:pre_start}
        ;; NEW: map-of-lists requires special merge
        map-of-lists-keys #{:harness_args}
        merged (reduce
                (fn [acc k]
                  (cond
                    ;; List keys - concatenate
                    (contains? list-keys k)
                    (let [global-val (get global-config k)
                          project-val (get project-config k)]
                      (if (or global-val project-val)
                        (assoc acc k (vec (concat (or global-val [])
                                                 (or project-val []))))
                        acc))

                    ;; Map keys - shallow merge
                    (contains? map-keys k)
                    (let [global-val (get global-config k)
                          project-val (get project-config k)]
                      (if (or global-val project-val)
                        (assoc acc k (merge (or global-val {})
                                           (or project-val {})))
                        acc))

                    ;; NEW: Map-of-lists - merge keys, concat lists
                    (contains? map-of-lists-keys k)
                    (let [global-val (get global-config k)
                          project-val (get project-config k)]
                      (if (or global-val project-val)
                        (assoc acc k (merge-harness-args global-val project-val))
                        acc))

                    ;; Scalar keys - project wins
                    (contains? scalar-keys k)
                    (if-let [project-val (get project-config k)]
                      (assoc acc k project-val)
                      (if-let [global-val (get global-config k)]
                        (assoc acc k global-val)
                        acc))

                    :else acc))
                {}
                (clojure.set/union (set (keys global-config))
                                  (set (keys project-config))))]
    ;; Remove :extends key from result
    (dissoc merged :extends)))
```

### Argument Injection at Invocation

```clojure
;; Source: Extending src/aishell/run.clj run-container

(defn run-container
  "Run docker container for shell or harness.
   Arguments:
   - cmd: nil (shell), \"claude\", or \"opencode\"
   - harness-args: Extra arguments to pass to harness (vector)"
  [cmd harness-args]
  ;; ... existing setup code ...

  (let [cfg (config/load-config project-dir)

        ;; NEW: Extract defaults for this harness
        defaults (when (and cfg cmd)
                   (get-in cfg [:harness_args (keyword cmd)] []))

        ;; NEW: Normalize to vector (handle nil)
        defaults-vec (vec (or defaults []))

        ;; NEW: Merge defaults with CLI args (defaults first)
        merged-args (vec (concat defaults-vec harness-args))

        ;; NEW: Verbose output for applied defaults
        _ (when (and cfg (seq defaults-vec))
            (output/verbose (str "Applying default " cmd " args: "
                                (clojure.string/join " " defaults-vec))))

        ;; Build container command with merged args
        container-cmd (case cmd
                        "claude"
                        (into ["claude" "--dangerously-skip-permissions"]
                              merged-args)

                        "opencode"
                        (into ["opencode"] merged-args)

                        ;; Default: bash shell
                        ["/bin/bash"])]

    ;; Execute
    (apply p/exec (concat docker-args container-cmd))))
```

### Example Config YAML

```yaml
# Global config: ~/.aishell/config.yaml
harness_args:
  claude:
    - "--add-plugin"
    - "context7"
  opencode:
    - "--model"
    - "gpt-4"

# Project config: .aishell/config.yaml
extends: global

harness_args:
  claude:
    - "--verbose"  # Concatenates with global: ["--add-plugin", "context7", "--verbose"]

# Resulting merged config for this project:
# harness_args:
#   claude: ["--add-plugin", "context7", "--verbose"]
#   opencode: ["--model", "gpt-4"]

# CLI invocation:
# $ aishell claude --help
# Executes: claude --dangerously-skip-permissions --add-plugin context7 --verbose --help
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Manual args every time | Config-based defaults | This phase | Reduces repetition, better UX for common flags |
| Bash array handling | Clojure sequences (concat, into) | v2.0 (Phase 13-18) | Cleaner data flow, cross-platform |
| Shell-style run.conf | YAML config.yaml | v2.0 (Phase 16) | Better structure, native parsing |

**Deprecated/outdated:**
- N/A - This is a new feature, not a replacement

## Open Questions

1. **Key name choice (Claude's discretion)**
   - What we know: Context suggests `harness_args`, `default_args`, or `args`
   - What's unclear: Which name feels most natural in config.yaml?
   - Recommendation: Use `harness_args` - clearest intent, matches existing `docker_args` pattern

2. **--no-defaults flag (Claude's discretion)**
   - What we know: Could allow skipping defaults for one-off invocations
   - What's unclear: Is this needed? CLI args can already override by position
   - Recommendation: Skip for v1. Position-based override is sufficient. Add only if users request it.

3. **validate command (Claude's discretion)**
   - What we know: Could add `aishell validate` to check config without running
   - What's unclear: Is this valuable? Warnings already show on first use
   - Recommendation: Skip for v1. Config validation happens automatically on load. Add only if debugging becomes painful.

4. **When to show validation warnings (Claude's discretion)**
   - What we know: Could show on any command vs only when using that harness
   - What's unclear: Is noise (showing claude warnings when running opencode) a problem?
   - Recommendation: Show all warnings on any invocation. Config is loaded once per run, validation is cheap, and seeing all issues upfront is better UX.

## Sources

### Primary (HIGH confidence)

- `/home/jonasrodrigues/projects/harness/src/aishell/config.clj` - Existing config loading, validation, merge patterns (lines 9-146)
- `/home/jonasrodrigues/projects/harness/src/aishell/run.clj` - Harness invocation flow, argument passing (lines 53-129)
- `/home/jonasrodrigues/projects/harness/.planning/quick/004-add-extends-key-for-config-merge-strateg/004-PLAN.md` - Merge strategy implementation patterns
- `/home/jonasrodrigues/projects/harness/.planning/phases/18.1-default-harness-args/18.1-CONTEXT.md` - Phase decisions and constraints
- Babashka REPL testing - Verified YAML parsing behavior for string vs list values

### Secondary (MEDIUM confidence)

- `/home/jonasrodrigues/projects/harness/.planning/research/STACK.md` - Babashka built-in library usage patterns
- `/home/jonasrodrigues/projects/harness/src/aishell/validation.clj` - Advisory warning patterns

### Tertiary (LOW confidence)

- N/A - All findings verified with codebase or REPL

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All built-in Babashka, already in use
- Architecture: HIGH - Direct extension of existing patterns in config.clj and run.clj
- Pitfalls: HIGH - Based on concrete examples from codebase (keyword vs string, nil handling)

**Research date:** 2026-01-22
**Valid until:** 60 days (stable codebase, no fast-moving dependencies)
