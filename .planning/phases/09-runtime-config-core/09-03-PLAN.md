---
phase: 09-runtime-config-core
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - aishell
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Invalid config variable produces clear error message visible to user"
    - "MOUNTS with source:destination format works correctly"
    - "MOUNTS with source-only format continues to work"
    - "ENV passthrough works with simple config"
  artifacts:
    - path: "aishell"
      provides: "Fixed parse_run_conf using error() function"
      contains: "error.*Config error"
    - path: "aishell"
      provides: "build_mount_args supporting source:destination format"
      contains: "source:destination"
  key_links:
    - from: "parse_run_conf"
      to: "error()"
      via: "function call on invalid config"
      pattern: "error.*Config error"
    - from: "build_mount_args"
      to: "docker -v"
      via: "colon detection for format"
      pattern: "\\*:\\*"
---

<objective>
Fix three UAT failures in runtime config: error display, MOUNTS source:destination format, and ENV passthrough

Purpose: Close gaps identified during user acceptance testing where config errors were silent and MOUNTS with colons failed
Output: Working runtime config with clear error messages and support for both mount formats
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-runtime-config-core/09-01-SUMMARY.md
@.planning/phases/09-runtime-config-core/09-02-SUMMARY.md
@.planning/phases/09-runtime-config-core/09-UAT.md
@aishell
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix parse_run_conf error output using error() function</name>
  <files>aishell</files>
  <action>
Modify parse_run_conf() (around lines 461-468) to use the existing error() function instead of direct echo/exit.

**Current problematic code (lines 461-468):**
```bash
else
    # Provide helpful error with line number and context
    echo -e "${RED}Config error${NC} in $config_file line $line_num:" >&2
    echo "  $line" >&2
    echo "" >&2
    echo "Expected format: VARIABLE=value or VARIABLE=\"value with spaces\"" >&2
    echo "Allowed variables: MOUNTS, ENV, PORTS, DOCKER_ARGS, PRE_START" >&2
    exit 1
fi
```

**Replace with:**
```bash
else
    # Provide helpful error with line number and context
    # Build multiline message for error() function
    local err_msg="Config error in $config_file line $line_num:
  $line

Expected format: VARIABLE=value or VARIABLE=\"value with spaces\"
Allowed variables: MOUNTS, ENV, PORTS, DOCKER_ARGS, PRE_START"
    error "$err_msg"
fi
```

**Why this fixes the issue:**
- The existing error() function (line 63-66) uses `echo -e` to stderr AND calls `exit 1`
- By consolidating into error(), we get consistent colored output and immediate exit
- The error() function is proven to work for other error cases in the script
- Multiline strings work fine with error() - it just passes to echo -e

**Alternative if multiline doesn't render well:** Use printf to build the message:
```bash
else
    printf -v err_msg 'Config error in %s line %d:\n  %s\n\nExpected format: VARIABLE=value or VARIABLE="value with spaces"\nAllowed variables: MOUNTS, ENV, PORTS, DOCKER_ARGS, PRE_START' \
        "$config_file" "$line_num" "$line"
    error "$err_msg"
fi
```
  </action>
  <verify>
Test with invalid config:
```bash
mkdir -p /tmp/test-error/.aishell
echo 'INVALID_VAR=test' > /tmp/test-error/.aishell/run.conf
cd /tmp/test-error && /home/jonasrodrigues/projects/harness/aishell 2>&1
# Should see colored "Error: Config error in..." message
echo "Exit code: $?"
# Should be 1
```
  </verify>
  <done>
- parse_run_conf uses error() function for invalid config
- Error message is visible to user (colored, to stderr)
- Exit code is 1 on invalid config
  </done>
</task>

<task type="auto">
  <name>Task 2: Support source:destination format in build_mount_args</name>
  <files>aishell</files>
  <action>
Modify build_mount_args() (lines 477-508) to support BOTH formats:
- Source-only: `/path/to/dir` mounts at same path in container
- Source:destination: `/host/path:/container/path` mounts at different path

**Current code produces malformed output:**
When input is `$HOME/.config:/home/user/.config`, current code does:
1. Expands $HOME: `/home/jonas/.config:/home/user/.config`
2. Outputs: `-v /home/jonas/.config:/home/user/.config:/home/jonas/.config:/home/user/.config`
This has FOUR colons, which is invalid for `docker -v`.

**Replace the function body (lines 477-508) with:**
```bash
build_mount_args() {
    local mounts_str="$1"

    [[ -z "$mounts_str" ]] && return 0

    # Split on whitespace
    for mount_entry in $mounts_str; do
        local source=""
        local destination=""

        # Check if this is source:destination format
        # Look for : that's not part of $HOME or ${HOME}
        if [[ "$mount_entry" == *":"* && ! "$mount_entry" =~ ^\$\{?HOME\}?:$ ]]; then
            # Has colon - split into source and destination
            # Handle case where source might have $HOME
            source="${mount_entry%%:*}"
            destination="${mount_entry#*:}"
        else
            # Source-only format - use same path for both
            source="$mount_entry"
            destination=""
        fi

        # Expand $HOME in source
        source="${source//\$HOME/$HOME}"
        source="${source//\$\{HOME\}/$HOME}"
        if [[ "$source" == "~"* ]]; then
            source="$HOME${source:1}"
        fi

        # Expand $HOME in destination if present
        if [[ -n "$destination" ]]; then
            destination="${destination//\$HOME/$HOME}"
            destination="${destination//\$\{HOME\}/$HOME}"
            if [[ "$destination" == "~"* ]]; then
                destination="$HOME${destination:1}"
            fi
        else
            # Source-only: destination equals source
            destination="$source"
        fi

        # Resolve source to absolute path if exists
        if [[ -e "$source" ]]; then
            source=$(realpath "$source")
        else
            warn "Mount source does not exist: $source"
        fi

        # Output mount flags
        printf '%s\n' "-v"
        printf '%s\n' "$source:$destination"
    done
}
```

**Key changes:**
1. Detect source:destination by presence of colon (but not in $HOME pattern)
2. Split on first colon only (%%:* and #*:)
3. Expand $HOME in both source AND destination
4. Handle ~ in both source AND destination
5. Only resolve source to realpath (destination is container path)
  </action>
  <verify>
Test both mount formats:
```bash
# Test source:destination format
mkdir -p /tmp/test-mounts/.aishell /tmp/test-mounts/config
echo 'MOUNTS="$HOME/.config:/home/user/.config"' > /tmp/test-mounts/.aishell/run.conf
cd /tmp/test-mounts && /home/jonasrodrigues/projects/harness/aishell -v echo test 2>&1
# Should show: -v /home/jonas/.config:/home/user/.config (two colons only)

# Test source-only format still works
echo 'MOUNTS="$HOME/.config"' > /tmp/test-mounts/.aishell/run.conf
cd /tmp/test-mounts && /home/jonasrodrigues/projects/harness/aishell -v echo test 2>&1
# Should show: -v /home/jonas/.config:/home/jonas/.config

# Test mixed formats
echo 'MOUNTS="$HOME/.ssh $HOME/.config:/config"' > /tmp/test-mounts/.aishell/run.conf
cd /tmp/test-mounts && /home/jonasrodrigues/projects/harness/aishell -v echo test 2>&1
# Should show both mounts with correct format
```
  </verify>
  <done>
- build_mount_args handles source:destination format correctly
- build_mount_args still handles source-only format
- $HOME expanded in both source and destination
- No malformed docker -v arguments with triple/quadruple colons
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify ENV passthrough works independently</name>
  <files>aishell</files>
  <action>
This task verifies ENV parsing works correctly without MOUNTS issues causing cascading failures.

**No code changes expected** - just verification that ENV works when MOUNTS is fixed or absent.

Run verification tests:

1. **ENV-only config (no MOUNTS):**
```bash
mkdir -p /tmp/test-env/.aishell
cat > /tmp/test-env/.aishell/run.conf << 'EOF'
ENV="EDITOR"
EOF
export EDITOR=vim
cd /tmp/test-env && /home/jonasrodrigues/projects/harness/aishell -v echo test 2>&1
# Should show: -e EDITOR in verbose output
```

2. **ENV with literal value:**
```bash
cat > /tmp/test-env/.aishell/run.conf << 'EOF'
ENV="DEBUG_MODE=1"
EOF
cd /tmp/test-env && /home/jonasrodrigues/projects/harness/aishell -v echo test 2>&1
# Should show: -e DEBUG_MODE=1 in verbose output
```

3. **ENV with mixed passthrough and literal:**
```bash
cat > /tmp/test-env/.aishell/run.conf << 'EOF'
ENV="EDITOR DEBUG_MODE=1"
EOF
export EDITOR=vim
cd /tmp/test-env && /home/jonasrodrigues/projects/harness/aishell -v echo test 2>&1
# Should show both -e EDITOR and -e DEBUG_MODE=1
```

**If any test fails**, investigate build_env_args() (lines 510-531) for similar issues to build_mount_args.

**Expected outcome:** ENV works correctly - the UAT failure was cascading from MOUNTS failure.
  </action>
  <verify>
```bash
# Comprehensive ENV test
mkdir -p /tmp/test-env/.aishell
export TEST_VAR="hello"
cat > /tmp/test-env/.aishell/run.conf << 'EOF'
ENV="TEST_VAR LITERAL_VAR=world"
EOF
cd /tmp/test-env && /home/jonasrodrigues/projects/harness/aishell -v printenv TEST_VAR LITERAL_VAR 2>&1
# Inside container should show:
# hello
# world
```
  </verify>
  <done>
- ENV passthrough (VAR) works with host environment variables
- ENV literal (VAR=value) works for setting values
- Mixed ENV configs work correctly
- Container starts successfully with ENV-only config
  </done>
</task>

</tasks>

<verification>
After completing all tasks, run the original UAT tests:

**Test 2 (Config error messages):**
```bash
mkdir -p /tmp/uat-test/.aishell
echo 'INVALID_VAR=test' > /tmp/uat-test/.aishell/run.conf
cd /tmp/uat-test && /home/jonasrodrigues/projects/harness/aishell 2>&1 | head -10
# Expected: Visible colored error message with line number
```

**Test 3 (MOUNTS with source:destination):**
```bash
mkdir -p /tmp/uat-test/.aishell ~/.config
echo 'MOUNTS="$HOME/.config:/home/user/.config"' > /tmp/uat-test/.aishell/run.conf
cd /tmp/uat-test && /home/jonasrodrigues/projects/harness/aishell ls /home/user/.config
# Expected: Container starts and lists config directory contents
```

**Test 5 (ENV passthrough):**
```bash
export EDITOR=vim
echo 'ENV="EDITOR"' > /tmp/uat-test/.aishell/run.conf
cd /tmp/uat-test && /home/jonasrodrigues/projects/harness/aishell printenv EDITOR
# Expected: Outputs "vim"
```
</verification>

<success_criteria>
- Invalid config variables produce visible error messages (colored, with line number)
- MOUNTS="source:destination" format works (container starts, path mounted correctly)
- MOUNTS="source" format continues to work (backward compatible)
- ENV passthrough works independently of MOUNTS
- All three UAT gaps closed
</success_criteria>

<output>
After completion, create `.planning/phases/09-runtime-config-core/09-03-SUMMARY.md`
</output>
