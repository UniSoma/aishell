---
phase: 09-runtime-config-core
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - aishell
autonomous: true

must_haves:
  truths:
    - "User can specify MOUNTS in run.conf and paths are mounted to container"
    - "User can specify ENV and variables are passed to container"
    - "User can specify PORTS and ports are exposed"
    - "User can specify DOCKER_ARGS and they are passed through"
    - "$HOME in MOUNTS is expanded to actual home path"
    - "VAR syntax in ENV passes through host value"
    - "VAR=value syntax in ENV sets literal value"
  artifacts:
    - path: "aishell"
      provides: "build_mount_args, build_env_args, build_port_args functions"
      contains: "build_mount_args"
    - path: "aishell"
      provides: "apply_runtime_config function"
      contains: "apply_runtime_config"
  key_links:
    - from: "main()"
      to: "parse_run_conf"
      via: "function call"
      pattern: "parse_run_conf"
    - from: "docker_args"
      to: "CONF_MOUNTS"
      via: "build_mount_args"
      pattern: "build_mount_args.*CONF_MOUNTS"
---

<objective>
Implement argument builders and integrate runtime config into docker run

Purpose: Build docker run arguments from parsed config and wire into main execution flow
Output: Working runtime configuration that applies MOUNTS, ENV, PORTS, DOCKER_ARGS to container launch
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-runtime-config-core/09-RESEARCH.md
@.planning/phases/09-runtime-config-core/09-01-SUMMARY.md
@aishell
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add argument builder functions</name>
  <files>aishell</files>
  <action>
Add four argument builder functions to aishell. Place them after parse_run_conf (in a new "Runtime Config" section).

**1. build_mount_args()**
- Takes mounts string as argument (space-separated paths)
- For each path:
  - Expand $HOME using parameter substitution: ${path//\$HOME/$HOME}
  - Expand ${HOME} syntax: ${path//\$\{HOME\}/$HOME}
  - Handle ~ at start: if [[ "$path" == "~"* ]]; then path="$HOME${path:1}"; fi
  - Resolve to absolute path with realpath if path exists
  - Warn (don't error) if path doesn't exist using warn() function
  - Output "-v" then "$expanded_path:$expanded_path" (same path in container)
- Return 0 even if some paths don't exist (Docker handles gracefully)

**2. build_env_args()**
- Takes env string as argument (space-separated entries)
- For each entry:
  - If contains "=": literal value, output "-e" then the entry
  - If no "=": passthrough from host
    - Check if variable exists on host: [[ -v "$env_entry" ]]
    - If exists: output "-e" then the variable name
    - If not exists: warn "Skipping unset host variable: $env_entry"

**3. build_port_args()**
- Takes ports string as argument (space-separated port mappings)
- For each port:
  - Validate format: ^[0-9]+:[0-9]+(/[a-z]+)?$
  - If valid: output "-p" then the port spec
  - If invalid: call error() with helpful message about expected format

**4. apply_runtime_config()**
- Takes project_dir and docker_args array name as arguments
- Uses nameref: local -n docker_args_ref="$2"
- Calls parse_run_conf "$project_dir/.aishell/run.conf"
- For each non-empty CONF_* variable:
  - Call appropriate builder function
  - Read output line-by-line and append to docker_args_ref
- For CONF_DOCKER_ARGS: word-split and append directly (with shellcheck disable SC2206)

Use the patterns from 09-RESEARCH.md for implementation details.
  </action>
  <verify>
Test each builder function independently:
```bash
# Test mount args
result=$(build_mount_args '$HOME/.ssh $HOME/.config')
echo "$result"  # Should show -v /home/user/.ssh:/home/user/.ssh etc

# Test env args
export TEST_VAR=hello
result=$(build_env_args 'TEST_VAR DEBUG=1')
echo "$result"  # Should show -e TEST_VAR -e DEBUG=1

# Test port args
result=$(build_port_args '3000:3000 8080:80')
echo "$result"  # Should show -p 3000:3000 -p 8080:80
```
  </verify>
  <done>
- build_mount_args expands $HOME and outputs -v flags
- build_env_args handles both passthrough and literal syntax
- build_port_args validates format and outputs -p flags
- apply_runtime_config orchestrates all builders
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate runtime config into main()</name>
  <files>aishell</files>
  <action>
Modify main() to apply runtime configuration before docker run.

Insert the integration code after the existing docker_args initialization and API env vars (around line 1162, before the "Dispatch based on command" section).

Add:
```bash
# Apply runtime configuration from .aishell/run.conf
local config_file="$project_dir/.aishell/run.conf"
if [[ -f "$config_file" ]]; then
    verbose "Loading runtime config: $config_file"
    parse_run_conf "$config_file"

    # Add configured mounts
    if [[ -n "$CONF_MOUNTS" ]]; then
        while IFS= read -r arg; do
            [[ -n "$arg" ]] && docker_args+=("$arg")
        done < <(build_mount_args "$CONF_MOUNTS")
    fi

    # Add configured environment variables
    if [[ -n "$CONF_ENV" ]]; then
        while IFS= read -r arg; do
            [[ -n "$arg" ]] && docker_args+=("$arg")
        done < <(build_env_args "$CONF_ENV")
    fi

    # Add configured port mappings
    if [[ -n "$CONF_PORTS" ]]; then
        while IFS= read -r arg; do
            [[ -n "$arg" ]] && docker_args+=("$arg")
        done < <(build_port_args "$CONF_PORTS")
    fi

    # Add extra docker arguments (word splitting intentional)
    if [[ -n "$CONF_DOCKER_ARGS" ]]; then
        # shellcheck disable=SC2206
        docker_args+=($CONF_DOCKER_ARGS)
    fi
fi
```

Also add verbose output showing what was loaded from config for debugging.
  </action>
  <verify>
End-to-end test:
```bash
# Create test project with run.conf
mkdir -p /tmp/test-project/.aishell
cat > /tmp/test-project/.aishell/run.conf << 'EOF'
MOUNTS="$HOME/.ssh"
ENV="EDITOR"
PORTS="3000:3000"
DOCKER_ARGS="--hostname=test"
EOF

cd /tmp/test-project
aishell build  # Build base image first
aishell -v     # Verbose mode shows config loading

# Inside container, verify:
# - ~/.ssh is mounted
# - EDITOR env var is set
# - Port 3000 is exposed
# - Hostname is 'test'
```
  </verify>
  <done>
- Runtime config is loaded before docker run
- Mounts, env vars, ports, docker args applied to container
- Verbose mode shows config loading
  </done>
</task>

<task type="auto">
  <name>Task 3: Update usage documentation</name>
  <files>aishell</files>
  <action>
Update the usage() function to document runtime configuration.

Add a new section to the help output:

```
Runtime Configuration:
    Create .aishell/run.conf to configure container runtime:

    MOUNTS="$HOME/.ssh $HOME/.config/git"    # Additional volume mounts
    ENV="EDITOR DEBUG_MODE=1"                 # Environment variables
    PORTS="3000:3000 8080:80"                 # Port mappings
    DOCKER_ARGS="--cap-add=SYS_PTRACE"        # Extra docker run args

    See: https://github.com/user/aishell#runtime-configuration
```

Place this section after "Project Extensions" and before "Examples".
  </action>
  <verify>
```bash
aishell --help
# Verify new "Runtime Configuration" section appears
```
  </verify>
  <done>
- Help output documents run.conf format
- Shows examples of MOUNTS, ENV, PORTS, DOCKER_ARGS
  </done>
</task>

</tasks>

<verification>
Full integration test:
1. Create project with .aishell/run.conf containing all four config types
2. Run `aishell build` then `aishell -v`
3. Verify verbose output shows config loading
4. Inside container:
   - Check mounted paths exist
   - Check environment variables are set
   - Check ports are mapped (netstat or ss)
   - Check docker args took effect (e.g., hostname)
</verification>

<success_criteria>
- All argument builder functions implemented
- Runtime config integrated into main()
- Help updated with runtime config documentation
- Requirements covered: RCONF-01, MOUNT-01, MOUNT-02, MOUNT-03, ENV-01, ENV-02, ENV-03, PORT-01, PORT-02, DARG-01, DARG-02
</success_criteria>

<output>
After completion, create `.planning/phases/09-runtime-config-core/09-02-SUMMARY.md`
</output>
