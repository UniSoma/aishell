---
phase: 09-runtime-config-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - aishell
autonomous: true

must_haves:
  truths:
    - "Config file .aishell/run.conf is parsed when present"
    - "Only MOUNTS, ENV, PORTS, DOCKER_ARGS variables are accepted"
    - "Syntax errors show line number and helpful message"
    - "Missing config file is silently ignored (not an error)"
  artifacts:
    - path: "aishell"
      provides: "parse_run_conf function"
      contains: "parse_run_conf"
  key_links:
    - from: "parse_run_conf"
      to: "CONF_* variables"
      via: "declare -g"
      pattern: 'declare -g "CONF_'
---

<objective>
Implement safe config file parser for .aishell/run.conf

Purpose: Parse runtime configuration with security (whitelist approach) and good error messages
Output: parse_run_conf() function added to aishell script that sets CONF_MOUNTS, CONF_ENV, CONF_PORTS, CONF_DOCKER_ARGS
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-runtime-config-core/09-RESEARCH.md
@aishell
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add parse_run_conf function</name>
  <files>aishell</files>
  <action>
Add the parse_run_conf() function to aishell script. Place it in the "State Management" section (after read_state_file, around line 403).

The function must:
1. Accept config file path as argument
2. Initialize CONF_MOUNTS, CONF_ENV, CONF_PORTS, CONF_DOCKER_ARGS to empty strings
3. Return 0 if config file does not exist (silent skip)
4. Parse file line-by-line using `while IFS= read -r line`
5. Skip empty lines and comments (lines starting with #)
6. Trim leading/trailing whitespace from each line
7. Validate each line matches pattern: ^(MOUNTS|ENV|PORTS|DOCKER_ARGS)=(.*)$
8. Strip surrounding quotes (double or single) from values
9. Use declare -g to set CONF_${var_name}=$var_value
10. On invalid lines, output error with RED color, line number, the offending line, expected format, and allowed variables, then exit 1

Use the RUNCONF_ALLOWED_VARS pattern from research:
```bash
readonly RUNCONF_ALLOWED_VARS="MOUNTS|ENV|PORTS|DOCKER_ARGS"
```

Error format example:
```
Config error in .aishell/run.conf line 5:
  INVALID_VAR=something

Expected format: VARIABLE=value or VARIABLE="value with spaces"
Allowed variables: MOUNTS, ENV, PORTS, DOCKER_ARGS
```

Reference the existing read_state_file() pattern (lines 379-403) for the validation approach.
  </action>
  <verify>
Create test config files and verify parsing:
```bash
# Create test project
mkdir -p /tmp/test-aishell/.aishell

# Test 1: Valid config
cat > /tmp/test-aishell/.aishell/run.conf << 'EOF'
# Test config
MOUNTS="$HOME/.ssh $HOME/.config/git"
ENV="EDITOR DEBUG_MODE=1"
PORTS="3000:3000"
DOCKER_ARGS="--cap-add=SYS_PTRACE"
EOF

# Source aishell functions and test parsing
cd /tmp/test-aishell
source /path/to/aishell  # Or test inline
```
  </verify>
  <done>
- parse_run_conf function exists in aishell
- Valid config files parse without errors
- Invalid variable names produce error with line number
- Missing config file returns 0 (no error)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for config parsing</name>
  <files>aishell</files>
  <action>
Create a test section or test script that validates parse_run_conf behavior. Add these test cases:

1. **Missing config file**: Returns 0, all CONF_* variables are empty
2. **Empty config file**: Returns 0, all CONF_* variables are empty
3. **Comments only**: Returns 0, all CONF_* variables are empty
4. **Valid single variable**: MOUNTS="$HOME/.ssh" sets CONF_MOUNTS correctly
5. **Valid all variables**: All four variables parsed correctly
6. **Invalid variable name**: INVALID=foo produces error with line number
7. **Unquoted value**: MOUNTS=$HOME/.ssh works (no quotes required for simple values)
8. **Mixed valid/invalid**: First invalid line causes error, valid lines before it are parsed

Test by running inline bash that sources the script functions and calls parse_run_conf with test files.

The test can be a separate script `test-parse-config.sh` in the project root, or inline verification commands.
  </action>
  <verify>
Run test cases and verify output:
```bash
# Run test script
./test-parse-config.sh

# Or run inline tests
```
  </verify>
  <done>
- All test cases pass
- Error messages include line numbers
- Config values are correctly stored in CONF_* variables
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. Parse valid config file without errors
2. Parse invalid config file and see helpful error message
3. Verify CONF_* variables are set correctly after parsing
4. Verify missing config file is handled gracefully
</verification>

<success_criteria>
- parse_run_conf() function added to aishell
- Function sets CONF_MOUNTS, CONF_ENV, CONF_PORTS, CONF_DOCKER_ARGS
- Invalid lines produce errors with line numbers
- Only whitelisted variables accepted (MOUNTS, ENV, PORTS, DOCKER_ARGS)
- Requirements covered: RCONF-01 (partial), RCONF-02, RCONF-03
</success_criteria>

<output>
After completion, create `.planning/phases/09-runtime-config-core/09-01-SUMMARY.md`
</output>
