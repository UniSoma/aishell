---
phase: 23-context-config
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/aishell/detection/gitignore.clj
  - src/aishell/detection/core.clj
autonomous: true

must_haves:
  truths:
    - "High-severity findings NOT in .gitignore show '(risk: may be committed)' suffix"
    - "High-severity findings IN .gitignore show no extra text"
    - "Medium and low-severity findings show no gitignore status (regardless of status)"
    - "Non-git directories treat all files as unprotected"
  artifacts:
    - path: "src/aishell/detection/gitignore.clj"
      provides: "git check-ignore wrapper function"
      exports: ["gitignored?"]
    - path: "src/aishell/detection/core.clj"
      provides: "Gitignore-aware warning display"
      contains: "gitignore"
  key_links:
    - from: "src/aishell/detection/core.clj"
      to: "git check-ignore"
      via: "gitignore/gitignored? function"
      pattern: "gitignore/gitignored\\?"
---

<objective>
Add gitignore status checking for high-severity findings to help users identify files that may be accidentally committed.

Purpose: High-severity files (SSH keys, credentials) that are NOT in .gitignore represent a higher risk of accidental exposure. Adding "(risk: may be committed)" suffix draws attention to this specific danger.

Output: gitignore.clj namespace with git check-ignore wrapper, modified core.clj that annotates high-severity findings with gitignore status.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-context-config/23-CONTEXT.md
@.planning/phases/23-context-config/23-RESEARCH.md

@src/aishell/detection/core.clj
@src/aishell/detection/formatters.clj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create gitignore.clj with git check-ignore wrapper</name>
  <files>src/aishell/detection/gitignore.clj</files>
  <action>
Create new namespace `aishell.detection.gitignore` with:

1. `gitignored?` function that:
   - Takes `project-dir` and `file-path` arguments
   - Executes `git check-ignore -q {file-path}` in project-dir
   - Uses babashka.process with `:continue true` to capture exit code
   - Returns:
     - `true` if exit code 0 (file IS ignored)
     - `false` if exit code 1 (file is NOT ignored)
     - `nil` on any exception or other exit code (not a git repo, etc.)

Pattern from RESEARCH.md:
```clojure
(defn gitignored?
  [project-dir file-path]
  (try
    (let [result (p/shell {:dir project-dir
                          :out :string
                          :err :string
                          :continue true}
                         "git" "check-ignore" "-q" file-path)]
      (case (:exit result)
        0 true
        1 false
        nil))
    (catch Exception _e nil)))
```

Require `babashka.process :as p`.
  </action>
  <verify>
Run in REPL:
```clojure
(require '[aishell.detection.gitignore :as gi])
;; Create test file
(spit "test-ignored.txt" "test")
;; Should return false (not ignored, assuming not in .gitignore)
(gi/gitignored? "." "test-ignored.txt")
;; Clean up
(babashka.fs/delete "test-ignored.txt")
```
  </verify>
  <done>gitignored? returns true for ignored files, false for non-ignored files, nil for non-git directories</done>
</task>

<task type="auto">
  <name>Task 2: Integrate gitignore check into high-severity finding display</name>
  <files>src/aishell/detection/core.clj</files>
  <action>
Modify `display-warnings` in core.clj to:

1. Add require for `[aishell.detection.gitignore :as gitignore]`

2. Create helper function `annotate-with-gitignore-status`:
   - Takes `project-dir` and `findings`
   - For each finding with `:severity :high`:
     - Call `(gitignore/gitignored? project-dir (:path finding))`
     - If result is `false` (explicitly NOT ignored), append " (risk: may be committed)" to `:reason`
     - If result is `true` or `nil`, leave `:reason` unchanged
   - For medium/low severity, return finding unchanged
   - Return updated findings vector

3. Call `annotate-with-gitignore-status` BEFORE grouping by severity in `display-warnings`:
   - Get project-dir from somewhere (add as parameter to display-warnings)
   - Apply annotation to all findings
   - Then proceed with existing display logic

4. Update `display-warnings` signature to accept `project-dir` as first argument:
   ```clojure
   (defn display-warnings
     [project-dir findings]
     ...)
   ```

5. Update the caller in run.clj to pass project-dir to display-warnings.

Important: Only check gitignore for `:high` severity. Medium/low are not annotated per CONTEXT.md decision.
  </action>
  <verify>
1. Create a test file that should NOT be in gitignore:
```bash
touch id_rsa_test
```

2. Run aishell shell in project dir and verify output shows:
   `HIGH id_rsa_test - SSH private key file (risk: may be committed)`

3. Add to .gitignore:
```bash
echo "id_rsa_test" >> .gitignore
```

4. Run again - should NOT show "(risk: may be committed)" suffix

5. Clean up:
```bash
rm id_rsa_test
git checkout .gitignore
```
  </verify>
  <done>High-severity findings NOT in .gitignore show "(risk: may be committed)", those in .gitignore do not</done>
</task>

</tasks>

<verification>
1. Namespace loads: `(require '[aishell.detection.gitignore :as gi] '[aishell.detection.core :as core])`
2. gitignored? function exists and returns boolean/nil
3. High-severity + NOT ignored -> "(risk: may be committed)" appended
4. High-severity + ignored -> no annotation
5. Medium/low severity -> no annotation regardless of gitignore status
6. Non-git directory -> all files treated as unprotected (nil from gitignored? = no annotation but default assumption is unprotected)
</verification>

<success_criteria>
- [ ] src/aishell/detection/gitignore.clj exists with gitignored? function
- [ ] gitignored? correctly returns true/false/nil based on git check-ignore exit code
- [ ] display-warnings accepts project-dir parameter
- [ ] High-severity findings get gitignore status check
- [ ] "(risk: may be committed)" appended only when gitignored? returns false
- [ ] Medium/low severity findings unchanged
- [ ] All namespaces load without error
</success_criteria>

<output>
After completion, create `.planning/phases/23-context-config/23-01-SUMMARY.md`
</output>
