---
phase: 24-dockerfile---build-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["24-01"]
files_modified:
  - src/aishell/docker/build.clj
  - src/aishell/state.clj
autonomous: true

must_haves:
  truths:
    - "Build passes --build-arg WITH_CODEX=true when --with-codex specified"
    - "Build passes --build-arg WITH_GEMINI=true when --with-gemini specified"
    - "Version change for codex or gemini triggers rebuild"
    - "Adding codex or gemini that wasn't in previous build triggers rebuild"
    - "Build summary shows Codex version when installed"
    - "Build summary shows Gemini version when installed"
  artifacts:
    - path: "src/aishell/docker/build.clj"
      provides: "Build args, version detection, summary for Codex/Gemini"
      contains: "with-codex"
    - path: "src/aishell/state.clj"
      provides: "State schema documentation for new harnesses"
      contains: "codex-version"
  key_links:
    - from: "build.clj"
      to: "templates.clj"
      via: "build-arg names match Dockerfile ARGs"
      pattern: "WITH_CODEX|WITH_GEMINI"
    - from: "build.clj"
      to: "state.clj"
      via: "state keys match opts keys"
      pattern: "with-codex|codex-version"
---

<objective>
Wire Codex and Gemini flags to Docker build execution, state tracking, and version change detection.

Purpose: Complete build integration so `aishell build --with-codex` actually installs Codex
Output: Working build command that installs Codex/Gemini and tracks state correctly
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/24-dockerfile---build-infrastructure/24-RESEARCH.md
@.planning/phases/24-dockerfile---build-infrastructure/24-01-SUMMARY.md

@src/aishell/docker/build.clj
@src/aishell/state.clj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend build-docker-args for Codex and Gemini</name>
  <files>src/aishell/docker/build.clj</files>
  <action>
Extend the build-docker-args function to pass Codex and Gemini build arguments.

1. Update the destructuring in build-docker-args to include new keys:
```clojure
(defn- build-docker-args
  [{:keys [with-claude with-opencode with-codex with-gemini
           claude-version opencode-version codex-version gemini-version]}
   dockerfile-hash]
```

2. Add new build args to the cond-> chain (after opencode-version):
```clojure
with-codex (conj "--build-arg" "WITH_CODEX=true")
with-gemini (conj "--build-arg" "WITH_GEMINI=true")
codex-version (conj "--build-arg" (str "CODEX_VERSION=" codex-version))
gemini-version (conj "--build-arg" (str "GEMINI_VERSION=" gemini-version))
```
  </action>
  <verify>
Run: `grep -A 15 "build-docker-args" src/aishell/docker/build.clj | grep -c "codex\|gemini"`
Should return 4 (two with-* and two *-version args).
  </verify>
  <done>
build-docker-args passes WITH_CODEX, WITH_GEMINI, CODEX_VERSION, GEMINI_VERSION to Docker build when specified.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend version-changed? for Codex and Gemini</name>
  <files>src/aishell/docker/build.clj</files>
  <action>
Extend version-changed? to detect Codex and Gemini version changes.

Add to the `or` expression after the existing OpenCode checks:

```clojure
;; Codex version changed
(and (:with-codex opts)
     (not= (:codex-version opts) (:codex-version state)))
;; Gemini version changed
(and (:with-gemini opts)
     (not= (:gemini-version opts) (:gemini-version state)))
;; Harness added that wasn't in previous build (Codex and Gemini)
(and (:with-codex opts) (not (:with-codex state)))
(and (:with-gemini opts) (not (:with-gemini state)))
```

This ensures rebuild is triggered when:
- Version is different from previous build
- Harness is newly added (wasn't in previous build)
  </action>
  <verify>
Run: `grep -A 20 "defn version-changed?" src/aishell/docker/build.clj | grep -c "codex\|gemini"`
Should return 4 (two version checks and two "added" checks).
  </verify>
  <done>
version-changed? detects when Codex or Gemini version changes or when they are newly added to build.
  </done>
</task>

<task type="auto">
  <name>Task 3: Extend build summary and result for Codex and Gemini</name>
  <files>src/aishell/docker/build.clj</files>
  <action>
Extend build-base-image to display and return Codex/Gemini info.

1. In the success block of build-base-image, add summary output after OpenCode (around line 166-168):
```clojure
(when (:with-codex opts)
  (println (format-harness-line "Codex" (:codex-version opts))))
(when (:with-gemini opts)
  (println (format-harness-line "Gemini" (:gemini-version opts))))
```

2. In the result map returned on success, add new keys (after :opencode-version):
```clojure
:with-codex (:with-codex opts)
:with-gemini (:with-gemini opts)
:codex-version (:codex-version opts)
:gemini-version (:gemini-version opts)
```
  </action>
  <verify>
Run: `grep -A 30 "Built.*format-duration" src/aishell/docker/build.clj | grep -c "codex\|gemini"`
Should return at least 4.
  </verify>
  <done>
Build summary shows "Codex: X.Y.Z" and "Gemini: X.Y.Z" when installed, and result map includes all Codex/Gemini state.
  </done>
</task>

<task type="auto">
  <name>Task 4: Update state schema documentation</name>
  <files>src/aishell/state.clj</files>
  <action>
Update the state schema documentation in write-state docstring to include Codex and Gemini.

Update the schema example in the docstring:
```clojure
(defn write-state
  "Write state to file, creating directory if needed.

   State schema:
   {:with-claude true            ; boolean
    :with-opencode false         ; boolean
    :with-codex false            ; boolean
    :with-gemini false           ; boolean
    :claude-version \"2.0.22\"   ; string or nil
    :opencode-version nil        ; string or nil
    :codex-version \"0.89.0\"    ; string or nil
    :gemini-version nil          ; string or nil
    :image-tag \"aishell:base\"  ; string
    :build-time \"2026-01-20...\" ; ISO-8601 string
    :dockerfile-hash \"abc123def456\"} ; 12-char SHA-256 hash"
  [state]
  ...)
```

This is documentation only - the actual state is a map that accepts any keys.
  </action>
  <verify>
Run: `grep -c "codex-version\|gemini-version" src/aishell/state.clj`
Should return 2 (both in docstring).
  </verify>
  <done>
State schema documentation includes :with-codex, :with-gemini, :codex-version, :gemini-version fields.
  </done>
</task>

</tasks>

<verification>
1. `bb -cp src -e "(require '[aishell.docker.build :as b]) (b/version-changed? {:with-codex true :codex-version \"1.0\"} {:with-codex true :codex-version \"0.9\"})"` returns true
2. `bb -cp src -e "(require '[aishell.docker.build :as b]) (b/version-changed? {:with-gemini true} {})"` returns true (new harness added)
3. `grep "WITH_CODEX=true" src/aishell/docker/build.clj` returns match
4. Full test: `bb aishell.clj build --help` shows --with-codex and --with-gemini options
</verification>

<success_criteria>
- build-docker-args passes correct build args for Codex and Gemini
- version-changed? detects Codex/Gemini version changes
- version-changed? detects newly added Codex/Gemini harnesses
- Build summary displays Codex and Gemini versions when installed
- State schema documentation is complete
- All 7 phase requirements are satisfied (CODEX-01, CODEX-02, GEMINI-01, GEMINI-02, BUILD-01, BUILD-02, BUILD-03)
</success_criteria>

<output>
After completion, create `.planning/phases/24-dockerfile---build-infrastructure/24-02-SUMMARY.md`
</output>
