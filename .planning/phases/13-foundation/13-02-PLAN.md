---
phase: 13-foundation
plan: 02
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - src/aishell/util.clj
  - src/aishell/cli.clj
autonomous: true

must_haves:
  truths:
    - "Path utilities work correctly on Linux"
    - "Path utilities work correctly on macOS"
    - "Home directory is resolved without hardcoding $HOME"
    - "Tilde expansion works in paths"
  artifacts:
    - path: "src/aishell/util.clj"
      provides: "Cross-platform path utilities"
      exports: ["get-home", "expand-path", "config-dir", "state-dir"]
  key_links:
    - from: "src/aishell/util.clj"
      to: "babashka.fs"
      via: "require and use fs/path, fs/home"
      pattern: "fs/path\\|fs/home"
---

<objective>
Implement cross-platform path utilities and verify full CLI functionality.

Purpose: Complete PLAT-03 requirement by providing path utilities that work on both Linux and macOS.
Output: Path utility module that subsequent phases use for config/state file access.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-foundation/13-CONTEXT.md
@.planning/phases/13-foundation/13-RESEARCH.md
@.planning/phases/13-foundation/13-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement path utilities module</name>
  <files>src/aishell/util.clj</files>
  <action>
Create `src/aishell/util.clj` with cross-platform path utilities:

1. Namespace requires:
   - `[babashka.fs :as fs]`
   - `[clojure.string :as str]`

2. Implement `get-home`:
   ```clojure
   (defn get-home
     "Get user home directory (cross-platform).
      Uses babashka.fs/home which handles Linux, macOS, and fallbacks."
     []
     (str (fs/home)))
   ```

3. Implement `expand-path`:
   ```clojure
   (defn expand-path
     "Expand ~ and $HOME in path string.
      Works on both Linux and macOS."
     [path]
     (when path
       (let [home (get-home)]
         (-> path
             (str/replace #"^~(?=/|$)" home)
             (str/replace #"\$HOME(?=/|$)" home)
             (str/replace #"\$\{HOME\}(?=/|$)" home)))))
   ```
   Note: The regex anchors ensure we only replace at path boundaries.

4. Implement `config-dir`:
   ```clojure
   (defn config-dir
     "Get aishell config directory path (~/.aishell)."
     []
     (str (fs/path (get-home) ".aishell")))
   ```

5. Implement `state-dir`:
   ```clojure
   (defn state-dir
     "Get XDG state directory for aishell.
      Respects XDG_STATE_HOME if set, otherwise ~/.local/state/aishell."
     []
     (let [xdg-state (or (System/getenv "XDG_STATE_HOME")
                         (str (fs/path (get-home) ".local" "state")))]
       (str (fs/path xdg-state "aishell"))))
   ```

6. Implement `ensure-dir`:
   ```clojure
   (defn ensure-dir
     "Create directory if it doesn't exist. Returns the path."
     [dir]
     (when-not (fs/exists? dir)
       (fs/create-dirs dir))
     dir)
   ```

7. Implement `project-config-path`:
   ```clojure
   (defn project-config-path
     "Get path to project config file (.aishell/config.yaml) relative to given dir."
     [project-dir]
     (str (fs/path project-dir ".aishell" "config.yaml")))
   ```

Reference: 13-RESEARCH.md Path Utilities section and Pitfall 4, 5.
  </action>
  <verify>
  - `bb -e "(require 'aishell.util) (println (aishell.util/get-home))"` prints home directory
  - `bb -e "(require 'aishell.util) (println (aishell.util/expand-path \"~/test\"))"` prints expanded path
  - `bb -e "(require 'aishell.util) (println (aishell.util/config-dir))"` prints ~/.aishell path
  - `bb -e "(require 'aishell.util) (println (aishell.util/state-dir))"` prints state directory path
  </verify>
  <done>Path utilities work correctly with cross-platform support</done>
</task>

<task type="auto">
  <name>Task 2: Enhance CLI error messages with suggestions</name>
  <files>src/aishell/output.clj, src/aishell/cli.clj</files>
  <action>
Enhance error handling to provide better suggestions:

1. Update `src/aishell/output.clj` - add command suggestion logic:
   ```clojure
   (def known-commands #{"build" "update" "claude" "opencode"})

   (defn- levenshtein-distance
     "Calculate edit distance between two strings (simple implementation)."
     [s1 s2]
     (cond
       (empty? s1) (count s2)
       (empty? s2) (count s1)
       :else
       (let [s1 (vec s1)
             s2 (vec s2)
             n (count s1)
             m (count s2)
             ;; Simple iterative approach
             d (atom (vec (range (inc m))))]
         (doseq [i (range 1 (inc n))]
           (let [prev @d
                 curr (atom [(inc i)])]
             (doseq [j (range 1 (inc m))]
               (let [cost (if (= (s1 (dec i)) (s2 (dec j))) 0 1)]
                 (swap! curr conj
                        (min (inc (prev j))
                             (inc (last @curr))
                             (+ (prev (dec j)) cost)))))
             (reset! d @curr)))
         (last @d))))

   (defn suggest-command
     "Suggest a similar command based on input."
     [input]
     (let [input (str/lower-case input)
           candidates (->> known-commands
                           (map (fn [cmd] [cmd (levenshtein-distance input cmd)]))
                           (filter (fn [[_ dist]] (<= dist 3)))  ;; Max 3 edits
                           (sort-by second))]
       (when (seq candidates)
         (first (first candidates)))))
   ```

2. Update `error-unknown-command` in `output.clj`:
   ```clojure
   (defn error-unknown-command
     "Print error for unknown command with suggestion."
     [cmd]
     (binding [*out* *err*]
       (println (str RED "Error:" NC " Unknown command: " cmd))
       (when-let [suggestion (suggest-command cmd)]
         (println (str "Did you mean: " CYAN suggestion NC "?")))
       (println (str "Try: " CYAN "aishell --help" NC)))
     (System/exit 1))
   ```

3. In `src/aishell/cli.clj`, add error-fn to dispatch for invalid options:
   ```clojure
   (defn handle-error [{:keys [cause option msg]}]
     (case cause
       :restrict
       (do
         (binding [*out* *err*]
           (println (str output/RED "Error:" output/NC " Unknown option: " option))
           (println (str "Try: " output/CYAN "aishell --help" output/NC)))
         (System/exit 1))

       ;; Default
       (output/error msg)))

   (defn dispatch [args]
     (cli/dispatch dispatch-table args {:error-fn handle-error}))
   ```

Reference: 13-RESEARCH.md Pattern 4 and CONTEXT.md error message style decisions.
  </action>
  <verify>
  - `bb -m aishell.core buil` suggests "build"
  - `bb -m aishell.core claud` suggests "claude"
  - `bb -m aishell.core xyz` shows error without suggestion (too different)
  - `bb -m aishell.core --unknown` shows unknown option error
  </verify>
  <done>Error messages include helpful suggestions when possible</done>
</task>

<task type="auto">
  <name>Task 3: Full integration verification</name>
  <files>(none - verification only)</files>
  <action>
Run comprehensive verification of all Phase 13 requirements:

1. CLI-01 (--version):
   - `./aishell.clj --version` -> "aishell 2.0.0"
   - `./aishell.clj -v` -> "aishell 2.0.0"
   - `./aishell.clj --version --json` -> JSON output

2. CLI-02 (--help):
   - `./aishell.clj --help` -> formatted help with commands, options, examples
   - `./aishell.clj -h` -> same as --help
   - Help shows colors when terminal supports it

3. CLI-08 (error messages):
   - `./aishell.clj foo` -> "Unknown command: foo" + suggestion if close match
   - `./aishell.clj buil` -> "Did you mean: build?"
   - `./aishell.clj --badopt` -> "Unknown option" error
   - All errors suggest trying --help

4. PLAT-03 (cross-platform paths):
   - `bb -e "(require 'aishell.util) (println (aishell.util/get-home))"` -> valid path
   - `bb -e "(require 'aishell.util) (println (aishell.util/expand-path \"~/.aishell\"))"` -> expanded
   - Paths use forward slashes (works on both Linux and macOS)

5. No color output when piped:
   - `./aishell.clj --help | cat` -> no ANSI codes
   - `NO_COLOR=1 ./aishell.clj --help` -> no ANSI codes

If any check fails, fix the issue before marking complete.
  </action>
  <verify>
All verification commands from action section pass.
  </verify>
  <done>All Phase 13 requirements (CLI-01, CLI-02, CLI-08, PLAT-03) verified working</done>
</task>

</tasks>

<verification>
Final verification checklist:
```bash
# Requirements coverage
echo "=== CLI-01: --version ==="
./aishell.clj --version
./aishell.clj -v
./aishell.clj --version --json

echo "=== CLI-02: --help ==="
./aishell.clj --help
./aishell.clj -h

echo "=== CLI-08: error messages ==="
./aishell.clj unknowncommand
./aishell.clj buil  # Should suggest "build"
./aishell.clj --badoption

echo "=== PLAT-03: cross-platform paths ==="
bb -e "(require 'aishell.util) (println (aishell.util/get-home))"
bb -e "(require 'aishell.util) (println (aishell.util/expand-path \"~/.config\"))"
bb -e "(require 'aishell.util) (println (aishell.util/config-dir))"

echo "=== Color handling ==="
./aishell.clj --help | head -1  # Should have no ANSI codes when piped
NO_COLOR=1 ./aishell.clj --help | head -1  # Should have no ANSI codes
```
</verification>

<success_criteria>
- src/aishell/util.clj exists with path utilities
- get-home returns user's home directory
- expand-path correctly handles ~, $HOME, ${HOME}
- config-dir returns ~/.aishell
- state-dir respects XDG_STATE_HOME or defaults correctly
- Unknown commands get suggestions when close match exists
- Unknown options get clear error message
- All errors suggest trying --help
- Colors disabled when output piped or NO_COLOR set
- All Phase 13 requirements verified
</success_criteria>

<output>
After completion, create `.planning/phases/13-foundation/13-02-SUMMARY.md`
</output>
