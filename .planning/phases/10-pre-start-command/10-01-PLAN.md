---
phase: 10-pre-start-command
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - aishell
autonomous: true

must_haves:
  truths:
    - "User can specify PRE_START=\"command\" in .aishell/run.conf"
    - "Command executes inside container before main process starts"
    - "Command runs in background without blocking shell/harness startup"
    - "Command output goes to /tmp/pre-start.log"
  artifacts:
    - path: "aishell"
      provides: "PRE_START whitelist, env var passthrough"
      contains: "PRE_START"
    - path: "aishell (write_entrypoint function)"
      provides: "Background execution before exec gosu"
      contains: "sh -c \"$PRE_START\""
  key_links:
    - from: "run.conf PRE_START"
      to: "CONF_PRE_START variable"
      via: "parse_run_conf whitelist"
      pattern: "RUNCONF_ALLOWED_VARS.*PRE_START"
    - from: "main() CONF_PRE_START"
      to: "docker run -e PRE_START"
      via: "docker_args array"
      pattern: "-e \"PRE_START=\\$CONF_PRE_START\""
    - from: "entrypoint.sh PRE_START env"
      to: "background process"
      via: "sh -c with &"
      pattern: "sh -c.*PRE_START.*&"
---

<objective>
Implement PRE_START command support for running background services/sidecars before the main container process.

Purpose: Enable users to start services like Redis, PostgreSQL, or custom daemons inside the container before the shell/harness launches. This completes the v1.1 runtime configuration feature set.

Output: Working PRE_START support where `PRE_START="redis-server --daemonize yes"` in run.conf causes the command to execute in background when the container starts.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-pre-start-command/10-RESEARCH.md
@.planning/phases/09-runtime-config-core/09-01-SUMMARY.md
@.planning/phases/09-runtime-config-core/09-02-SUMMARY.md
@aishell
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend config whitelist and add env passthrough</name>
  <files>aishell</files>
  <action>
Make two changes to aishell:

1. **Extend RUNCONF_ALLOWED_VARS constant** (around line 407):
   - Change: `readonly RUNCONF_ALLOWED_VARS="MOUNTS|ENV|PORTS|DOCKER_ARGS"`
   - To: `readonly RUNCONF_ALLOWED_VARS="MOUNTS|ENV|PORTS|DOCKER_ARGS|PRE_START"`

2. **Initialize CONF_PRE_START in parse_run_conf** (around line 417-420):
   Add to the list of initialized variables:
   ```bash
   declare -g CONF_PRE_START=""
   ```

3. **Add PRE_START env passthrough in main()** (after DOCKER_ARGS handling, around line 1385-1389):
   Add this block after the DOCKER_ARGS section:
   ```bash
   # Pass PRE_START command to container if configured
   if [[ -n "${CONF_PRE_START:-}" ]]; then
       verbose "  PRE_START: $CONF_PRE_START"
       docker_args+=(-e "PRE_START=$CONF_PRE_START")
   fi
   ```

4. **Update usage() to document PRE_START** (around line 840-846):
   Update the Runtime Configuration section to include PRE_START:
   ```
   Runtime Configuration:
       Create .aishell/run.conf to configure container runtime:

       MOUNTS="$HOME/.ssh $HOME/.config/git"    # Additional volume mounts
       ENV="EDITOR DEBUG_MODE=1"                  # Environment variables
       PORTS="3000:3000 8080:80"                  # Port mappings
       DOCKER_ARGS="--cap-add=SYS_PTRACE"         # Extra docker run args
       PRE_START="redis-server --daemonize yes"   # Background command before shell

       See: https://github.com/user/aishell#runtime-configuration
   ```

5. **Update the Allowed variables error message in parse_run_conf** (around line 459):
   Change: `echo "Allowed variables: MOUNTS, ENV, PORTS, DOCKER_ARGS" >&2`
   To: `echo "Allowed variables: MOUNTS, ENV, PORTS, DOCKER_ARGS, PRE_START" >&2`
  </action>
  <verify>
Run: `grep -n "PRE_START" aishell`
Expected: Should show PRE_START in RUNCONF_ALLOWED_VARS, CONF_PRE_START initialization, verbose output, docker_args passthrough, and usage documentation.
  </verify>
  <done>PRE_START is accepted by parse_run_conf and passed to container via -e flag</done>
</task>

<task type="auto">
  <name>Task 2: Add PRE_START execution in entrypoint.sh</name>
  <files>aishell</files>
  <action>
Modify the write_entrypoint() function in aishell (around line 206-276) to add PRE_START execution before the final exec gosu line.

Locate the current ending of entrypoint.sh which is:
```bash
# Add harness bin directories to PATH if they exist
[[ -d /usr/local/bin ]] && export PATH="/usr/local/bin:$PATH"

# Execute command as the user via gosu
exec gosu "$USER_ID:$GROUP_ID" "$@"
```

Change it to:
```bash
# Add harness bin directories to PATH if they exist
[[ -d /usr/local/bin ]] && export PATH="/usr/local/bin:$PATH"

# Execute pre-start command if specified (PRE-01, PRE-02, PRE-03)
if [[ -n "${PRE_START:-}" ]]; then
    # Run in background, redirect all output to log file
    # Using sh -c ensures proper argument handling for complex commands
    sh -c "$PRE_START" > /tmp/pre-start.log 2>&1 &
fi

# Execute command as the user via gosu
exec gosu "$USER_ID:$GROUP_ID" "$@"
```

Note: This code runs BEFORE the exec gosu, so it runs as root. The background process starts, then exec replaces the shell with gosu running as the user. The background process continues running independently.

Important: The PRE_START block must be AFTER the PATH export and BEFORE the exec gosu line. The `sh -c` approach safely handles commands with arguments. Output goes to /tmp/pre-start.log to avoid polluting the terminal.
  </action>
  <verify>
Run: `grep -A3 "PRE_START" aishell | grep -A3 "sh -c"`
Expected: Should show `sh -c "$PRE_START" > /tmp/pre-start.log 2>&1 &`
  </verify>
  <done>PRE_START command executes in background inside container before main process</done>
</task>

<task type="auto">
  <name>Task 3: Manual integration test</name>
  <files>(no files - verification only)</files>
  <action>
Test the PRE_START feature end-to-end:

1. Ensure a build exists (if not, run `./aishell build`)

2. Create test run.conf:
```bash
mkdir -p .aishell
cat > .aishell/run.conf << 'EOF'
PRE_START="echo 'Pre-start executed at:' $(date) && sleep 1 && echo 'Background process running'"
EOF
```

3. Run aishell with verbose to see PRE_START being loaded:
```bash
./aishell -v
```

4. Inside the container, check that:
   - The shell/prompt appeared immediately (not blocked by sleep)
   - Run: `cat /tmp/pre-start.log`
   - Should show: "Pre-start executed at: [date]" and "Background process running"

5. Clean up test config:
```bash
rm .aishell/run.conf
```

If MOUNTS or other config needed for the project, restore the original run.conf.
  </action>
  <verify>
Inside container: `cat /tmp/pre-start.log` shows pre-start output
Outside container: Shell prompt appeared without waiting for sleep
  </verify>
  <done>PRE_START runs in background, output captured, shell not blocked</done>
</task>

</tasks>

<verification>
1. Config parsing: `PRE_START="cmd"` in run.conf sets CONF_PRE_START
2. Env passthrough: `-e PRE_START=cmd` appears in docker run args (check with -v flag)
3. Background execution: Pre-start command runs without blocking shell startup
4. Log capture: Output in /tmp/pre-start.log inside container
5. Help documentation: `./aishell --help` shows PRE_START in Runtime Configuration section
</verification>

<success_criteria>
- PRE-01: PRE_START variable accepted in run.conf (whitelist extended)
- PRE-02: Command executes inside container before shell (entrypoint.sh integration)
- PRE-03: Command runs in background (& operator, output redirected)
- Documentation updated with PRE_START example
- No regression in existing MOUNTS, ENV, PORTS, DOCKER_ARGS functionality
</success_criteria>

<output>
After completion, create `.planning/phases/10-pre-start-command/10-01-SUMMARY.md`
</output>
