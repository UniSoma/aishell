---
phase: 03-harness-integration
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - aishell
  - entrypoint.sh
autonomous: true

must_haves:
  truths:
    - "Running aishell claude starts Claude Code inside container"
    - "Running aishell opencode starts OpenCode inside container"
    - "Running aishell (no args) enters interactive shell"
    - "Host ~/.claude directory is accessible inside container"
    - "Host ~/.config/opencode directory is accessible inside container"
    - "ANTHROPIC_API_KEY from host is available inside container"
  artifacts:
    - path: "aishell"
      provides: "Subcommand parsing, config mounting, env passthrough"
      contains: "case.*claude"
    - path: "entrypoint.sh"
      provides: "Harness command dispatch"
      contains: "claude|opencode"
  key_links:
    - from: "aishell subcommand parsing"
      to: "docker run CMD"
      via: "exec docker run ... $IMAGE_NAME $harness_cmd"
      pattern: 'exec docker run.*"$IMAGE_NAME"'
    - from: "aishell config mounting"
      to: "container filesystem"
      via: "-v $HOME/.claude:$HOME/.claude"
      pattern: '-v.*\.claude'
---

<objective>
Add subcommand parsing, config directory mounting, and environment variable passthrough to aishell

Purpose: Enable users to invoke harnesses via `aishell claude` and `aishell opencode` with their existing configurations and API keys available inside the container.

Output: Modified aishell script with full harness invocation support
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-harness-integration/03-RESEARCH.md
@.planning/phases/03-harness-integration/03-CONTEXT.md
@.planning/phases/03-harness-integration/03-01-SUMMARY.md

# Current implementation
@aishell
@entrypoint.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add config mounting and environment passthrough to aishell</name>
  <files>aishell</files>
  <action>
Add functions for config mounting and API key passthrough. Insert after the `read_git_identity()` function:

1. Add config mount function:
   ```bash
   # --- Harness Config Mounts ---
   build_config_mounts() {
       local -a mounts=()

       # Claude Code configs
       [[ -d "$HOME/.claude" ]] && mounts+=(-v "$HOME/.claude:$HOME/.claude")
       [[ -f "$HOME/.claude.json" ]] && mounts+=(-v "$HOME/.claude.json:$HOME/.claude.json")

       # OpenCode configs
       [[ -d "$HOME/.config/opencode" ]] && mounts+=(-v "$HOME/.config/opencode:$HOME/.config/opencode")

       # OpenCode credentials (auth.json from /connect)
       [[ -d "$HOME/.local/share/opencode" ]] && mounts+=(-v "$HOME/.local/share/opencode:$HOME/.local/share/opencode")

       printf '%s\n' "${mounts[@]}"
   }
   ```

2. Add API key passthrough function:
   ```bash
   # --- API Key Environment Variables ---
   build_api_env() {
       local -a envs=()

       # API keys for various providers (only pass if set, avoid empty override)
       local api_vars=(
           ANTHROPIC_API_KEY
           OPENAI_API_KEY
           GEMINI_API_KEY
           GROQ_API_KEY
           GITHUB_TOKEN
           AWS_ACCESS_KEY_ID
           AWS_SECRET_ACCESS_KEY
           AWS_REGION
           AWS_PROFILE
           AZURE_OPENAI_API_KEY
           AZURE_OPENAI_ENDPOINT
           GOOGLE_CLOUD_PROJECT
           GOOGLE_APPLICATION_CREDENTIALS
       )

       for var in "${api_vars[@]}"; do
           [[ -n "${!var:-}" ]] && envs+=(-e "$var=${!var}")
       done

       # Recommended container settings for Claude Code
       envs+=(-e "DISABLE_AUTOUPDATER=1")

       printf '%s\n' "${envs[@]}"
   }
   ```

Key points:
- Only mount directories/files that exist (avoid Docker mount errors per RESEARCH.md Pitfall 2)
- Only pass env vars that are set (avoid empty override per RESEARCH.md Pitfall 4)
- DISABLE_AUTOUPDATER=1 always set (per RESEARCH.md, ephemeral containers)
  </action>
  <verify>
Source the script and test functions:
```bash
cd /home/jonasrodrigues/projects/harness
bash -n aishell  # Syntax check
# Test config mounts (will show mounts if dirs exist)
bash -c 'source <(grep -A20 "build_config_mounts()" aishell); build_config_mounts'
```
  </verify>
  <done>
aishell contains build_config_mounts() and build_api_env() functions that conditionally build mount and environment arguments.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add subcommand parsing and build arg support to aishell</name>
  <files>aishell</files>
  <action>
Refactor argument parsing to support subcommands and build flags. Major changes:

1. Update usage() to reflect subcommand interface:
   ```bash
   usage() {
       cat << EOF
   Usage: aishell [OPTIONS] [COMMAND] [ARGS...]

   Launch an ephemeral container with the current directory mounted.

   Commands:
       claude      Run Claude Code (requires --with-claude at build)
       opencode    Run OpenCode (requires --with-opencode at build)
       update      Rebuild image with latest harness versions
       (none)      Enter interactive shell (default)

   Options:
       --with-claude       Include Claude Code in image (build-time)
       --with-opencode     Include OpenCode in image (build-time)
       -v, --verbose       Show detailed output
       -h, --help          Show this help message
       --version           Show version

   Examples:
       aishell                     # Enter shell
       aishell claude              # Run Claude Code
       aishell opencode            # Run OpenCode
       aishell --with-claude       # Rebuild with Claude Code, then shell

   EOF
   }
   ```

2. Add build flag variables after VERSION:
   ```bash
   WITH_CLAUDE=false
   WITH_OPENCODE=false
   HARNESS_CMD=""
   HARNESS_ARGS=()
   ```

3. Refactor parse_args() to handle subcommands:
   ```bash
   parse_args() {
       while [[ $# -gt 0 ]]; do
           case $1 in
               --with-claude)
                   WITH_CLAUDE=true
                   shift
                   ;;
               --with-opencode)
                   WITH_OPENCODE=true
                   shift
                   ;;
               -v|--verbose)
                   VERBOSE=true
                   shift
                   ;;
               -h|--help)
                   usage
                   exit 0
                   ;;
               --version)
                   echo "aishell $VERSION"
                   exit 0
                   ;;
               claude|opencode)
                   HARNESS_CMD="$1"
                   shift
                   HARNESS_ARGS=("$@")
                   break
                   ;;
               update)
                   HARNESS_CMD="update"
                   shift
                   break
                   ;;
               -*)
                   error "Unknown option: $1"
                   ;;
               *)
                   # Unknown positional - treat as command to run in shell
                   HARNESS_CMD="exec"
                   HARNESS_ARGS=("$1" "${@:2}")
                   break
                   ;;
           esac
       done
   }
   ```

4. Modify ensure_image() to use build args:
   ```bash
   ensure_image() {
       local needs_build=false
       local -a build_args=()

       # Check if image exists
       if ! docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
           needs_build=true
       fi

       # Check if build flags request harnesses not in current image
       # (For now, rebuild if any --with-* flag passed)
       if [[ "$WITH_CLAUDE" == true ]] || [[ "$WITH_OPENCODE" == true ]]; then
           needs_build=true
       fi

       if [[ "$needs_build" == true ]]; then
           verbose "Building image..."
           start_spinner "Building image"

           local script_dir
           script_dir="$(dirname "$(readlink -f "$0")")"

           [[ "$WITH_CLAUDE" == true ]] && build_args+=(--build-arg WITH_CLAUDE=true)
           [[ "$WITH_OPENCODE" == true ]] && build_args+=(--build-arg WITH_OPENCODE=true)

           if ! docker build "${build_args[@]}" -t "$IMAGE_NAME" "$script_dir" >/dev/null 2>&1; then
               stop_spinner
               error "Failed to build image"
           fi

           stop_spinner
           verbose "Image built successfully"
       fi
   }
   ```
  </action>
  <verify>
Test argument parsing:
```bash
cd /home/jonasrodrigues/projects/harness
bash -n aishell  # Syntax check
./aishell --help  # Should show new usage
./aishell --version  # Should show version
```
  </verify>
  <done>
aishell supports subcommands (claude, opencode, update) and build flags (--with-claude, --with-opencode).
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement subcommand dispatch in main()</name>
  <files>aishell, entrypoint.sh</files>
  <action>
1. Refactor main() to dispatch based on HARNESS_CMD:
   ```bash
   main() {
       parse_args "$@"

       # Handle update command before docker checks
       if [[ "$HARNESS_CMD" == "update" ]]; then
           do_update
           exit 0
       fi

       check_docker
       ensure_image

       local project_dir
       project_dir="$(pwd)"

       # Read git identity from host
       local identity git_name git_email
       identity=$(read_git_identity "$project_dir")
       git_name=$(echo "$identity" | head -1)
       git_email=$(echo "$identity" | tail -1)

       if [[ -z "$git_name" ]] || [[ -z "$git_email" ]]; then
           warn "Git identity not found on host"
       fi

       verbose "Launching container..."
       verbose "  Project: $project_dir"
       verbose "  UID/GID: $(id -u):$(id -g)"
       if [[ -n "$git_name" ]] && [[ -n "$git_email" ]]; then
           verbose "  Git identity: $git_name <$git_email>"
       fi
       [[ -n "$HARNESS_CMD" ]] && verbose "  Command: $HARNESS_CMD ${HARNESS_ARGS[*]}"

       # Build docker run arguments
       local -a docker_args=(
           --rm -it
           -v "$project_dir:$project_dir"
           -w "$project_dir"
           -e "LOCAL_UID=$(id -u)"
           -e "LOCAL_GID=$(id -g)"
           -e "TERM=${TERM:-xterm-256color}"
       )

       # Add git identity env vars
       if [[ -n "$git_name" ]] && [[ -n "$git_email" ]]; then
           docker_args+=(
               -e "GIT_AUTHOR_NAME=$git_name"
               -e "GIT_AUTHOR_EMAIL=$git_email"
               -e "GIT_COMMITTER_NAME=$git_name"
               -e "GIT_COMMITTER_EMAIL=$git_email"
           )
       fi

       # Add config mounts (using mapfile for robustness)
       local config_mounts
       config_mounts=$(build_config_mounts)
       if [[ -n "$config_mounts" ]]; then
           while IFS= read -r mount; do
               [[ -n "$mount" ]] && docker_args+=($mount)
           done <<< "$config_mounts"
       fi

       # Add API environment variables
       local api_envs
       api_envs=$(build_api_env)
       if [[ -n "$api_envs" ]]; then
           while IFS= read -r env; do
               [[ -n "$env" ]] && docker_args+=($env)
           done <<< "$api_envs"
       fi

       # Dispatch based on command
       case "$HARNESS_CMD" in
           claude)
               exec docker run "${docker_args[@]}" "$IMAGE_NAME" claude "${HARNESS_ARGS[@]}"
               ;;
           opencode)
               exec docker run "${docker_args[@]}" "$IMAGE_NAME" opencode "${HARNESS_ARGS[@]}"
               ;;
           exec)
               exec docker run "${docker_args[@]}" "$IMAGE_NAME" "${HARNESS_ARGS[@]}"
               ;;
           *)
               exec docker run "${docker_args[@]}" "$IMAGE_NAME" /bin/bash
               ;;
       esac
   }
   ```

2. Add do_update() function before main():
   ```bash
   # --- Update Command ---
   do_update() {
       check_docker

       verbose "Rebuilding image with latest harness versions..."
       start_spinner "Updating image"

       local script_dir
       script_dir="$(dirname "$(readlink -f "$0")")"

       # Force rebuild with no cache for harness layers
       local -a build_args=(--no-cache)
       [[ "$WITH_CLAUDE" == true ]] && build_args+=(--build-arg WITH_CLAUDE=true)
       [[ "$WITH_OPENCODE" == true ]] && build_args+=(--build-arg WITH_OPENCODE=true)

       if ! docker build "${build_args[@]}" -t "$IMAGE_NAME" "$script_dir" >/dev/null 2>&1; then
           stop_spinner
           error "Failed to update image"
       fi

       stop_spinner
       echo "Image updated successfully"
   }
   ```

3. Update entrypoint.sh to handle harness commands properly (ensure PATH includes harness bins):
   Add before the exec gosu line:
   ```bash
   # Add harness bin directories to PATH if they exist
   [[ -d /root/.claude/bin ]] && export PATH="/root/.claude/bin:$PATH"
   [[ -d /root/.opencode/bin ]] && export PATH="/root/.opencode/bin:$PATH"
   ```

Key points:
- Harness commands pass through to container with all remaining args
- Config mounts and API env vars added to all invocations (shell and harness)
- Update command forces rebuild with --no-cache
- PATH extended in entrypoint for harness discovery
  </action>
  <verify>
Test full flow:
```bash
cd /home/jonasrodrigues/projects/harness
bash -n aishell  # Syntax check
bash -n entrypoint.sh  # Syntax check
./aishell --help  # Verify help shows commands
```
  </verify>
  <done>
aishell dispatches subcommands correctly. main() builds docker args with config mounts and API env vars, then dispatches to appropriate command. do_update() rebuilds image with --no-cache.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Syntax validation:
   ```bash
   bash -n aishell
   bash -n entrypoint.sh
   ```

2. Help displays subcommands:
   ```bash
   ./aishell --help
   ```

3. Config mount function works:
   ```bash
   # Create test directories if needed
   mkdir -p ~/.claude ~/.config/opencode
   ./aishell -v  # Should show config mounts in verbose output
   ```

4. Shell mode still works:
   ```bash
   ./aishell  # Should enter shell
   ```
</verification>

<success_criteria>
- aishell --help shows claude, opencode, update subcommands
- aishell (no args) enters interactive shell
- aishell claude passes 'claude' as CMD to container
- aishell opencode passes 'opencode' as CMD to container
- Config directories mounted when they exist on host
- API key environment variables passed when set on host
- DISABLE_AUTOUPDATER=1 always passed to container
- aishell update rebuilds image with --no-cache
- Requirements HARNESS-01, HARNESS-02, HARNESS-03, HARNESS-04, HARNESS-05 satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/03-harness-integration/03-02-SUMMARY.md`
</output>
