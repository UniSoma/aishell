---
phase: 18-distribution
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/aishell/core.clj
  - src/aishell/cli.clj
  - scripts/build-release.sh
autonomous: true

must_haves:
  truths:
    - "Version moved from core.clj to cli.clj (breaks artificial circular dependency)"
    - "core.clj uses static require for cli (no dynamic require hack)"
    - "Build script creates single-file uberscript from source"
    - "Uberscript bundles ALL namespaces (not just core)"
    - "Uberscript executes directly with shebang (./dist/aishell, not bb dist/aishell)"
    - "Checksum file is generated alongside uberscript"
  artifacts:
    - path: "src/aishell/core.clj"
      provides: "Clean entry point with static requires"
      min_lines: 10
    - path: "scripts/build-release.sh"
      provides: "Uberscript build automation"
      min_lines: 20
  key_links:
    - from: "scripts/build-release.sh"
      to: "src/aishell/core.clj"
      via: "bb uberscript command"
      pattern: "bb uberscript.*-m aishell.core"
    - from: "src/aishell/core.clj"
      to: "src/aishell/cli.clj"
      via: "static require"
      pattern: ":require.*aishell.cli"
---

<objective>
Refactor to eliminate circular dependency and create build script for uberscript packaging.

Purpose: Enable reproducible release builds that produce distributable artifacts for GitHub Releases.
Output: Refactored core.clj/cli.clj and `scripts/build-release.sh` that generates `dist/aishell` and `dist/aishell.sha256`

PROBLEM: core.clj uses dynamic require for cli.clj to avoid circular dependency.
This breaks uberscript bundling (only static top-level requires are detected).

ROOT CAUSE: Version functions are in core.clj, but cli.clj needs them.
So: core → cli (dispatch) → core (version) = cycle

SOLUTION: Move version to cli.clj. Then core can statically require cli. No cycle.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-distribution/18-CONTEXT.md
@.planning/phases/18-distribution/18-RESEARCH.md

@src/aishell/core.clj
@src/aishell/cli.clj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Move version from core.clj to cli.clj</name>
  <files>src/aishell/cli.clj</files>
  <action>
    Add version definition and print functions to cli.clj:

    1. Add at the top of cli.clj (after the ns form):
       ```clojure
       (def version "2.0.0")

       (defn print-version []
         (println (str "aishell " version)))

       (defn print-version-json []
         (println (str "{\"name\":\"aishell\",\"version\":\"" version "\"}")))
       ```

    2. Update the existing references in cli.clj:
       - Change `core/print-version` to `print-version`
       - Change `core/print-version-json` to `print-version-json`

    3. Remove `[aishell.core :as core]` from cli.clj's require (no longer needed)

    This breaks the circular dependency: cli.clj no longer needs core.clj.
  </action>
  <verify>
    grep -q "def version" src/aishell/cli.clj
    grep -q "defn print-version" src/aishell/cli.clj
    ! grep -q "aishell.core" src/aishell/cli.clj
  </verify>
  <done>
    cli.clj contains version and print functions, no longer requires core
  </done>
</task>

<task type="auto">
  <name>Task 2: Simplify core.clj with static require</name>
  <files>src/aishell/core.clj</files>
  <action>
    Rewrite core.clj to use static require (now possible since cli doesn't need core):

    ```clojure
    (ns aishell.core
      (:require [aishell.cli :as cli]
                [aishell.output :as output]))

    (defn -main [& args]
      (try
        (cli/dispatch args)
        (catch clojure.lang.ExceptionInfo e
          (output/error (ex-message e)))
        (catch Exception e
          (output/error (str "Unexpected error: " (.getMessage e))))))

    (when (= *file* (System/getProperty "babashka.file"))
      (apply -main *command-line-args*))
    ```

    Key changes:
    - Static `(:require [aishell.cli :as cli])` at top level
    - Remove dynamic `(require '[aishell.cli :as cli])` from -main
    - Remove `(resolve 'aishell.cli/dispatch)` - just call `cli/dispatch` directly
    - Remove version, print-version, print-version-json (moved to cli.clj)

    This enables uberscript to detect and bundle all namespaces.
  </action>
  <verify>
    grep -q ":require.*aishell.cli" src/aishell/core.clj
    ! grep -q "require '\[aishell.cli" src/aishell/core.clj
    ! grep -q "def version" src/aishell/core.clj
  </verify>
  <done>
    core.clj uses static require for cli, no dynamic require hack
  </done>
</task>

<task type="auto">
  <name>Task 3: Create build-release.sh script</name>
  <files>scripts/build-release.sh</files>
  <action>
    Create `scripts/build-release.sh` that:

    1. Create dist/ directory
    2. Run `bb uberscript dist/aishell -m aishell.core`
    3. Add shebang `#!/usr/bin/env bb` as first line using sed
    4. Make executable with chmod +x
    5. Generate checksum file dist/aishell.sha256
       - Use sha256sum on Linux, shasum -a 256 on macOS
       - Format: `{hash}  aishell` (two spaces, relative filename)
    6. Print success message with checksum

    Script requirements:
    - Use `set -euo pipefail` for safety
    - Support both Linux (sha256sum) and macOS (shasum -a 256)
    - Use sed -i on Linux, sed -i '' on macOS (detect platform)

    Note: Version is now in src/aishell/cli.clj - update it there before release builds.
    Reference RESEARCH.md Pattern 1 for implementation.
  </action>
  <verify>
    Run: ./scripts/build-release.sh
    Then: ./dist/aishell --version (should show "aishell 2.0.0")
    Then: file dist/aishell (should show "ASCII text executable")
    Then: cat dist/aishell.sha256 (should show hash)
  </verify>
  <done>
    Build script exists at scripts/build-release.sh, runs successfully, produces:
    - dist/aishell (executable uberscript with ALL namespaces bundled)
    - dist/aishell.sha256 (checksum file)
  </done>
</task>

<task type="auto">
  <name>Task 4: Verify uberscript execution</name>
  <files>dist/aishell</files>
  <action>
    Test the generated uberscript (Docker is NOT available in this environment):

    1. Run `./dist/aishell --version` - should show "aishell 2.0.0"
    2. Run `./dist/aishell --help` - should show help text listing available commands
    3. Verify shebang is present: `head -1 dist/aishell` should show `#!/usr/bin/env bb`
    4. Verify ALL namespaces are bundled: `grep -c "^(ns aishell" dist/aishell` should show 15+
    5. Verify checksum matches:
       - Calculate: sha256sum dist/aishell | awk '{print $1}'
       - Compare with: awk '{print $1}' dist/aishell.sha256
       - Must match

    If any test fails, debug and rebuild.

    Note: Skip testing subcommands (build, shell, claude, opencode) as they require Docker.
    The --version and --help tests verify the uberscript loads and executes correctly.
  </action>
  <verify>
    ./dist/aishell --version outputs "aishell 2.0.0"
    ./dist/aishell --help outputs help text without errors
    All 15+ namespaces are bundled in uberscript
    Checksum verification passes
  </verify>
  <done>
    Uberscript executes correctly:
    - --version shows correct version
    - --help works
    - All namespaces bundled
    - Checksum file is accurate
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. cli.clj contains version and print-version functions
2. cli.clj does NOT require aishell.core
3. core.clj uses static require for cli (no dynamic require)
4. scripts/build-release.sh exists and is executable
5. Running build-release.sh produces dist/aishell and dist/aishell.sha256
6. dist/aishell is directly executable (./dist/aishell, not bb dist/aishell)
7. All 15+ namespaces are bundled in the uberscript
8. Checksum file matches actual file hash
</verification>

<success_criteria>
- Circular dependency eliminated (cli no longer requires core)
- core.clj uses static requires (no dynamic require hack)
- Build script creates reproducible uberscript artifacts
- Uberscript bundles ALL namespaces (not just core and output)
- Uberscript executes --version and --help without classpath issues
- Checksum generation works on both Linux and macOS
</success_criteria>

<output>
After completion, create `.planning/phases/18-distribution/18-01-SUMMARY.md`
</output>
