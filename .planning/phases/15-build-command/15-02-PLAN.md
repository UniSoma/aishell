---
phase: 15-build-command
plan: 02
type: execute
wave: 2
depends_on: ["15-01"]
files_modified:
  - src/aishell/cli.clj
  - src/aishell/docker/build.clj
autonomous: true

must_haves:
  truths:
    - "User can run ./aishell build and see image building"
    - "User can run ./aishell build --with-claude and Claude is included"
    - "User can run ./aishell build --with-claude=1.0.0 to pin version"
    - "Build flags are persisted in ~/.aishell/state.edn"
    - "Invalid version formats are rejected before build starts"
    - "Build with no flags clears previous state"
  artifacts:
    - path: "src/aishell/cli.clj"
      provides: "Build subcommand dispatch"
      contains: "handle-build"
    - path: "src/aishell/docker/build.clj"
      provides: "Enhanced build output with harness versions"
      contains: "harness-summary"
  key_links:
    - from: "src/aishell/cli.clj"
      to: "src/aishell/docker/build.clj"
      via: "build/build-base-image call"
      pattern: "build/build-base-image"
    - from: "src/aishell/cli.clj"
      to: "src/aishell/state.clj"
      via: "state/write-state call"
      pattern: "state/write-state"
---

<objective>
Wire the build subcommand with flag parsing, version validation, and state persistence.

Purpose: This is the main user-facing build command. Users run `aishell build --with-claude=1.0.0` to build images with pinned harness versions. State is persisted for subsequent commands.

Output: Working `aishell build` command with flag parsing, validation, and state persistence.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/15-build-command/15-RESEARCH.md
@.planning/phases/15-build-command/15-CONTEXT.md
@.planning/phases/15-build-command/15-01-SUMMARY.md
@src/aishell/cli.clj
@src/aishell/docker/build.clj
@src/aishell/state.clj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add build subcommand to cli.clj</name>
  <files>src/aishell/cli.clj</files>
  <action>
Update `src/aishell/cli.clj` to add build subcommand:

1. Add requires at top:
   - `[aishell.docker.build :as build]`
   - `[aishell.state :as state]`
   - `[clojure.string :as str]`

2. Add version validation constants and functions:

```clojure
(def semver-pattern
  #"^\d+\.\d+\.\d+(-[a-zA-Z0-9.-]+)?(\+[a-zA-Z0-9.-]+)?$")

(def dangerous-chars #"[;&|`$(){}\[\]<>!\\]")

(defn validate-version
  "Validate version string. Returns nil on success, exits with error on failure."
  [version harness-name]
  (when (and version (not= version "true") (not= version "latest"))
    (cond
      (re-find dangerous-chars version)
      (output/error (str "Invalid " harness-name " version: contains shell metacharacters"))

      (not (re-matches semver-pattern version))
      (output/error (str "Invalid " harness-name " version format: " version
                        "\nExpected: X.Y.Z or X.Y.Z-prerelease (e.g., 2.0.22, 1.0.0-beta.1)")))))
```

3. Add flag parsing helper:

```clojure
(defn parse-with-flag
  "Parse --with-X flag value.
   nil -> {:enabled? false}
   'true' -> {:enabled? true} (flag without value)
   'latest' -> {:enabled? true}
   version -> {:enabled? true :version version}"
  [value]
  (cond
    (nil? value) {:enabled? false}
    (= value "true") {:enabled? true}
    (= value "latest") {:enabled? true}
    :else {:enabled? true :version value}))
```

4. Add build-spec:

```clojure
(def build-spec
  {:with-claude   {:coerce :string :desc "Include Claude Code (optional: =VERSION)"}
   :with-opencode {:coerce :string :desc "Include OpenCode (optional: =VERSION)"}
   :verbose       {:alias :v :coerce :boolean :desc "Show full Docker build output"}
   :help          {:alias :h :coerce :boolean :desc "Show build help"}})
```

5. Add print-build-help:

```clojure
(defn print-build-help []
  (println (str output/BOLD "Usage:" output/NC " aishell build [OPTIONS]"))
  (println)
  (println "Build the container image with optional harness installations.")
  (println)
  (println (str output/BOLD "Options:" output/NC))
  (println (cli/format-opts {:spec build-spec
                             :order [:with-claude :with-opencode :verbose :help]}))
  (println)
  (println (str output/BOLD "Examples:" output/NC))
  (println (str "  " output/CYAN "aishell build" output/NC "                      Build base image"))
  (println (str "  " output/CYAN "aishell build --with-claude" output/NC "        Include Claude Code (latest)"))
  (println (str "  " output/CYAN "aishell build --with-claude=2.0.22" output/NC " Pin Claude Code version"))
  (println (str "  " output/CYAN "aishell build --with-claude --with-opencode" output/NC " Include both")))
```

6. Add handle-build function:

```clojure
(defn handle-build [{:keys [opts]}]
  (if (:help opts)
    (print-build-help)
    (let [;; Parse flags
          claude-config (parse-with-flag (:with-claude opts))
          opencode-config (parse-with-flag (:with-opencode opts))

          ;; Validate versions before build
          _ (validate-version (:version claude-config) "Claude Code")
          _ (validate-version (:version opencode-config) "OpenCode")

          ;; Show replacement message if image exists
          _ (when (docker/image-exists? build/base-image-tag)
              (println "Replacing existing image..."))

          ;; Build with explicit force (no aishell caching per CONTEXT.md)
          result (build/build-base-image
                   {:with-claude (:enabled? claude-config)
                    :with-opencode (:enabled? opencode-config)
                    :claude-version (:version claude-config)
                    :opencode-version (:version opencode-config)
                    :verbose (:verbose opts)
                    :force true})]

      ;; Persist state (always, even on failure this won't run due to error exit)
      (state/write-state
        {:with-claude (:enabled? claude-config)
         :with-opencode (:enabled? opencode-config)
         :claude-version (:version claude-config)
         :opencode-version (:version opencode-config)
         :image-tag (:image result)
         :build-time (java.time.Instant/now)}))))
```

7. Update dispatch-table to include build:

```clojure
(def dispatch-table
  [{:cmds ["build"] :fn handle-build :spec build-spec :restrict true}
   {:cmds [] :spec global-spec :fn handle-default}])
```

Note: `:restrict true` on build entry ensures unknown options are caught.
  </action>
  <verify>
```bash
cd /home/jonasrodrigues/projects/harness

# Test help
./aishell build --help

# Test version validation (should error)
./aishell build --with-claude="not-semver" 2>&1 | grep -q "Invalid"

# Test dangerous chars (should error)
./aishell build --with-claude="\$(whoami)" 2>&1 | grep -q "Invalid"
```
  </verify>
  <done>
- `aishell build --help` shows build-specific help
- `aishell build --with-claude=invalid` exits with validation error
- Version strings with shell metacharacters are rejected
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance build output with harness versions</name>
  <files>src/aishell/docker/build.clj</files>
  <action>
Update `src/aishell/docker/build.clj` to show harness versions in success output:

1. Update `build-base-image` to include options in return value:

Change the success return from:
```clojure
{:success true :image base-image-tag}
```

To include more detail for the CLI to use:
```clojure
{:success true
 :image base-image-tag
 :duration duration
 :size size
 :with-claude (:with-claude opts)
 :with-opencode (:with-opencode opts)
 :claude-version (:claude-version opts)
 :opencode-version (:opencode-version opts)}
```

2. Update the success output formatting to show harness versions:

Replace the current success println:
```clojure
(println (str "Built " base-image-tag
              " (" (format-duration duration)
              (when size (str ", " size)) ")"))
```

With enhanced output that shows harnesses:
```clojure
(defn- format-harness-line [name version]
  (str "  " name ": " (or version "latest")))

;; In build-base-image, after successful build:
(when-not quiet
  (println (str "Built " base-image-tag
                " (" (format-duration duration)
                (when size (str ", " size)) ")"))
  (when (:with-claude opts)
    (println (format-harness-line "Claude Code" (:claude-version opts))))
  (when (:with-opencode opts)
    (println (format-harness-line "OpenCode" (:opencode-version opts)))))
```

This produces output like:
```
Built aishell:base (45.2s, 1.2GB)
  Claude Code: 2.0.22
  OpenCode: latest
```
  </action>
  <verify>
```bash
cd /home/jonasrodrigues/projects/harness

# Build with Claude and check output shows version line
./aishell build --with-claude 2>&1 | grep -q "Claude Code"
```
  </verify>
  <done>
- Build success output shows "Claude Code: VERSION" when --with-claude used
- Build success output shows "OpenCode: VERSION" when --with-opencode used
- Versions show "latest" when no version pinned
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify state persistence end-to-end</name>
  <files>src/aishell/cli.clj</files>
  <action>
This is a verification task - no code changes, just confirm the wiring works.

Run through the complete flow:

1. Clean state: `rm -f ~/.aishell/state.edn`

2. Build with flags: `./aishell build --with-claude=2.0.22`

3. Check state persisted:
   ```bash
   cat ~/.aishell/state.edn
   ```
   Should show `{:with-claude true :claude-version "2.0.22" ...}`

4. Build without flags: `./aishell build`

5. Check state cleared:
   ```bash
   cat ~/.aishell/state.edn
   ```
   Should show `{:with-claude false :with-opencode false ...}`

If any step fails, debug and fix the issue in cli.clj.
  </action>
  <verify>
```bash
cd /home/jonasrodrigues/projects/harness

# Full flow test
rm -f ~/.aishell/state.edn
./aishell build --with-claude=2.0.22
grep -q ":with-claude true" ~/.aishell/state.edn && echo "State persisted OK"
grep -q ":claude-version \"2.0.22\"" ~/.aishell/state.edn && echo "Version persisted OK"

# Clear test
./aishell build
grep -q ":with-claude false" ~/.aishell/state.edn && echo "State cleared OK"
```
  </verify>
  <done>
- State persists with correct values after build with flags
- State clears (with-claude false) after build without flags
- Version strings persist correctly
  </done>
</task>

</tasks>

<verification>
```bash
cd /home/jonasrodrigues/projects/harness

# 1. Help works
./aishell build --help | grep -q "Build the container image"

# 2. Basic build works
./aishell build

# 3. Build with Claude works
./aishell build --with-claude

# 4. Version pinning works
./aishell build --with-claude=2.0.22

# 5. State persisted
cat ~/.aishell/state.edn | grep -q "with-claude"

# 6. Validation rejects invalid
./aishell build --with-claude="invalid" 2>&1 | grep -q "Invalid"

# 7. Unknown options rejected
./aishell build --unknown 2>&1 | grep -q "Unknown option"
```
</verification>

<success_criteria>
- `aishell build` builds base image with spinner
- `aishell build --with-claude` includes Claude Code (latest)
- `aishell build --with-claude=2.0.22` pins specific version
- `aishell build --with-opencode` includes OpenCode
- Invalid version formats rejected before build starts
- Shell metacharacters in versions rejected
- State persisted to ~/.aishell/state.edn after build
- Build without flags clears previous state
- Build success shows harness versions when included
- Unknown options show clear error
</success_criteria>

<output>
After completion, create `.planning/phases/15-build-command/15-02-SUMMARY.md`
</output>
