---
phase: 42-resurrect-state-persistence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/aishell/config.clj
  - src/aishell/docker/run.clj
autonomous: true

must_haves:
  truths:
    - "resurrect: true in config.yaml is parsed as {:enabled true :restore_processes false}"
    - "resurrect: {restore_processes: true} is parsed as {:enabled true :restore_processes true}"
    - "resurrect: {enabled: false} returns nil (disabled)"
    - "resurrect state directory is mounted from host when resurrect enabled and tmux active"
    - "resurrect config silently ignored when tmux not enabled"
  artifacts:
    - path: "src/aishell/config.clj"
      provides: "parse-resurrect-config function and validation"
      contains: "parse-resurrect-config"
    - path: "src/aishell/docker/run.clj"
      provides: "Resurrect state directory volume mount"
      contains: "resurrect"
  key_links:
    - from: "src/aishell/config.clj"
      to: "src/aishell/docker/run.clj"
      via: "Parsed resurrect config flows through config map to run args builder"
      pattern: "resurrect"
---

<objective>
Parse tmux.resurrect config and mount resurrect state directory from host into container.

Purpose: Enable the config layer and docker run layer to understand and act on resurrect settings, providing the foundation for session persistence.
Output: Config parsing for resurrect (boolean sugar + map form), host directory mount for state persistence.
</objective>

<execution_context>
@/home/jonasrodrigues/.claude/get-shit-done/workflows/execute-plan.md
@/home/jonasrodrigues/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/42-resurrect-state-persistence/42-CONTEXT.md
@.planning/phases/42-resurrect-state-persistence/42-RESEARCH.md
@.planning/phases/41-tpm-initialization-in-entrypoint/41-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Parse resurrect config in config.clj</name>
  <files>src/aishell/config.clj</files>
  <action>
Add a `parse-resurrect-config` function that handles the boolean sugar and map form:

```clojure
(defn parse-resurrect-config
  "Parse tmux.resurrect config: boolean sugar or map with options.
   - true -> {:enabled true :restore_processes false}
   - false -> nil
   - {:restore_processes true} -> {:enabled true :restore_processes true}
   - {:enabled false} -> nil
   - {:enabled false :restore_processes true} -> nil (enabled wins)
   Returns normalized map or nil if disabled/invalid."
  [resurrect-value]
  (cond
    (true? resurrect-value)
    {:enabled true :restore_processes false}

    (false? resurrect-value)
    nil

    (map? resurrect-value)
    (let [enabled? (get resurrect-value :enabled true)
          restore-processes? (get resurrect-value :restore_processes false)]
      (when enabled?
        {:enabled true :restore_processes (boolean restore-processes?)}))

    :else
    (do (output/warn (str "Invalid tmux.resurrect value: expected boolean or map, got "
                          (type resurrect-value)))
        nil)))
```

Update `validate-tmux-config` to also validate the `:resurrect` key if present. The resurrect key accepts boolean or map — warn if it's neither. No need to validate deeply since `parse-resurrect-config` handles normalization.

Add validation in `validate-tmux-config` after the plugins validation block:
```clojure
(when-let [resurrect (:resurrect tmux-config)]
  (when-not (or (boolean? resurrect) (map? resurrect))
    (output/warn (str "Invalid tmux.resurrect in " source-path
                      ": expected boolean or map, got " (type resurrect)
                      "\nExamples:\n  tmux:\n    resurrect: true\n  or:\n  tmux:\n    resurrect:\n      restore_processes: true"))))
```

The merge strategy for tmux is already scalar (project replaces global) since `:tmux` is in the `scalar-keys` set in `merge-configs`. This means resurrect config from the project config replaces the global — which is correct behavior.
  </action>
  <verify>
Run `bb -e '(require (quote [aishell.config :as c])) (println (c/parse-resurrect-config true)) (println (c/parse-resurrect-config false)) (println (c/parse-resurrect-config {:restore_processes true})) (println (c/parse-resurrect-config {:enabled false}))'` from the project root. Expected output:
- `{:enabled true, :restore_processes false}`
- `nil`
- `{:enabled true, :restore_processes true}`
- `nil`

Also verify syntax: `bb -e '(require (quote [aishell.config]))'` exits without error.
  </verify>
  <done>parse-resurrect-config handles all 4 config shapes (true, false, map-enabled, map-disabled) and validate-tmux-config warns on invalid resurrect types.</done>
</task>

<task type="auto">
  <name>Task 2: Mount resurrect state directory in docker run</name>
  <files>src/aishell/docker/run.clj</files>
  <action>
Add a `build-resurrect-mount` function that mounts the host resurrect state directory into the container when resurrect is enabled and tmux is active.

The function needs:
1. Check state has `:with-tmux` true
2. Parse resurrect config from the config map using `parse-resurrect-config` (require aishell.config)
3. If resurrect enabled: compute host path `~/.aishell/resurrect/{project-hash}/`
4. Ensure parent directory exists on host (`mkdir -p`)
5. Return volume mount args: `["-v" "{host-path}:/home/developer/.tmux/resurrect"]`
6. If resurrect not enabled or tmux not active: return `[]`

The project hash is available from `aishell.docker.naming/project-hash`. Add require for `aishell.docker.naming` and `aishell.config` to the ns declaration.

```clojure
(defn- build-resurrect-mount
  "Build mount args for resurrect state directory if enabled.
   Mounts host ~/.aishell/resurrect/{project-hash}/ into container
   at ~/.tmux/resurrect/ for tmux-resurrect state persistence.
   Creates host directory if it doesn't exist."
  [state config project-dir]
  (if (and (get state :with-tmux)
           (when-let [resurrect-val (get-in config [:tmux :resurrect])]
             (:enabled (cfg/parse-resurrect-config resurrect-val))))
    (let [home (util/get-home)
          hash (naming/project-hash project-dir)
          host-dir (str home "/.aishell/resurrect/" hash)
          container-home (str home "/.tmux/resurrect")]
      ;; Ensure host directory exists
      (fs/create-dirs host-dir)
      ["-v" (str host-dir ":" container-home)])
    []))
```

In `build-docker-args-internal`, add the resurrect mount after the tmux config mount line (after `(into (build-tmux-config-mount state config))`):

```clojure
;; Resurrect state directory mount (persistent tmux session state)
(into (build-resurrect-mount state config project-dir))
```

The `project-dir` is already available in `build-docker-args-internal` via the destructured params. Verify it's in the destructuring — it is (`:project-dir` is destructured at line 237).

Also add `:project-dir` to the keys passed through in `build-docker-args` and `build-docker-args-for-exec` — it's already there since both pass `:project-dir` to `build-docker-args-internal`.

Add requires to ns declaration:
- `[aishell.docker.naming :as naming]`
- `[aishell.config :as cfg]`

Note: `babashka.fs` is already required as `fs`.
  </action>
  <verify>
Verify syntax: `bb -e '(require (quote [aishell.docker.run]))'` exits without error.

Grep for the resurrect mount in the output: `grep -n "resurrect" src/aishell/docker/run.clj` should show the new function and its usage.
  </verify>
  <done>When tmux.resurrect is enabled in config and --with-tmux is set, the resurrect state directory (~/.aishell/resurrect/{project-hash}/) is mounted into the container at ~/.tmux/resurrect/. When tmux is not enabled, resurrect config is silently ignored.</done>
</task>

</tasks>

<verification>
1. `bb -e '(require (quote [aishell.config :as c])) (println (c/parse-resurrect-config true))'` returns `{:enabled true, :restore_processes false}`
2. `bb -e '(require (quote [aishell.docker.run]))'` loads without error
3. `grep -c "resurrect" src/aishell/docker/run.clj` returns at least 5 (function + usage + comments)
</verification>

<success_criteria>
- parse-resurrect-config correctly handles: true, false, map with enabled, map without enabled, map with enabled:false
- validate-tmux-config warns on invalid resurrect types
- Resurrect state directory mount added to docker run args when both tmux and resurrect are enabled
- Mount silently skipped when tmux disabled (regardless of resurrect config)
- Host resurrect directory auto-created on first use
</success_criteria>

<output>
After completion, create `.planning/phases/42-resurrect-state-persistence/42-01-SUMMARY.md`
</output>
