---
phase: 42-resurrect-state-persistence
plan: 02
type: execute
wave: 2
depends_on: ["42-01"]
files_modified:
  - src/aishell/docker/volume.clj
  - src/aishell/cli.clj
  - src/aishell/docker/templates.clj
autonomous: true

must_haves:
  truths:
    - "tmux-resurrect plugin is auto-added to plugin list when resurrect is enabled"
    - "Duplicate tmux-resurrect plugin entries are silently deduplicated"
    - "Process restoration is disabled by default in tmux config"
    - "Process restoration uses :all: mode when restore_processes is true"
    - "Auto-restore runs on tmux start if resurrect state exists"
    - "Session state persists across container restarts when resurrect configured"
  artifacts:
    - path: "src/aishell/docker/volume.clj"
      provides: "Resurrect plugin auto-injection in volume population"
      contains: "tmux-resurrect"
    - path: "src/aishell/cli.clj"
      provides: "Resurrect plugin auto-injection in build command"
      contains: "resurrect"
    - path: "src/aishell/docker/templates.clj"
      provides: "Resurrect config injection and auto-restore in entrypoint"
      contains: "resurrect"
  key_links:
    - from: "src/aishell/cli.clj"
      to: "src/aishell/docker/volume.clj"
      via: "Plugin list with auto-added resurrect flows to volume population"
      pattern: "tmux-resurrect"
    - from: "src/aishell/docker/templates.clj"
      to: "tmux-resurrect plugin"
      via: "Entrypoint injects resurrect config and auto-restore run-shell"
      pattern: "resurrect"
---

<objective>
Auto-inject tmux-resurrect plugin and configure resurrect behavior in the entrypoint.

Purpose: Complete the resurrect feature by ensuring the plugin is installed, configured with correct settings (process restoration off/on), and auto-restores on container start.
Output: Plugin auto-injection in build pipeline, resurrect config injection in entrypoint, auto-restore via run-shell.
</objective>

<execution_context>
@/home/jonasrodrigues/.claude/get-shit-done/workflows/execute-plan.md
@/home/jonasrodrigues/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/42-resurrect-state-persistence/42-CONTEXT.md
@.planning/phases/42-resurrect-state-persistence/42-RESEARCH.md
@.planning/phases/42-resurrect-state-persistence/42-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Auto-inject tmux-resurrect plugin in build pipeline</name>
  <files>src/aishell/cli.clj, src/aishell/docker/volume.clj</files>
  <action>
When resurrect is enabled, `tmux-plugins/tmux-resurrect` must be auto-added to the plugin list so TPM installs it into the volume. This must happen in two places: the build command (cli.clj) and the lazy volume population path (run.clj via volume.clj).

**In cli.clj** (around line 189 where tmux-plugins is extracted):

Currently:
```clojure
:tmux-plugins (when with-tmux
                (get-in cfg [:tmux :plugins]))
```

Change to auto-inject resurrect plugin when resurrect is enabled:
```clojure
:tmux-plugins (when with-tmux
                (let [plugins (vec (or (get-in cfg [:tmux :plugins]) []))
                      resurrect-val (get-in cfg [:tmux :resurrect])
                      resurrect-cfg (cfg/parse-resurrect-config resurrect-val)
                      needs-resurrect? (:enabled resurrect-cfg)
                      has-resurrect? (some #(= % "tmux-plugins/tmux-resurrect") plugins)]
                  (if (and needs-resurrect? (not has-resurrect?))
                    (conj plugins "tmux-plugins/tmux-resurrect")
                    plugins)))
```

The `cfg` alias for `aishell.config` is already required in cli.clj's ns (check â€” it uses `config/load-config`, so the require is `[aishell.config :as config]`). Use `config/parse-resurrect-config` instead of `cfg/`.

Also need to pass the resurrect config to state so the entrypoint can read it. Add to `state-map`:
```clojure
:resurrect-config (when with-tmux
                    (config/parse-resurrect-config (get-in cfg [:tmux :resurrect])))
```

**In run.clj `ensure-harness-volume`** (lazy population path):

The lazy volume population in `run.clj` calls `vol/populate-volume` which already receives `{:config config}`. The plugin list is extracted inside `populate-volume` via `(get-in opts [:config :tmux :plugins])`. We need to ensure the auto-injection also happens here.

Add a helper function in volume.clj:
```clojure
(defn inject-resurrect-plugin
  "Auto-add tmux-resurrect to plugin list when resurrect is enabled.
   Deduplicates if user already declared it."
  [plugins resurrect-enabled?]
  (if (and resurrect-enabled?
           (not (some #(= % "tmux-plugins/tmux-resurrect") plugins)))
    (conj (vec plugins) "tmux-plugins/tmux-resurrect")
    (vec (or plugins []))))
```

Update `populate-volume` to use this helper. In the `let` binding where `tmux-plugins` is computed (around line 325-326):

Currently:
```clojure
tmux-plugins (when (:with-tmux state)
               (get-in opts [:config :tmux :plugins]))
```

Change to:
```clojure
tmux-plugins (when (:with-tmux state)
               (let [plugins (get-in opts [:config :tmux :plugins])
                     resurrect-val (get-in opts [:config :tmux :resurrect])
                     resurrect-enabled? (when resurrect-val
                                          (:enabled ((requiring-resolve 'aishell.config/parse-resurrect-config) resurrect-val)))]
                 (inject-resurrect-plugin plugins resurrect-enabled?)))
```

Use `requiring-resolve` to avoid circular dependency (volume.clj should not require config.clj directly). Alternatively, since the resurrect check is simple (boolean or map with :enabled), duplicate the minimal check inline:

```clojure
tmux-plugins (when (:with-tmux state)
               (let [plugins (get-in opts [:config :tmux :plugins])
                     resurrect-val (get-in opts [:config :tmux :resurrect])
                     resurrect-enabled? (cond
                                          (true? resurrect-val) true
                                          (map? resurrect-val) (get resurrect-val :enabled true)
                                          :else false)]
                 (inject-resurrect-plugin plugins resurrect-enabled?)))
```

This avoids the circular dependency issue entirely. The inline check mirrors parse-resurrect-config logic for just the enabled? boolean.
  </action>
  <verify>
Verify syntax: `bb -e '(require (quote [aishell.cli]))' && bb -e '(require (quote [aishell.docker.volume]))'` both exit without error.

Verify inject-resurrect-plugin works: `bb -e '(require (quote [aishell.docker.volume :as v])) (println (v/inject-resurrect-plugin ["tmux-plugins/tmux-sensible"] true)) (println (v/inject-resurrect-plugin ["tmux-plugins/tmux-resurrect"] true)) (println (v/inject-resurrect-plugin nil false))'`
Expected:
- `["tmux-plugins/tmux-sensible" "tmux-plugins/tmux-resurrect"]`
- `["tmux-plugins/tmux-resurrect"]` (no duplicate)
- `[]`
  </verify>
  <done>tmux-resurrect is auto-added to plugin list when resurrect enabled in config. Deduplication prevents double entries. Both build path (cli.clj) and lazy population path (volume.clj) handle auto-injection.</done>
</task>

<task type="auto">
  <name>Task 2: Inject resurrect config and auto-restore in entrypoint</name>
  <files>src/aishell/docker/templates.clj, src/aishell/docker/run.clj</files>
  <action>
The entrypoint needs to inject tmux-resurrect configuration (resurrect-dir, process restoration setting) and the auto-restore run-shell command into the runtime tmux config.

**Step A: Pass resurrect config as environment variables**

In `src/aishell/docker/run.clj`, in `build-docker-args-internal`, after the `WITH_TMUX=true` env var block (line ~284-285), add resurrect env vars when enabled:

```clojure
;; Pass resurrect config to entrypoint for tmux-resurrect configuration
(cond-> (let [resurrect-val (get-in config [:tmux :resurrect])
              resurrect-cfg (when resurrect-val
                              (cfg/parse-resurrect-config resurrect-val))]
          (and (get state :with-tmux) (:enabled resurrect-cfg)))
  (into (cond-> ["-e" "RESURRECT_ENABLED=true"]
          (:restore_processes (cfg/parse-resurrect-config (get-in config [:tmux :resurrect])))
          (into ["-e" "RESURRECT_RESTORE_PROCESSES=true"]))))
```

Simplify by computing once:
```clojure
;; Compute resurrect config once for env var injection
(as-> % args
  (let [resurrect-val (get-in config [:tmux :resurrect])
        resurrect-cfg (when (and (get state :with-tmux) resurrect-val)
                        (cfg/parse-resurrect-config resurrect-val))]
    (if (:enabled resurrect-cfg)
      (cond-> (into args ["-e" "RESURRECT_ENABLED=true"])
        (:restore_processes resurrect-cfg)
        (into ["-e" "RESURRECT_RESTORE_PROCESSES=true"]))
      args)))
```

Actually, keep it simpler and consistent with the existing cond-> threading pattern. Add after the WITH_TMUX block:

After this existing block:
```clojure
;; Pass WITH_TMUX flag to entrypoint for conditional tmux startup
(cond-> (get state :with-tmux)
  (into ["-e" "WITH_TMUX=true"]))
```

Add:
```clojure
;; Pass resurrect config to entrypoint
(into (build-resurrect-env-args state config))
```

And define a helper:
```clojure
(defn- build-resurrect-env-args
  "Build -e flags for resurrect configuration.
   Returns empty vector if resurrect not enabled or tmux not active."
  [state config]
  (if-let [resurrect-val (and (get state :with-tmux)
                               (get-in config [:tmux :resurrect]))]
    (let [resurrect-cfg (cfg/parse-resurrect-config resurrect-val)]
      (if (:enabled resurrect-cfg)
        (cond-> ["-e" "RESURRECT_ENABLED=true"]
          (:restore_processes resurrect-cfg)
          (into ["-e" "RESURRECT_RESTORE_PROCESSES=true"]))
        []))
    []))
```

**Step B: Inject resurrect config in entrypoint script**

In `src/aishell/docker/templates.clj`, in the `entrypoint-script` string, add a new block AFTER the config injection section (after the TPM initialization append block, before the conditional startup block). Insert between the `fi` that closes the config injection block and the `# Conditional startup` comment:

```bash
# Resurrect configuration: inject tmux-resurrect settings into runtime config
if [ \"$WITH_TMUX\" = \"true\" ] && [ \"$RESURRECT_ENABLED\" = \"true\" ]; then
    # Set resurrect save directory (matches volume mount point)
    echo \"\" >> \"$RUNTIME_TMUX_CONF\"
    echo \"# tmux-resurrect configuration (auto-added by aishell)\" >> \"$RUNTIME_TMUX_CONF\"
    echo \"set -g @resurrect-dir '~/.tmux/resurrect'\" >> \"$RUNTIME_TMUX_CONF\"

    # Configure process restoration
    if [ \"$RESURRECT_RESTORE_PROCESSES\" = \"true\" ]; then
        echo \"set -g @resurrect-processes ':all:'\" >> \"$RUNTIME_TMUX_CONF\"
    else
        echo \"set -g @resurrect-processes 'false'\" >> \"$RUNTIME_TMUX_CONF\"
    fi

    # Auto-restore: run resurrect restore script on tmux start
    # This restores the last saved session if state exists, no-ops if no state
    echo \"run-shell '~/.tmux/plugins/tmux-resurrect/scripts/restore.sh r'\" >> \"$RUNTIME_TMUX_CONF\"
fi
```

Important: This block must appear AFTER the TPM initialization block (which writes `run '~/.tmux/plugins/tpm/tpm'`) because resurrect plugin must be loaded by TPM before the restore script runs. The `run-shell` for restore should come after TPM initialization in the config file.

Wait -- actually the order in the config file matters for tmux processing. TPM's `run` line should be BEFORE the resurrect `run-shell` line. Since we append TPM run first and then resurrect run-shell, the order in the file will be correct: TPM loads plugins (including resurrect), then the restore script runs.

Place this new bash block right before the `# Conditional startup` comment in the entrypoint string.
  </action>
  <verify>
Verify syntax: `bb -e '(require (quote [aishell.docker.templates]))'` and `bb -e '(require (quote [aishell.docker.run]))'` both exit without error.

Verify entrypoint contains resurrect block:
`bb -e '(require (quote [aishell.docker.templates :as t])) (println (re-find #"RESURRECT_ENABLED" t/entrypoint-script))'` should print `RESURRECT_ENABLED`.

Verify run.clj passes resurrect env vars:
`grep -n "RESURRECT" src/aishell/docker/run.clj` should show the env var injection lines.
  </verify>
  <done>Entrypoint injects resurrect-dir, process restoration setting, and auto-restore run-shell into runtime tmux config. Process restoration defaults to false, uses :all: when explicitly enabled. Auto-restore runs on tmux start via run-shell script invocation.</done>
</task>

</tasks>

<verification>
1. `bb -e '(require (quote [aishell.docker.volume :as v])) (println (v/inject-resurrect-plugin [] true))'` returns `["tmux-plugins/tmux-resurrect"]`
2. `bb -e '(require (quote [aishell.cli]))'` loads without error
3. `bb -e '(require (quote [aishell.docker.templates :as t])) (println (boolean (re-find #"resurrect-dir" t/entrypoint-script)))'` returns `true`
4. `bb -e '(require (quote [aishell.docker.run]))'` loads without error
5. `grep -c "resurrect" src/aishell/docker/templates.clj` returns at least 5
</verification>

<success_criteria>
- tmux-resurrect auto-added to plugin list when resurrect enabled (both build and lazy paths)
- Duplicate resurrect plugin entries silently deduplicated
- RESURRECT_ENABLED and RESURRECT_RESTORE_PROCESSES env vars passed to container when applicable
- Entrypoint injects @resurrect-dir, @resurrect-processes, and run-shell auto-restore into runtime tmux config
- Process restoration defaults to 'false', uses ':all:' only when restore_processes: true
- Auto-restore script runs after TPM initialization in config file order
- All modules load without syntax errors
</success_criteria>

<output>
After completion, create `.planning/phases/42-resurrect-state-persistence/42-02-SUMMARY.md`
</output>
