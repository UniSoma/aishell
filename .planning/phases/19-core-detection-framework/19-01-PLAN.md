---
phase: 19-core-detection-framework
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/aishell/detection/core.clj
  - src/aishell/detection/formatters.clj
  - src/aishell/cli.clj
  - src/aishell/run.clj
autonomous: true

must_haves:
  truths:
    - "User sees severity level (high/medium/low) alongside each warning"
    - "Warnings appear before container runs when invoking aishell commands"
    - "User can proceed to container despite any warnings (never blocked)"
    - "High-severity warnings require y/n confirmation; medium/low auto-proceed"
    - "User can bypass all warnings with --unsafe flag"
  artifacts:
    - path: "src/aishell/detection/core.clj"
      provides: "Detection framework: scan-project, display-warnings, confirm-if-needed"
      exports: ["scan-project", "display-warnings", "confirm-if-needed"]
    - path: "src/aishell/detection/formatters.clj"
      provides: "Severity-specific terminal output formatting"
      exports: ["format-finding-line", "severity-config"]
    - path: "src/aishell/cli.clj"
      provides: "--unsafe flag parsing and pass-through"
      contains: "--unsafe"
    - path: "src/aishell/run.clj"
      provides: "Detection hook before container execution"
      contains: "detection/scan-project"
  key_links:
    - from: "src/aishell/cli.clj"
      to: "src/aishell/run.clj"
      via: ":unsafe option passed to run-container"
      pattern: "run-container.*:unsafe"
    - from: "src/aishell/run.clj"
      to: "src/aishell/detection/core.clj"
      via: "require and call scan-project"
      pattern: "detection.*scan-project"
    - from: "src/aishell/detection/core.clj"
      to: "src/aishell/detection/formatters.clj"
      via: "require formatters for display"
      pattern: "formatters/format-finding-line"
---

<objective>
Create the core detection framework that warns users about sensitive files with severity tiers (high/medium/low) before container execution.

Purpose: Establish the extensible detection infrastructure that Phases 20-22 will populate with specific patterns. This phase creates the skeleton: scanning, grouping by severity, display formatting, y/n confirmation for high-severity, and --unsafe bypass.

Output: Working detection framework with placeholder patterns that demonstrates the full warning flow (display + confirmation), ready to receive actual detection patterns in subsequent phases.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-core-detection-framework/19-CONTEXT.md
@.planning/phases/19-core-detection-framework/19-RESEARCH.md

@src/aishell/cli.clj
@src/aishell/run.clj
@src/aishell/output.clj
@src/aishell/validation.clj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create detection namespace with formatters and core</name>
  <files>
    src/aishell/detection/formatters.clj
    src/aishell/detection/core.clj
  </files>
  <action>
Create two new files in src/aishell/detection/:

**formatters.clj** - Severity-specific terminal output:
- Define DIM color code (using colors-enabled? pattern from output.clj)
- Define severity-config map: {:high {:label "HIGH" :color RED :bold? true}, :medium {:label "MEDIUM" :color YELLOW}, :low {:label "LOW" :color DIM}}
- format-severity-label fn: returns colored label string
- format-finding-line fn: takes {:severity :path :reason}, returns "  HIGH path - reason" with colors

**core.clj** - Detection framework:
- Define excluded-dirs set: #{".git" "node_modules" "vendor" "target" "build" "dist" "__pycache__" ".venv" "venv" ".bundle"}
- Define severity-order: {:high 0 :medium 1 :low 2}
- scan-project fn: Takes project-dir, returns vector of findings [{:severity :path :reason :type}]. For Phase 19, return empty [] (patterns added in Phase 20+). Include fs/glob with excluded-dirs filtering as infrastructure.
- group-by-severity fn: Groups and sorts findings by severity (high first)
- display-warnings fn: Prints warning block to stderr following validation.clj pattern. Header: "Sensitive files detected in project directory", separator line, grouped findings, footer: "AI tools will have access to these files inside the container."
- interactive? fn: Returns true if System/console is not nil
- prompt-yn fn: Print message, flush, read-line, return true if "y"
- confirm-if-needed fn: If has high-severity AND interactive, prompt y/n. If non-interactive with high-severity, print error requiring --unsafe and exit 1. Medium/low only auto-proceeds.

Follow existing namespace patterns. Use defmulti for format-finding (dispatch on :type) with :default method - this enables extension in later phases.
  </action>
  <verify>
    bb -e "(require '[aishell.detection.core :as d]) (println (d/scan-project \".\"))"
    bb -e "(require '[aishell.detection.formatters :as f]) (println (f/format-severity-label :high))"
  </verify>
  <done>
    - detection/core.clj exists with scan-project, display-warnings, confirm-if-needed
    - detection/formatters.clj exists with format-finding-line, severity-config
    - Both namespaces load without error in bb
  </done>
</task>

<task type="auto">
  <name>Task 2: Add --unsafe flag and hook detection into run flow</name>
  <files>
    src/aishell/cli.clj
    src/aishell/run.clj
  </files>
  <action>
**cli.clj modifications:**

Update the dispatch function to intercept --unsafe before pass-through. IMPORTANT: Handle backward compatibility - the existing callsite at line 189 calls `(run/run-container nil [])` without an opts map. Update ALL callsites:

```clojure
(defn dispatch [args]
  ;; Extract --unsafe flag before pass-through
  (let [unsafe? (some #{"--unsafe"} args)
        clean-args (vec (remove #{"--unsafe"} args))]
    (case (first clean-args)
      "claude" (run/run-container "claude" (vec (rest clean-args)) {:unsafe unsafe?})
      "opencode" (run/run-container "opencode" (vec (rest clean-args)) {:unsafe unsafe?})
      ;; Standard dispatch for other commands (build, update, help, shell)
      (if unsafe?
        ;; --unsafe with shell mode
        (run/run-container nil [] {:unsafe true})
        (cli/dispatch dispatch-table args {:error-fn handle-error :restrict true})))))
```

Also update handle-default to pass empty opts map for shell mode:
```clojure
;; In handle-default, change line 189 from:
;;   (run/run-container nil [])
;; to:
(run/run-container nil [] {})
```

**run.clj modifications:**

1. Add require for detection.core: `[aishell.detection.core :as detection]`

2. Update run-container signature to accept optional opts map with default:
   `(defn run-container [cmd harness-args & [opts]]`
   The `& [opts]` destructuring handles both old calls without opts and new calls with opts.

3. Add detection hook INSIDE the existing let block, AFTER warn-dangerous-mounts (line 106), BEFORE building docker-args (line 109). The hook uses the already-bound `project-dir` variable from line 70:
```clojure
;; Scan for sensitive files (unless --unsafe)
;; Uses project-dir already bound at line 70
_ (when-not (:unsafe opts)
    (let [findings (detection/scan-project project-dir)]
      (when (seq findings)
        (detection/display-warnings findings)
        (detection/confirm-if-needed findings))))
```

This placement ensures:
- Warnings appear after config/validation warnings
- Warnings appear before container starts
- User can abort before docker exec
- Uses existing project-dir binding (no re-computation)
  </action>
  <verify>
    # Verify namespaces load after modifications (catches require/syntax errors):
    bb -e "(require '[aishell.cli :as cli]) (require '[aishell.run :as run]) (println 'OK')"
    # Verify --unsafe is recognized in source:
    grep -n "unsafe" src/aishell/cli.clj src/aishell/run.clj
    # Verify detection require added:
    grep -n "detection" src/aishell/run.clj
  </verify>
  <done>
    - cli.clj extracts --unsafe flag and passes to run-container
    - cli.clj handle-default passes empty opts map (backward compatible)
    - run.clj run-container accepts optional opts map with :unsafe key
    - run.clj calls detection/scan-project when not :unsafe
    - Detection hook placed after warn-dangerous-mounts, before docker-args
    - All callsites updated (no breaking changes)
  </done>
</task>

<task type="auto">
  <name>Task 3: Test end-to-end flow with mock finding</name>
  <files>
    src/aishell/detection/core.clj
  </files>
  <action>
Temporarily modify scan-project to return a mock finding to verify the full flow works:

```clojure
(defn scan-project
  "Scan project directory for sensitive files.
   Returns vector of findings: [{:path :type :severity :reason}]"
  [project-dir]
  ;; TODO: Phase 20+ will add actual pattern matching
  ;; For testing, uncomment this mock finding:
  ;; [{:path ".env.example" :type :env-file :severity :low :reason "Environment template"}]
  [])
```

Test the flow manually:
1. Uncomment the mock finding
2. Run `bb -cp src -m aishell.core` (or however the project runs locally)
3. Verify warning displays with severity label and path
4. Verify pressing 'n' aborts (for high severity mock)
5. Verify --unsafe skips the warning
6. Comment out mock finding, leaving clean scan-project returning []

**Test non-interactive mode behavior:**
7. Test high-severity in non-interactive mode (piped input):
   ```bash
   echo "" | bb -e "(require '[aishell.detection.core :as d]) (d/confirm-if-needed [{:severity :high :path \"test.key\" :reason \"Test\"}])"
   ```
   Should print error requiring --unsafe and exit 1 (non-zero exit code).

8. Test medium-severity in non-interactive mode (should auto-proceed):
   ```bash
   echo "" | bb -e "(require '[aishell.detection.core :as d]) (d/confirm-if-needed [{:severity :medium :path \"test.env\" :reason \"Test\"}]) (println 'proceeded')"
   ```
   Should print "proceeded" without prompting.

Leave a clear TODO comment in scan-project indicating where patterns will be added.
  </action>
  <verify>
    # Verify clean state (empty findings):
    bb -e "(require '[aishell.detection.core :as d]) (assert (empty? (d/scan-project \".\")) \"Should return empty\")"
    # Verify display function works with mock data:
    bb -e "(require '[aishell.detection.core :as d]) (d/display-warnings [{:severity :high :path \"test.key\" :reason \"Test\"}])"
    # Verify non-interactive high-severity exits non-zero:
    echo "" | bb -e "(require '[aishell.detection.core :as d]) (d/confirm-if-needed [{:severity :high :path \"x\" :reason \"y\"}])" 2>&1 || echo "Exit code: $?"
    # Verify non-interactive medium-severity auto-proceeds:
    echo "" | bb -e "(require '[aishell.detection.core :as d]) (d/confirm-if-needed [{:severity :medium :path \"x\" :reason \"y\"}]) (println 'OK')"
  </verify>
  <done>
    - scan-project returns [] by default (clean state for Phase 19)
    - display-warnings correctly formats mock findings
    - confirm-if-needed prompts for high-severity in interactive mode
    - confirm-if-needed exits 1 for high-severity in non-interactive mode (requires --unsafe)
    - confirm-if-needed auto-proceeds for medium/low in any mode
    - Framework is ready for Phase 20 to add actual patterns
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Namespace loading:**
   ```bash
   bb -e "(require '[aishell.detection.core]) (require '[aishell.detection.formatters]) (require '[aishell.cli]) (require '[aishell.run]) (println 'All namespaces OK')"
   ```
   Should complete without error.

2. **Display formatting:**
   ```bash
   bb -e "(require '[aishell.detection.core :as d]) (d/display-warnings [{:severity :high :path \"id_rsa\" :reason \"Private key\"} {:severity :medium :path \".env\" :reason \"Env file\"} {:severity :low :path \".env.example\" :reason \"Template\"}])"
   ```
   Should show grouped output: HIGH first, then MEDIUM, then LOW.

3. **CLI integration:**
   ```bash
   grep -c "unsafe" src/aishell/cli.clj
   grep -c "detection" src/aishell/run.clj
   ```
   Both should return non-zero counts.

4. **Clean scan-project:**
   ```bash
   bb -e "(require '[aishell.detection.core :as d]) (println (d/scan-project \".\"))"
   ```
   Should print `[]`.

5. **Non-interactive high-severity behavior:**
   ```bash
   echo "" | bb -e "(require '[aishell.detection.core :as d]) (d/confirm-if-needed [{:severity :high :path \"x\" :reason \"y\"}])" 2>&1; echo "Exit: $?"
   ```
   Should print error message and "Exit: 1".
</verification>

<success_criteria>
Phase 19 is complete when:
- [ ] detection/core.clj exists with scan-project, display-warnings, confirm-if-needed
- [ ] detection/formatters.clj exists with severity formatting
- [ ] cli.clj parses --unsafe and passes to run-container
- [ ] cli.clj handle-default passes empty opts map (backward compatible)
- [ ] run.clj hooks detection before container execution (uses existing project-dir binding)
- [ ] scan-project returns [] (placeholder for Phase 20 patterns)
- [ ] display-warnings correctly groups by severity (high first)
- [ ] confirm-if-needed prompts for high-severity in interactive mode
- [ ] confirm-if-needed requires --unsafe for high-severity in non-interactive mode (exits 1)
- [ ] confirm-if-needed auto-proceeds for medium/low in any mode
- [ ] All namespaces load without error
</success_criteria>

<output>
After completion, create `.planning/phases/19-core-detection-framework/19-01-SUMMARY.md`
</output>
