---
phase: 28-dynamic-help-config-improvements
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/aishell/config.clj
  - src/aishell/cli.clj
  - src/aishell/state.clj
  - src/aishell/docker/build.clj
  - src/aishell/docker/templates.clj
autonomous: true

must_haves:
  truths:
    - "User defines pre_start as YAML list; commands execute joined by && separator"
    - "User defines pre_start as string; behavior unchanged from v2.4.0"
    - "User runs aishell build --without-gitleaks; resulting image lacks Gitleaks binary"
    - "User checks ~/.aishell/state.edn; sees :with-gitleaks boolean field"
  artifacts:
    - path: "src/aishell/config.clj"
      provides: "normalize-pre-start function"
      contains: "normalize-pre-start"
    - path: "src/aishell/cli.clj"
      provides: "--without-gitleaks flag in build-spec"
      contains: ":without-gitleaks"
    - path: "src/aishell/state.clj"
      provides: "State schema with :with-gitleaks field"
      contains: ":with-gitleaks"
    - path: "src/aishell/docker/templates.clj"
      provides: "Conditional Gitleaks installation in Dockerfile"
      contains: "WITH_GITLEAKS"
    - path: "src/aishell/docker/build.clj"
      provides: "WITH_GITLEAKS build arg propagation"
      contains: "with-gitleaks"
  key_links:
    - from: "src/aishell/cli.clj"
      to: "src/aishell/docker/build.clj"
      via: ":with-gitleaks in opts map"
      pattern: ":with-gitleaks"
    - from: "src/aishell/docker/build.clj"
      to: "src/aishell/docker/templates.clj"
      via: "WITH_GITLEAKS build arg"
      pattern: "WITH_GITLEAKS"
    - from: "src/aishell/config.clj"
      to: "load-yaml-config"
      via: "normalize-pre-start after YAML parse"
      pattern: "normalize-pre-start"
---

<objective>
Implement core Phase 28 infrastructure: pre_start list format support and --without-gitleaks build flag with state tracking.

Purpose: Enable users to write cleaner multi-command pre_start configs using YAML lists, and optionally exclude Gitleaks from builds to reduce image size.

Output: Updated config.clj with list normalization, updated cli.clj/build.clj/templates.clj with gitleaks flag, updated state.clj schema.
</objective>

<execution_context>
@/home/jonasrodrigues/.claude/get-shit-done/workflows/execute-plan.md
@/home/jonasrodrigues/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-dynamic-help-config-improvements/28-RESEARCH.md

@src/aishell/config.clj
@src/aishell/cli.clj
@src/aishell/state.clj
@src/aishell/docker/build.clj
@src/aishell/docker/templates.clj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement pre_start list format normalization</name>
  <files>src/aishell/config.clj</files>
  <action>
Add normalize-pre-start function to config.clj that handles both string and list formats:

```clojure
(defn normalize-pre-start
  "Normalize pre_start: string passes through, list joins with ' && '.
   Filters empty items from lists. Returns string or nil."
  [pre-start-value]
  (cond
    (nil? pre-start-value) nil
    (string? pre-start-value) pre-start-value
    (sequential? pre-start-value)
    (let [filtered (filter (comp not str/blank?) (map str pre-start-value))]
      (when (seq filtered)
        (str/join " && " filtered)))
    :else nil))
```

Modify load-yaml-config to call normalize-pre-start after YAML parsing:
- After validate-config call, add `(update :pre_start normalize-pre-start)`
- Use threading macro to chain the transformations

Key considerations:
- Filter empty strings and blank items to prevent `&& &&` syntax errors
- Convert list items to strings with `(map str ...)` for safety
- Return nil for empty lists (no pre_start command)
- String format passes through unchanged (backwards compatible)
  </action>
  <verify>
1. Create test config with list format:
```yaml
pre_start:
  - "echo 'Step 1'"
  - "echo 'Step 2'"
  - ""
  - "echo 'Step 3'"
```
2. Run `bb -e "(require '[aishell.config :as c]) (println (:pre_start (c/load-config \".\")))"` in a test project
3. Output should be: `echo 'Step 1' && echo 'Step 2' && echo 'Step 3'` (empty item filtered)
4. Test string format still works: `pre_start: "echo hello"` passes through unchanged
  </verify>
  <done>
- normalize-pre-start function exists in config.clj
- YAML list format converts to && -joined string
- Empty list items are filtered out
- String format unchanged (backwards compatible)
- load-yaml-config calls normalize-pre-start
  </done>
</task>

<task type="auto">
  <name>Task 2: Add --without-gitleaks flag to CLI and state</name>
  <files>src/aishell/cli.clj, src/aishell/state.clj</files>
  <action>
**In cli.clj:**

1. Add to build-spec (after :with-gemini):
```clojure
:without-gitleaks {:coerce :boolean :desc "Skip Gitleaks installation"}
```

2. In handle-build, after parsing gemini-config:
```clojure
with-gitleaks (not (:without-gitleaks opts))  ; invert flag for positive tracking
```

3. Pass to build/build-base-image call:
```clojure
:with-gitleaks with-gitleaks
```

4. Add to state/write-state call:
```clojure
:with-gitleaks with-gitleaks
```

5. Update print-build-help to show the new flag (add after --with-gemini line):
```clojure
(println (str "  " output/CYAN "aishell build --without-gitleaks" output/NC "      Skip Gitleaks"))
```

6. Update build-spec order in format-opts to include :without-gitleaks.

**In state.clj:**

Update the docstring for write-state to include the new field:
```clojure
;; Add to schema comment:
;; :with-gitleaks true         ; boolean (whether Gitleaks installed)
```

Key considerations:
- Use --without-gitleaks (opt-out) not --with-gitleaks (opt-in) for backwards compatibility
- Default behavior (no flag) = Gitleaks installed (:with-gitleaks true)
- Flag present = skip Gitleaks (:with-gitleaks false)
  </action>
  <verify>
1. Run `bb src/aishell/main.clj build --help` - should show --without-gitleaks option
2. Check that build-spec includes :without-gitleaks key
3. Verify state schema docstring mentions :with-gitleaks
  </verify>
  <done>
- build-spec has :without-gitleaks flag with :coerce :boolean
- handle-build parses flag and inverts to :with-gitleaks boolean
- :with-gitleaks passed to build-base-image
- :with-gitleaks written to state.edn
- print-build-help shows --without-gitleaks example
- state.clj docstring updated
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement conditional Gitleaks installation in Docker build</name>
  <files>src/aishell/docker/templates.clj, src/aishell/docker/build.clj</files>
  <action>
**In templates.clj (base-dockerfile string):**

1. Add ARG before Gitleaks installation section:
```dockerfile
ARG WITH_GITLEAKS=true
```

2. Wrap Gitleaks RUN command in conditional:
```dockerfile
# Install Gitleaks for secret scanning (conditional)
ARG WITH_GITLEAKS=true
ARG GITLEAKS_VERSION=8.30.0
RUN if [ \"$WITH_GITLEAKS\" = \"true\" ]; then \\
        set -eux; \\
        dpkgArch=\"$(dpkg --print-architecture)\"; \\
        case \"${dpkgArch##*-}\" in \\
            amd64) glArch='x64' ;; \\
            arm64) glArch='arm64' ;; \\
            armhf) glArch='armv7' ;; \\
            *) echo \"unsupported architecture: $dpkgArch\"; exit 1 ;; \\
        esac; \\
        curl -fsSL \"https://github.com/gitleaks/gitleaks/releases/download/v${GITLEAKS_VERSION}/gitleaks_${GITLEAKS_VERSION}_linux_${glArch}.tar.gz\" \\
        | tar -xz -C /usr/local/bin gitleaks; \\
        chmod +x /usr/local/bin/gitleaks; \\
        gitleaks version; \\
    fi
```

**In build.clj:**

1. Update build-docker-args function signature to accept :with-gitleaks:
```clojure
(defn- build-docker-args
  [{:keys [with-claude with-opencode with-codex with-gemini with-gitleaks
           claude-version opencode-version codex-version gemini-version]} dockerfile-hash]
```

2. Add build arg for WITH_GITLEAKS after harness args:
```clojure
;; Gitleaks is opt-out, so we always pass the arg (true or false)
true (conj "--build-arg" (str "WITH_GITLEAKS=" (if with-gitleaks "true" "false")))
```

Key considerations:
- Always pass WITH_GITLEAKS arg explicitly (not just when false) for cache consistency
- Default in Dockerfile is true for backwards compat with existing cached layers
- The conditional RUN produces an empty layer when skipped (minimal overhead)
  </action>
  <verify>
1. Build without flag: `aishell build --with-claude` - Gitleaks should be installed
2. Build with flag: `aishell build --with-claude --without-gitleaks` - Gitleaks should be skipped
3. Verify by running: `docker run --rm aishell:base which gitleaks`
   - Without flag: shows `/usr/local/bin/gitleaks`
   - With --without-gitleaks: exits with error (not found)
4. Check state.edn: `cat ~/.aishell/state.edn | grep with-gitleaks`
  </verify>
  <done>
- templates.clj Dockerfile has WITH_GITLEAKS ARG
- Gitleaks installation is conditional on WITH_GITLEAKS=true
- build.clj passes WITH_GITLEAKS build arg
- Build with --without-gitleaks produces image without Gitleaks
- State file records :with-gitleaks boolean
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Pre-start list format:**
   - Create `.aishell/config.yaml` with list pre_start
   - Run container and check `/tmp/pre-start.log` for correct execution

2. **Gitleaks flag:**
   - `aishell build --with-claude --without-gitleaks`
   - `docker run --rm aishell:base which gitleaks` should fail
   - `cat ~/.aishell/state.edn` should show `:with-gitleaks false`

3. **Backwards compatibility:**
   - `aishell build --with-claude` (no --without-gitleaks)
   - Gitleaks should be installed
   - `:with-gitleaks true` in state.edn
</verification>

<success_criteria>
- [ ] normalize-pre-start function handles string, list, empty list, nil
- [ ] load-yaml-config normalizes pre_start after parsing
- [ ] build-spec includes :without-gitleaks flag
- [ ] handle-build parses and inverts flag to :with-gitleaks
- [ ] build-base-image receives :with-gitleaks option
- [ ] build-docker-args passes WITH_GITLEAKS build arg
- [ ] Dockerfile conditionally installs Gitleaks
- [ ] state.edn includes :with-gitleaks field after build
- [ ] All backwards compatibility maintained
</success_criteria>

<output>
After completion, create `.planning/phases/28-dynamic-help-config-improvements/28-01-SUMMARY.md`
</output>
