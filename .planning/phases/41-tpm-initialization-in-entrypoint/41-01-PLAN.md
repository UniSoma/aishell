---
phase: 41-tpm-initialization-in-entrypoint
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/aishell/docker/templates.clj
  - src/aishell/docker/run.clj
autonomous: true

must_haves:
  truths:
    - "Plugins installed in /tools/tmux/plugins are accessible at ~/.tmux/plugins via symlink"
    - "TPM initialization (run command) is appended to tmux config at container startup"
    - "tmux session starts only when WITH_TMUX=true env var is set"
    - "Shell mode (no tmux) works when WITH_TMUX is not set"
    - "aishell exec commands work identically regardless of tmux state"
  artifacts:
    - path: "src/aishell/docker/templates.clj"
      provides: "Conditional entrypoint with plugin bridging, config injection, and tmux/shell startup"
      contains: "WITH_TMUX"
    - path: "src/aishell/docker/run.clj"
      provides: "WITH_TMUX env var passed to container based on state :with-tmux flag"
      contains: "WITH_TMUX"
  key_links:
    - from: "src/aishell/docker/run.clj"
      to: "entrypoint.sh (in templates.clj)"
      via: "WITH_TMUX env var passed as -e flag in docker run"
      pattern: "WITH_TMUX"
    - from: "entrypoint.sh plugin symlink"
      to: "/tools/tmux/plugins volume (Phase 40)"
      via: "ln -sfn /tools/tmux/plugins ~/.tmux/plugins"
      pattern: "ln -sfn"
    - from: "entrypoint.sh config injection"
      to: "tmux -f runtime config"
      via: "cp ~/.tmux.conf to ~/.tmux.conf.runtime, append TPM run line"
      pattern: "tmux.conf.runtime"
---

<objective>
Add tmux plugin path bridging, config injection, and conditional tmux/shell startup to the entrypoint script. Pass the WITH_TMUX flag from state to the container via docker run environment variable.

Purpose: Bridge the gap between volume-installed plugins (Phase 40) and a working tmux session at runtime. Without this, plugins exist in the volume but tmux cannot find them, and the entrypoint always starts tmux even when the user opted out.

Output: Modified entrypoint-script in templates.clj with three new sections (plugin symlink, config injection, conditional startup) and WITH_TMUX env var in run.clj docker args.
</objective>

<execution_context>
@/home/jonasrodrigues/.claude/get-shit-done/workflows/execute-plan.md
@/home/jonasrodrigues/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/41-tpm-initialization-in-entrypoint/41-RESEARCH.md
@src/aishell/docker/templates.clj
@src/aishell/docker/run.clj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Pass WITH_TMUX env var in docker run args</name>
  <files>src/aishell/docker/run.clj</files>
  <action>
Add a WITH_TMUX environment variable to the docker run arguments when state has :with-tmux true.

In `build-docker-args-internal`, after the tmux config mount line (line ~271 `(into (build-tmux-config-mount state config))`), add:

```clojure
;; Pass WITH_TMUX flag to entrypoint for conditional tmux startup
(cond-> (get state :with-tmux)
  (into ["-e" "WITH_TMUX=true"]))
```

This passes the state flag as an environment variable so the entrypoint can decide whether to start tmux or shell mode. The env var approach is preferred over reading state.edn in bash because:
- state.edn is on host, not mounted into container
- Env var is simpler and more reliable than grep-parsing EDN in bash
- Consistent with existing pattern (PRE_START, TERM, etc. are all env vars)
  </action>
  <verify>
Read run.clj and confirm WITH_TMUX env var is conditionally added based on state :with-tmux flag. Verify it appears after the tmux config mount section.
  </verify>
  <done>WITH_TMUX=true is passed as -e flag in docker run when state has :with-tmux true. Not passed when :with-tmux is false or nil.</done>
</task>

<task type="auto">
  <name>Task 2: Add plugin bridging, config injection, and conditional startup to entrypoint</name>
  <files>src/aishell/docker/templates.clj</files>
  <action>
Modify the `entrypoint-script` string in templates.clj. Replace the hardcoded tmux exec at line 208 and add three new sections after the locale/TERM setup (after the `export LC_ALL=C.UTF-8` line, before the final exec).

**Section 1: Plugin path bridging** (runs only when WITH_TMUX=true)
```bash
# Plugin path bridging: symlink volume plugins to tmux's expected path
if [ "$WITH_TMUX" = "true" ] && [ -d "/tools/tmux/plugins" ]; then
    mkdir -p "$HOME/.tmux"
    ln -sfn /tools/tmux/plugins "$HOME/.tmux/plugins"
    if [ ! -d "$HOME/.tmux/plugins/tpm" ]; then
        echo "Warning: TPM not found at ~/.tmux/plugins/tpm" >&2
    fi
fi
```

Key details:
- `ln -sfn` is idempotent: -f removes existing, -n prevents directory traversal
- Guard with WITH_TMUX check so no tmux code runs in shell mode
- Warning-only if TPM missing (plugins are nice-to-have)

**Section 2: Config injection** (runs only when WITH_TMUX=true)
```bash
# Config injection: copy user's tmux config to writable location, append TPM run
if [ "$WITH_TMUX" = "true" ]; then
    RUNTIME_TMUX_CONF="$HOME/.tmux.conf.runtime"
    TPM_RUN_LINE="run '~/.tmux/plugins/tpm/tpm'"

    if [ -f "$HOME/.tmux.conf" ]; then
        cp "$HOME/.tmux.conf" "$RUNTIME_TMUX_CONF"
        if ! grep -qF "$TPM_RUN_LINE" "$RUNTIME_TMUX_CONF" 2>/dev/null; then
            echo "" >> "$RUNTIME_TMUX_CONF"
            echo "# TPM initialization (auto-added by aishell)" >> "$RUNTIME_TMUX_CONF"
            echo "$TPM_RUN_LINE" >> "$RUNTIME_TMUX_CONF"
        fi
    else
        cat > "$RUNTIME_TMUX_CONF" <<'TMUXEOF'
# Minimal tmux configuration (auto-generated by aishell)
run '~/.tmux/plugins/tpm/tpm'
TMUXEOF
    fi

    export TMUX_PLUGIN_MANAGER_PATH="$HOME/.tmux/plugins"
fi
```

Key details:
- Copies read-only mounted ~/.tmux.conf to ~/.tmux.conf.runtime (writable)
- Appends TPM run command if not already present (grep -qF check)
- Creates minimal config if no user config exists
- Sets TMUX_PLUGIN_MANAGER_PATH env var for plugin discovery
- Use `TMUXEOF` as heredoc delimiter (not `EOF`) to avoid conflicts with bash string escaping in Clojure

**Section 3: Conditional startup** (replaces the hardcoded line 208)
Replace the existing final exec line:
```bash
exec gosu "$USER_ID:$GROUP_ID" tmux new-session -A -s main -c "$PWD" "$@"
```

With conditional startup:
```bash
# Conditional startup: tmux session or direct shell
if [ "$WITH_TMUX" = "true" ]; then
    if ! command -v tmux >/dev/null 2>&1; then
        echo "Error: tmux not found but --with-tmux was specified" >&2
        exit 1
    fi
    exec gosu "$USER_ID:$GROUP_ID" tmux -f "$RUNTIME_TMUX_CONF" new-session -A -s harness -c "$PWD" "$@"
else
    exec gosu "$USER_ID:$GROUP_ID" "$@"
fi
```

Key details:
- Session name changes from "main" to "harness" (design decision from CONTEXT.md)
- `-f "$RUNTIME_TMUX_CONF"` uses the injected config with TPM run line
- Shell mode: direct exec without tmux (preserves original CMD ["/bin/bash"])
- Hard fail if tmux binary missing when user explicitly requested tmux
- gosu preserved in both branches for proper user switching

**Important Clojure string escaping notes:**
- The entrypoint-script is a Clojure string literal (double-quoted)
- Existing patterns in the string use `\\` for bash escapes (e.g., `\\\"` for quotes in bash)
- Heredoc delimiter inside Clojure string: use single quotes in the TPM_RUN_LINE (no escaping needed)
- `$HOME`, `$PWD`, `$@` etc. do NOT need escaping (Clojure strings don't interpolate $)
- Double quotes inside bash need `\\\"` escaping in the Clojure string
- Backslashes in bash need `\\\\` in Clojure string (but there are none needed here)

Also update the comment block above the final exec (lines 203-207) to reflect the new conditional behavior.
  </action>
  <verify>
1. Read templates.clj and verify:
   - Plugin symlink section exists with `ln -sfn` and WITH_TMUX guard
   - Config injection section exists with copy + append + fallback logic
   - Conditional startup replaces hardcoded tmux exec
   - Session name is "harness" (not "main")
   - Shell mode branch uses `exec gosu ... "$@"` without tmux
   - All bash double quotes properly escaped as `\\\"` in Clojure string
2. Run `bb -e '(load-file "src/aishell/docker/templates.clj") (println "OK")'` from project root to verify the Clojure string is syntactically valid.
  </verify>
  <done>
Entrypoint script has three new sections: plugin path bridging (symlink), config injection (copy+append TPM run), and conditional tmux/shell startup. Hardcoded tmux is replaced with WITH_TMUX-guarded conditional. Shell mode execs directly into shell command. Session name is "harness".
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Clojure syntax check**: `bb -e '(load-file "src/aishell/docker/templates.clj") (println "OK")'` prints OK
2. **Entrypoint string inspection**: Print the entrypoint-script and verify bash syntax looks correct:
   ```bash
   bb -e '(load-file "src/aishell/docker/templates.clj") (println aishell.docker.templates/entrypoint-script)' | bash -n
   ```
   This pipes the entrypoint through `bash -n` (syntax check without execution)
3. **WITH_TMUX in run.clj**: Grep for WITH_TMUX in run.clj confirms env var is passed
4. **No hardcoded tmux**: Grep entrypoint-script for `tmux new-session -A -s main` returns no matches (old hardcoded line removed)
5. **Conditional present**: Grep for `WITH_TMUX` in entrypoint-script confirms conditional logic exists
</verification>

<success_criteria>
- Entrypoint conditionally starts tmux (only when WITH_TMUX=true)
- Plugin path symlink bridges /tools/tmux/plugins to ~/.tmux/plugins
- TPM run command appended to runtime copy of user's tmux config
- Shell mode works (direct exec into shell when WITH_TMUX not set)
- Session name is "harness" (not "main")
- Clojure string is syntactically valid (bb can load it)
- Bash script is syntactically valid (bash -n passes)
</success_criteria>

<output>
After completion, create `.planning/phases/41-tpm-initialization-in-entrypoint/41-01-SUMMARY.md`
</output>
