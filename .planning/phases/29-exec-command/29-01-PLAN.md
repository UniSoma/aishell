---
phase: 29-exec-command
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/aishell/docker/run.clj
  - src/aishell/run.clj
  - src/aishell/cli.clj
  - src/aishell/output.clj
autonomous: true

must_haves:
  truths:
    - "User runs `aishell exec ls -la` and sees container directory listing"
    - "User runs `aishell exec` from script (non-TTY) and command executes without TTY error"
    - "User runs `aishell exec` before any build and receives clear error message"
    - "User can pipe input/output: `echo test | aishell exec cat` works correctly"
    - "User's config.yaml mounts and env vars apply to exec command"
  artifacts:
    - path: "src/aishell/docker/run.clj"
      provides: "TTY-conditional docker args via build-docker-args-for-exec"
      contains: "defn build-docker-args-for-exec"
    - path: "src/aishell/run.clj"
      provides: "run-exec function for one-off command execution"
      contains: "defn run-exec"
    - path: "src/aishell/cli.clj"
      provides: "exec command dispatch + handler"
      contains: "handle-exec"
  key_links:
    - from: "src/aishell/cli.clj"
      to: "src/aishell/run.clj"
      via: "handle-exec calls run-exec"
      pattern: "run/run-exec"
    - from: "src/aishell/run.clj"
      to: "src/aishell/docker/run.clj"
      via: "run-exec calls build-docker-args-for-exec"
      pattern: "docker-run/build-docker-args-for-exec"
---

<objective>
Implement the `aishell exec <command>` subcommand for running one-off commands in containers.

Purpose: Enable users to run single commands in the container without entering an interactive shell, supporting both terminal and piped/scripted usage.

Output: Working `aishell exec` command with TTY auto-detection, proper exit code propagation, and build state verification.
</objective>

<execution_context>
@/home/jonasrodrigues/.claude/get-shit-done/workflows/execute-plan.md
@/home/jonasrodrigues/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-exec-command/29-RESEARCH.md

# Source files to modify
@src/aishell/cli.clj
@src/aishell/run.clj
@src/aishell/docker/run.clj
@src/aishell/output.clj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add TTY-conditional docker args builder</name>
  <files>src/aishell/docker/run.clj</files>
  <action>
Create a new function `build-docker-args-for-exec` that builds docker args for one-off execution.

Key differences from `build-docker-args`:
1. Accept `:tty?` parameter to control TTY allocation
2. When `tty?` is true: use `["-it"]` flags (interactive + TTY)
3. When `tty?` is false: use `["-i"]` flag only (interactive, no TTY - allows piping)
4. Skip pre_start hooks entirely (one-off commands shouldn't start sidecars)
5. Include all other standard behavior: mounts, env, ports, API keys, git identity

Implementation approach:
- Refactor to share common arg building logic with existing `build-docker-args`
- Extract shared parts into a private helper function
- Keep `build-docker-args` unchanged (always uses `-it` for backward compat)
- New function uses conditional TTY based on parameter

Pattern from research:
```clojure
(defn build-docker-args-for-exec
  [{:keys [project-dir image-tag config git-identity tty?]}]
  (let [tty-flags (if tty? ["-it"] ["-i"])]  ; -i always for stdin
    ;; ... same logic as build-docker-args minus pre_start
    ))
```

IMPORTANT: Always include `-i` flag even when not allocating TTY. Without `-i`, stdin is not connected and piped input fails silently.
  </action>
  <verify>
Read the modified file and confirm:
1. `build-docker-args-for-exec` function exists
2. Function accepts `:tty?` parameter
3. Uses `["-it"]` when tty? is true, `["-i"]` when false
4. Does NOT include PRE_START env var handling
5. Includes all other args (mounts, env, ports, git identity, etc.)
  </verify>
  <done>
New function `build-docker-args-for-exec` exists that conditionally allocates TTY based on parameter, always includes `-i` for stdin, and excludes pre_start hooks.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add run-exec function</name>
  <files>src/aishell/run.clj</files>
  <action>
Create a new function `run-exec` that handles one-off command execution.

Key differences from `run-container`:
1. Takes a command vector (the user's command to execute)
2. Auto-detects TTY using `(some? (System/console))`
3. Skips sensitive file detection (fast path for quick commands)
4. Skips gitleaks freshness warnings (not relevant for exec)
5. Skips pre_start hooks (handled by not passing to docker args)
6. Uses `p/shell` with `:inherit true :continue true` (not p/exec)
7. Propagates exit code via `(System/exit (:exit result))`

Function signature:
```clojure
(defn run-exec
  "Run one-off command in container.

   Arguments:
   - cmd-args: Vector of command + arguments (e.g., [\"ls\" \"-la\"])

   Auto-detects TTY. Uses all standard mounts/env from config."
  [cmd-args]
  ...)
```

Implementation flow:
1. Check Docker available
2. Read state, verify build exists (error-no-build if not)
3. Verify image exists (clear error if missing)
4. Resolve image tag (handle project extensions)
5. Load config for mounts/env
6. Read git identity
7. Auto-detect TTY: `(some? (System/console))`
8. Build docker args with `build-docker-args-for-exec`
9. Execute with `p/shell {:inherit true :continue true}`
10. Exit with command's exit code

Skip these (compared to run-container):
- Harness verification (no harness, just raw command)
- Sensitive file detection (--unsafe by design for exec)
- Gitleaks freshness warnings
- Pre-start hooks
  </action>
  <verify>
Read the modified file and confirm:
1. `run-exec` function exists with correct docstring
2. Calls `docker/check-docker!`
3. Reads state and calls `output/error-no-build` if missing
4. Uses `(some? (System/console))` for TTY detection
5. Calls `docker-run/build-docker-args-for-exec` with `:tty?` parameter
6. Uses `p/shell` with `:inherit true :continue true`
7. Calls `(System/exit (:exit result))` to propagate exit code
8. Does NOT call detection functions or gitleaks-warnings
  </verify>
  <done>
New function `run-exec` exists that runs one-off commands with TTY auto-detection, exit code propagation, and skips detection/warnings for fast execution.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add exec command to CLI dispatch</name>
  <files>src/aishell/cli.clj, src/aishell/output.clj</files>
  <action>
Add the `exec` subcommand to the CLI:

**In cli.clj:**

1. Add `exec` to the case statement in `dispatch` function (before standard dispatch):
```clojure
"exec" (run/run-exec (vec (rest clean-args)))
```

2. Update `print-help` to show exec command:
```clojure
(println (str "  " output/CYAN "exec" output/NC "      Run one-off command in container"))
```
Place after harness commands, before `(none)` entry.

3. Add `exec` to command suggestions in output.clj `known-commands` set (already has build, update, claude, etc.)

**In output.clj:**

1. Update `known-commands` set to include "exec":
```clojure
(def known-commands #{"build" "update" "exec" "claude" "opencode" "codex" "gemini" "gitleaks"})
```

**Help text example:**
```
Commands:
  build      Build the container image
  update     Rebuild with latest versions
  exec       Run one-off command in container
  claude     Run Claude Code
  ...
```

Note: exec is NOT conditional on build state (unlike harness commands). It's always shown because:
1. It provides value even without harnesses
2. Error message when no build is clear enough
3. Aids discoverability
  </action>
  <verify>
Run these commands and confirm behavior:
1. `cd /home/jonasrodrigues/projects/harness && bb -m aishell.core --help` shows "exec" in commands
2. `bb -m aishell.core exce 2>&1` suggests "exec" (typo correction works)
3. Code inspection: `dispatch` function has "exec" case before standard dispatch
  </verify>
  <done>
- `aishell exec <command>` dispatches to `run/run-exec`
- Help shows exec command with description
- Typo correction suggests "exec" for similar inputs
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Basic execution:**
```bash
cd /tmp && mkdir -p test-exec && cd test-exec
# Assuming aishell is built
aishell exec echo "hello from container"
# Should print: hello from container
```

2. **Exit code propagation:**
```bash
aishell exec false; echo "Exit code: $?"
# Should print: Exit code: 1
```

3. **No build error:**
```bash
cd /tmp/fresh-dir-no-build
aishell exec ls
# Should print: Error: No image built. Run: aishell build
```

4. **Piping (if TTY detection works):**
```bash
echo "hello" | aishell exec cat
# Should print: hello (only works if -t not forced when stdin is pipe)
```

5. **Help output:**
```bash
aishell --help
# Should show: exec       Run one-off command in container
```
</verification>

<success_criteria>
1. `aishell exec <command>` runs command in container and exits
2. Exit code from container command propagates to host
3. Clear error when no build exists
4. TTY auto-detected (works in terminal AND in scripts/pipes)
5. Config mounts/env apply (same as interactive mode)
6. exec visible in help output
7. Typo suggestions work for "exec"
</success_criteria>

<output>
After completion, create `.planning/phases/29-exec-command/29-01-SUMMARY.md`
</output>
