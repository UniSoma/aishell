---
phase: 14-docker-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/aishell/docker.clj
autonomous: true

must_haves:
  truths:
    - "Docker availability check returns true when daemon is running"
    - "Docker availability check returns false when daemon unavailable"
    - "User sees 'Docker not running' error message on unavailable daemon"
    - "Image existence check returns true for existing images"
    - "Image existence check returns false for missing images"
  artifacts:
    - path: "src/aishell/docker.clj"
      provides: "Docker wrapper module with availability and image checks"
      exports: ["docker-available?", "docker-running?", "check-docker!", "image-exists?", "get-image-label"]
  key_links:
    - from: "src/aishell/docker.clj"
      to: "babashka.process"
      via: "shell with :continue true"
      pattern: "p/shell.*:continue true"
    - from: "src/aishell/docker.clj"
      to: "babashka.fs"
      via: "fs/which for Docker binary detection"
      pattern: "fs/which.*docker"
---

<objective>
Create Docker wrapper module with availability checks and image inspection utilities

Purpose: Provide foundation for all Docker operations - other plans depend on these primitives to check Docker state before building or running
Output: src/aishell/docker.clj with docker-available?, docker-running?, check-docker!, image-exists?, get-image-label functions
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/14-docker-integration/14-CONTEXT.md
@.planning/phases/14-docker-integration/14-RESEARCH.md

# Existing modules
@src/aishell/core.clj
@src/aishell/output.clj
@src/aishell/util.clj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Docker wrapper module with availability checks</name>
  <files>src/aishell/docker.clj</files>
  <action>
Create src/aishell/docker.clj with:

1. Namespace declaration requiring:
   - babashka.process :as p
   - babashka.fs :as fs
   - clojure.string :as str
   - aishell.output :as output

2. Functions (in order):

docker-available? []
- Use (fs/which "docker") to check if docker binary exists in PATH
- Return (some? result)

docker-running? []
- Run: (p/shell {:out :string :err :string :continue true} "docker" "info")
- Return (zero? (:exit result))
- Wrap in try/catch, return false on exception

check-docker! []
- Check docker-available? first -> (output/error "Docker is not installed")
- Check docker-running? second -> (output/error "Docker not running")
- Returns nil if both pass (no error exit)

image-exists? [image-tag]
- Run: (p/shell {:out :string :err :string :continue true} "docker" "image" "inspect" image-tag)
- Return (zero? (:exit result))

get-image-label [image label-key]
- Run docker inspect with Go template: --format={{index .Config.Labels "label-key"}}
- Use (str "--format={{index .Config.Labels \"" label-key "\"}}") for proper escaping
- Return trimmed value or nil if empty/"<no value>"/error
- Wrap in try/catch, return nil on exception

Follow the patterns from 14-RESEARCH.md exactly for subprocess handling.
  </action>
  <verify>
Run from project root:
```bash
cd /home/jonasrodrigues/projects/harness && bb -e "(require '[aishell.docker :as d]) (println 'loaded) (println (d/docker-available?)) (println (d/docker-running?))"
```
Should print: loaded, true (if docker installed), true/false (depending on daemon state)
  </verify>
  <done>
- docker.clj loads without errors
- docker-available? returns boolean based on docker binary presence
- docker-running? returns boolean based on daemon state
- check-docker! exits with colored error if docker unavailable
- image-exists? correctly detects existing/missing images
- get-image-label retrieves labels from images
  </done>
</task>

<task type="auto">
  <name>Task 2: Add image size formatting utility</name>
  <files>src/aishell/docker.clj</files>
  <action>
Add to docker.clj:

format-size [bytes]
- Handle bytes as long (use parse-long if needed)
- Return human-readable format:
  - < 1024: "{bytes}B"
  - < 1024*1024: "{kb:.1f}KB"
  - < 1024*1024*1024: "{mb:.1f}MB"
  - else: "{gb:.2f}GB"
- Use (format "%.1fMB" (/ bytes 1024.0 1024.0)) pattern

get-image-size [image-tag]
- Run: docker image inspect --format={{.Size}} image-tag
- Parse result with parse-long
- Return formatted string via format-size
- Return nil on error
  </action>
  <verify>
```bash
cd /home/jonasrodrigues/projects/harness && bb -e "(require '[aishell.docker :as d]) (println (d/format-size 1500000000))"
```
Should print something like "1.40GB" (or similar formatted value)
  </verify>
  <done>
- format-size returns human-readable sizes for various byte values
- get-image-size retrieves and formats image size from Docker
  </done>
</task>

</tasks>

<verification>
All Docker utility functions work correctly:
```bash
cd /home/jonasrodrigues/projects/harness
bb -e "(require '[aishell.docker :as d])
       (println \"Available:\" (d/docker-available?))
       (println \"Running:\" (d/docker-running?))
       (println \"Image exists (hello-world):\" (d/image-exists? \"hello-world\"))
       (println \"Format 1GB:\" (d/format-size 1073741824))"
```
</verification>

<success_criteria>
- src/aishell/docker.clj exists with all functions
- Functions follow babashka.process patterns from research
- check-docker! produces colored error output matching output.clj style
- Image inspection uses proper Go template escaping for labels with dots
</success_criteria>

<output>
After completion, create `.planning/phases/14-docker-integration/14-01-SUMMARY.md`
</output>
