---
phase: 14-docker-integration
plan: 03
type: execute
wave: 2
depends_on: ["14-01", "14-02"]
files_modified:
  - src/aishell/docker/build.clj
  - src/aishell/docker/templates.clj
autonomous: true

must_haves:
  truths:
    - "Embedded Dockerfile content is available as string"
    - "Build writes files to temp directory before docker build"
    - "Build labels image with Dockerfile hash for cache tracking"
    - "Cache hit detected when image exists with matching hash"
    - "Force rebuild bypasses cache check"
  artifacts:
    - path: "src/aishell/docker/templates.clj"
      provides: "Embedded Dockerfile, entrypoint.sh, bashrc.aishell content"
      exports: ["base-dockerfile", "entrypoint-script", "bashrc-content"]
    - path: "src/aishell/docker/build.clj"
      provides: "Build logic with caching and spinner"
      exports: ["needs-rebuild?", "build-base-image"]
  key_links:
    - from: "src/aishell/docker/build.clj"
      to: "src/aishell/docker.clj"
      via: "image-exists? and get-image-label"
      pattern: "docker/image-exists\\?|docker/get-image-label"
    - from: "src/aishell/docker/build.clj"
      to: "src/aishell/docker/hash.clj"
      via: "compute-hash for cache"
      pattern: "hash/compute-hash"
    - from: "src/aishell/docker/build.clj"
      to: "babashka.process"
      via: "docker build command"
      pattern: "p/process.*docker.*build"
---

<objective>
Create embedded Dockerfile templates and build logic with cache invalidation

Purpose: Enable building Docker images from embedded templates with intelligent caching - rebuilds only when Dockerfile content changes
Output: src/aishell/docker/templates.clj with file contents, src/aishell/docker/build.clj with build functions
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/14-docker-integration/14-CONTEXT.md
@.planning/phases/14-docker-integration/14-RESEARCH.md

# Prior plan summaries for context
@.planning/phases/14-docker-integration/14-01-SUMMARY.md
@.planning/phases/14-docker-integration/14-02-SUMMARY.md

# Reference existing bash Dockerfile (embedded in aishell script)
@aishell
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create templates module with embedded build files</name>
  <files>src/aishell/docker/templates.clj</files>
  <action>
Create src/aishell/docker/templates.clj with:

1. Namespace: aishell.docker.templates

2. Define three multiline strings (copy from existing bash heredocs in aishell script):

base-dockerfile - The full Dockerfile content from write_dockerfile function
- Start with "# Aishell Base Image" comment
- Include all stages (node-source, main)
- Include ARG declarations (WITH_CLAUDE, WITH_OPENCODE, CLAUDE_VERSION, OPENCODE_VERSION, BABASHKA_VERSION)
- Include all RUN commands for package installation
- Include conditional harness installation
- Copy verbatim from lines 232-330 of aishell script

entrypoint-script - The entrypoint.sh content from write_entrypoint function
- Dynamic user creation with gosu
- Git safe.directory configuration
- PRE_START handling
- Copy verbatim from lines 335-410 of aishell script

bashrc-content - The bashrc.aishell content from write_bashrc function
- UTF-8 locale
- Custom prompt
- Aliases
- Copy verbatim from lines 416-447 of aishell script

Use raw string literals with proper escaping. The content must exactly match the bash version.
  </action>
  <verify>
```bash
cd /home/jonasrodrigues/projects/harness && bb -e "
(require '[aishell.docker.templates :as t])
(println \"Dockerfile lines:\" (count (clojure.string/split-lines t/base-dockerfile)))
(println \"Has FROM debian:\" (clojure.string/includes? t/base-dockerfile \"FROM debian:bookworm-slim\"))
(println \"Has entrypoint gosu:\" (clojure.string/includes? t/entrypoint-script \"exec gosu\"))
(println \"Has bashrc PS1:\" (clojure.string/includes? t/bashrc-content \"PS1\"))"
```
Should print line count, true, true, true
  </verify>
  <done>
- templates.clj exists with base-dockerfile, entrypoint-script, bashrc-content
- Content matches existing bash script heredocs exactly
- All three templates are non-empty strings
  </done>
</task>

<task type="auto">
  <name>Task 2: Create build module with caching logic</name>
  <files>src/aishell/docker/build.clj</files>
  <action>
Create src/aishell/docker/build.clj with:

1. Namespace: aishell.docker.build
   Require:
   - babashka.process :as p
   - babashka.fs :as fs
   - clojure.string :as str
   - clojure.java.io :as io
   - aishell.docker :as docker
   - aishell.docker.hash :as hash
   - aishell.docker.spinner :as spinner
   - aishell.docker.templates :as templates
   - aishell.output :as output

2. Constants:
   (def dockerfile-hash-label "aishell.dockerfile.hash")
   (def base-image-id-label "aishell.base.id")
   (def base-image-tag "aishell:base")

3. Functions:

get-dockerfile-hash []
- (hash/compute-hash templates/base-dockerfile)

needs-rebuild? [image-tag force?]
- Return true if:
  - force? is true, OR
  - (not (docker/image-exists? image-tag)), OR
  - hash mismatch: (get-dockerfile-hash) != (docker/get-image-label image-tag dockerfile-hash-label)

write-build-files [build-dir]
- (spit (str (fs/path build-dir "Dockerfile")) templates/base-dockerfile)
- (spit (str (fs/path build-dir "entrypoint.sh")) templates/entrypoint-script)
- (spit (str (fs/path build-dir "bashrc.aishell")) templates/bashrc-content)

build-base-image [{:keys [with-claude with-opencode claude-version opencode-version force verbose quiet]}]
- Check docker first: (docker/check-docker!)
- Check cache: (if (needs-rebuild? base-image-tag force) ... else return early with message)
- Create temp dir: (fs/create-temp-dir {:prefix "aishell-build-"})
- Write files: (write-build-files temp-dir)
- Build docker args vector:
  - Add --build-arg WITH_CLAUDE=true if with-claude
  - Add --build-arg WITH_OPENCODE=true if with-opencode
  - Add --build-arg CLAUDE_VERSION=X if claude-version
  - Add --build-arg OPENCODE_VERSION=X if opencode-version
  - Add --label aishell.dockerfile.hash=HASH
- Record start time: (System/currentTimeMillis)
- If verbose: run docker build with :out :inherit :err :inherit and --progress=plain
- Else if not quiet: use spinner/with-spinner for progress
- Else: capture output silently
- On success: print completion with time and size
- On failure: exit with error
- Finally: (fs/delete-tree temp-dir)
- Return {:success true :image base-image-tag}

Use (p/process {:dir build-dir ...} "docker" "build" "-t" tag ... ".") pattern.
Collect build args into vector, use (concat ["docker" "build" "-t" tag] args ["."]).
  </action>
  <verify>
```bash
cd /home/jonasrodrigues/projects/harness && bb -e "
(require '[aishell.docker.build :as b])
(println \"Hash label:\" b/dockerfile-hash-label)
(println \"Needs rebuild (fake):\" (b/needs-rebuild? \"nonexistent:image\" false))
(println \"Dockerfile hash:\" (b/get-dockerfile-hash))"
```
Should print label constant, true (nonexistent needs rebuild), and 12-char hash
  </verify>
  <done>
- build.clj exists with all functions
- needs-rebuild? correctly detects when rebuild needed
- write-build-files writes all three template files
- build-base-image orchestrates full build with caching and progress
  </done>
</task>

</tasks>

<verification>
Build module works (dry run - doesn't actually build):
```bash
cd /home/jonasrodrigues/projects/harness
bb -e "(require '[aishell.docker.build :as b])
       (println \"Ready to build\")
       (println \"Cache check for base:\" (b/needs-rebuild? \"aishell:base\" false))"
```

Full verification requires running actual build (will be tested in 14-04).
</verification>

<success_criteria>
- src/aishell/docker/templates.clj has all three template strings
- src/aishell/docker/build.clj has needs-rebuild?, write-build-files, build-base-image
- Template content matches existing bash version
- Build uses proper subprocess patterns from research
- Cache invalidation uses Dockerfile hash comparison
</success_criteria>

<output>
After completion, create `.planning/phases/14-docker-integration/14-03-SUMMARY.md`
</output>
