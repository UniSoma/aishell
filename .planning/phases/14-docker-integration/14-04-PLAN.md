---
phase: 14-docker-integration
plan: 04
type: execute
wave: 2
depends_on: ["14-01", "14-02"]
files_modified:
  - src/aishell/docker/extension.clj
autonomous: true

must_haves:
  truths:
    - "Project Dockerfile detected at .aishell/Dockerfile"
    - "No error when project has no extension Dockerfile"
    - "Extended image tracks base image ID in label"
    - "Extended image rebuilds when base image changes"
  artifacts:
    - path: "src/aishell/docker/extension.clj"
      provides: "Per-project Dockerfile extension handling"
      exports: ["project-dockerfile", "needs-extended-rebuild?", "build-extended-image"]
  key_links:
    - from: "src/aishell/docker/extension.clj"
      to: "src/aishell/docker.clj"
      via: "get-image-label for base ID tracking"
      pattern: "docker/get-image-label"
    - from: "src/aishell/docker/extension.clj"
      to: "babashka.process"
      via: "docker build and inspect commands"
      pattern: "p/shell.*docker"
---

<objective>
Create per-project Dockerfile extension support for custom project images

Purpose: Projects can extend the base image with .aishell/Dockerfile. The extension is auto-rebuilt when base image changes.
Output: src/aishell/docker/extension.clj with project Dockerfile detection and building
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/14-docker-integration/14-CONTEXT.md
@.planning/phases/14-docker-integration/14-RESEARCH.md

# Prior plan summaries
@.planning/phases/14-docker-integration/14-01-SUMMARY.md
@.planning/phases/14-docker-integration/14-02-SUMMARY.md

# Reference existing bash implementation
@aishell
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create extension module for project Dockerfiles</name>
  <files>src/aishell/docker/extension.clj</files>
  <action>
Create src/aishell/docker/extension.clj with:

1. Namespace: aishell.docker.extension
   Require:
   - babashka.process :as p
   - babashka.fs :as fs
   - clojure.string :as str
   - aishell.docker :as docker
   - aishell.docker.hash :as hash
   - aishell.docker.spinner :as spinner
   - aishell.output :as output

2. Constant:
   (def base-image-id-label "aishell.base.id")

3. Functions:

project-dockerfile [project-dir]
- Build path: (fs/path project-dir ".aishell" "Dockerfile")
- Return (str path) if (fs/exists? path), else nil

get-base-image-id [image-tag]
- Run: docker inspect --format={{.Id}} image-tag
- Return trimmed output or nil on error

compute-extended-tag [project-dir]
- Hash the project path: (hash/compute-hash project-dir)
- Return (str "aishell:ext-" hash)

needs-extended-rebuild? [extended-tag base-image-tag]
- Check if extended image exists: (docker/image-exists? extended-tag)
- If not exists: return true
- Get stored base ID: (docker/get-image-label extended-tag base-image-id-label)
- Get current base ID: (get-base-image-id base-image-tag)
- Return true if IDs don't match, false if they match

build-extended-image [{:keys [project-dir base-tag extended-tag force verbose]}]
- Get dockerfile path: (project-dockerfile project-dir)
- If nil, return nil (no extension)
- Get base-id: (get-base-image-id base-tag)
- Build args:
  - ["-f" dockerfile-path]
  - ["-t" extended-tag]
  - [(str "--label=" base-image-id-label "=" base-id)]
  - Add --no-cache if force
  - Add --progress=plain if verbose
- Run docker build with project-dir as context
- Use spinner if not verbose
- Return {:success true :image extended-tag} or exit on error

Follow same subprocess patterns as docker.clj.
Match bash implementation behavior: silent when no project Dockerfile exists.
  </action>
  <verify>
```bash
cd /home/jonasrodrigues/projects/harness && bb -e "
(require '[aishell.docker.extension :as ext])
(println \"Project dockerfile:\" (ext/project-dockerfile \".\"))
(println \"Extended tag:\" (ext/compute-extended-tag \"/home/user/project\"))
(println \"Needs rebuild (fake):\" (ext/needs-extended-rebuild? \"fake:tag\" \"aishell:base\"))"
```
Should print nil (no .aishell/Dockerfile in this project), a hash-based tag, true
  </verify>
  <done>
- extension.clj exists with all functions
- project-dockerfile returns nil when no extension exists
- compute-extended-tag produces consistent project-based tags
- needs-extended-rebuild? detects base image changes
- build-extended-image builds project extension with base tracking
  </done>
</task>

<task type="auto">
  <name>Task 2: Add extension Dockerfile content hash tracking</name>
  <files>src/aishell/docker/extension.clj</files>
  <action>
Add to extension.clj:

(def extension-hash-label "aishell.extension.hash")

get-extension-dockerfile-hash [project-dir]
- Read project Dockerfile: (slurp (project-dockerfile project-dir))
- Return (hash/compute-hash content)

Update needs-extended-rebuild? to also check extension Dockerfile hash:
- After checking base image ID match
- Get stored extension hash: (docker/get-image-label extended-tag extension-hash-label)
- Compute current extension hash: (get-extension-dockerfile-hash project-dir)
- Return true if hashes don't match

Update build-extended-image to add extension hash label:
- Add --label aishell.extension.hash=HASH to build args

This ensures extended image rebuilds when:
1. Base image changes (base ID mismatch)
2. Project Dockerfile changes (extension hash mismatch)
3. Force flag is set
  </action>
  <verify>
```bash
cd /home/jonasrodrigues/projects/harness && bb -e "
(require '[aishell.docker.extension :as ext])
(println \"Extension hash label:\" ext/extension-hash-label)"
```
Should print the label constant
  </verify>
  <done>
- Extension tracks its own Dockerfile hash for cache invalidation
- Rebuild triggered by either base change OR extension Dockerfile change
- Labels correctly stored on extended image
  </done>
</task>

</tasks>

<verification>
Extension module ready:
```bash
cd /home/jonasrodrigues/projects/harness
bb -e "(require '[aishell.docker.extension :as ext])
       (println \"Extension module loaded\")
       (println \"Has project-dockerfile:\" (fn? ext/project-dockerfile))
       (println \"Has build-extended-image:\" (fn? ext/build-extended-image))"
```
</verification>

<success_criteria>
- src/aishell/docker/extension.clj exists with all functions
- Project Dockerfile detection works (returns nil when absent)
- Extended tag computation is deterministic per project path
- Cache invalidation tracks both base image ID and extension Dockerfile hash
- Build creates proper labels for future cache checks
</success_criteria>

<output>
After completion, create `.planning/phases/14-docker-integration/14-04-SUMMARY.md`
</output>
