---
phase: 54-path-handling
plan: 02
type: execute
wave: 2
depends_on: ["54-01"]
files_modified:
  - src/aishell/docker/run.clj
  - src/aishell/check.clj
autonomous: true

must_haves:
  truths:
    - "Docker volume mount source paths normalized to forward slashes on Windows"
    - "Mount parsing handles Windows drive letters without splitting on drive colon"
    - "Project mounts at /workspace on Windows, same-path on Unix"
    - "LOCAL_HOME set to /home/developer on Windows"
    - "Source-only mounts on Windows map destination under /home/developer"
    - "Harness config mounts use fs/path instead of string concatenation"
  artifacts:
    - path: "src/aishell/docker/run.clj"
      provides: "Cross-platform Docker mount construction"
      contains: "parse-mount-string"
    - path: "src/aishell/check.clj"
      provides: "Cross-platform mount validation"
      contains: "parse-mount-string"
  key_links:
    - from: "src/aishell/docker/run.clj"
      to: "src/aishell/util.clj"
      via: "util/get-home, util/expand-path for path resolution"
      pattern: "util/get-home|util/expand-path"
    - from: "src/aishell/docker/run.clj"
      to: "babashka.fs"
      via: "fs/unixify for Docker path normalization, fs/windows? for platform branching"
      pattern: "fs/unixify"
---

<objective>
Update Docker mount construction and validation for cross-platform Windows/Unix support.

Purpose: Docker Desktop for Windows (WSL2) accepts forward-slash source paths, but mount parsing must handle drive letter colons, source paths need normalization, and container destinations must be platform-appropriate. Also fix `build-harness-config-mounts` to use `fs/path` instead of string concatenation with hardcoded `/`.

Output: Cross-platform `build-mount-args`, `build-docker-args-internal`, `build-harness-config-mounts` in `docker/run.clj` and updated `check-mounts` in `check.clj`.
</objective>

<execution_context>
@/home/jonasrodrigues/.claude/get-shit-done/workflows/execute-plan.md
@/home/jonasrodrigues/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/54-path-handling/54-CONTEXT.md
@.planning/phases/54-path-handling/54-RESEARCH.md
@.planning/phases/54-path-handling/54-01-SUMMARY.md
@src/aishell/docker/run.clj
@src/aishell/check.clj
@src/aishell/util.clj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add mount parsing and Docker path helpers to docker/run.clj</name>
  <files>src/aishell/docker/run.clj</files>
  <action>
Add three new helper functions to `src/aishell/docker/run.clj` and rewrite `build-mount-args`, `build-harness-config-mounts`, and the project mount section of `build-docker-args-internal`.

**1. Add `parse-mount-string` function (new, place before `build-mount-args`):**

Smart colon parsing that detects Windows drive letters to avoid splitting on them.

```clojure
(defn- parse-mount-string
  "Parse mount string 'source' or 'source:dest'.
   Smart colon parsing: detect Windows drive letter (X:/) to avoid splitting on it.
   Returns [source dest] where dest is nil for source-only mounts."
  [mount-str]
  (if (re-matches #"^[A-Za-z]:[/\\].*" mount-str)
    ;; Windows absolute path with drive letter — find colon AFTER drive letter
    (if-let [idx (str/index-of mount-str ":" 2)]
      [(subs mount-str 0 idx) (subs mount-str (inc idx))]
      [mount-str nil])
    ;; Unix path or relative path — split on first colon
    (if-let [idx (str/index-of mount-str ":")]
      [(subs mount-str 0 idx) (subs mount-str (inc idx))]
      [mount-str nil])))
```

**2. Add `normalize-mount-source` function (new, place before `build-mount-args`):**

Normalizes mount source paths for Docker Desktop (forward slashes on Windows).

```clojure
(defn- normalize-mount-source
  "Normalize mount source path for Docker Desktop.
   On Windows: converts backslashes to forward slashes.
   On Unix: no-op."
  [source-path]
  (if (fs/windows?)
    (fs/unixify source-path)
    source-path))
```

**3. Rewrite `build-mount-args` (lines 40-63):**

Replace the current naive colon splitting with `parse-mount-string`. Add source normalization for Docker. On Windows, source-only mounts map destination under `/home/developer/` (container home); explicit `source:dest` mounts trust user's dest path. On Unix, keep current behavior (source-only mounts at same path).

```clojure
(defn- build-mount-args
  "Build -v flags from mounts config.
   Supports:
   - source-only: ~/.ssh (same path on Unix, /home/developer/<name> on Windows)
   - source:dest: /host/path:/container/path (trust user's dest)
   Expands ~ and $HOME in source paths. Warns if source doesn't exist.
   Normalizes source paths for Docker Desktop on Windows."
  [mounts]
  (when (seq mounts)
    (->> mounts
         (mapcat
           (fn [mount]
             (let [mount-str (str mount)
                   [source dest] (parse-mount-string mount-str)
                   source (util/expand-path source)
                   dest (if dest
                          dest  ; Explicit dest: trust user (container path)
                          (if (fs/windows?)
                            ;; Windows source-only: map under container home
                            (str "/home/developer/" (fs/file-name source))
                            ;; Unix source-only: same path
                            source))]
               (if (fs/exists? source)
                 ["-v" (str (normalize-mount-source source) ":" dest)]
                 (do
                   (output/warn (str "Mount source does not exist: " source))
                   []))))))))
```

Key changes from current code:
- Uses `parse-mount-string` instead of `(str/split mount-str #":" 2)` — handles Windows drive letters
- Dest is `nil` for source-only mounts (not same-as-source) — enables platform-specific dest logic
- Source normalized via `normalize-mount-source` before Docker command
- `dest` NOT expanded through `util/expand-path` when explicit (already targeting container, Unix-style)
- Source-only dest on Windows uses `(fs/file-name source)` to get last path component

**4. Rewrite `build-harness-config-mounts` (lines 181-196):**

Replace string concatenation `(str home "/...")` with `(str (fs/path home "..."))`. Add Windows-specific container dest mapping (under `/home/developer/`). Normalize source paths for Docker.

```clojure
(defn- build-harness-config-mounts
  "Build mount args for harness configuration directories.
   Only mounts directories that exist on host.
   On Windows: maps destinations under /home/developer (container home).
   On Unix: mounts at same path as source."
  []
  (let [home (util/get-home)
        container-home "/home/developer"
        config-entries [;; [relative-path-components]
                        [".claude"]
                        [".claude.json"]
                        [".config" "opencode"]
                        [".local" "share" "opencode"]
                        [".codex"]
                        [".gemini"]]]
    (->> config-entries
         (map (fn [components]
                (let [src (str (apply fs/path home components))
                      dst (if (fs/windows?)
                            (str (apply fs/path container-home components))
                            src)]
                  [src dst])))
         (filter (fn [[src _]] (fs/exists? src)))
         (mapcat (fn [[src dst]] ["-v" (str (normalize-mount-source src) ":" dst)])))))
```

Key changes:
- Path construction uses `(apply fs/path home components)` instead of `(str home "/.claude")` — no hardcoded `/`
- Windows: dest mapped under `/home/developer/` (container home) since Windows host paths are meaningless in Linux container
- Unix: dest stays same as source (current behavior preserved)
- Source normalized for Docker via `normalize-mount-source`

**5. Update project mount in `build-docker-args-internal` (lines 242-248):**

Replace the hardcoded same-path mount with platform-specific logic. On Windows: mount at `/workspace`, set `LOCAL_HOME` to `/home/developer`. On Unix: keep current same-path behavior.

In `build-docker-args-internal`, change the `into` block at lines 242-248 from:

```clojure
(into [;; Project mount at same path
       "-v" (str project-dir ":" project-dir)
       "-w" project-dir
       ;; User identity for entrypoint
       "-e" (str "LOCAL_UID=" uid)
       "-e" (str "LOCAL_GID=" gid)
       "-e" (str "LOCAL_HOME=" home)])
```

to:

```clojure
(into (let [mount-source (normalize-mount-source project-dir)
            mount-dest (if (fs/windows?) "/workspace" project-dir)
            container-home (if (fs/windows?) "/home/developer" home)]
        [;; Project mount
         "-v" (str mount-source ":" mount-dest)
         "-w" mount-dest
         ;; User identity for entrypoint
         "-e" (str "LOCAL_UID=" uid)
         "-e" (str "LOCAL_GID=" gid)
         "-e" (str "LOCAL_HOME=" container-home)]))
```

Key changes:
- `project-dir` source normalized via `normalize-mount-source`
- Windows: mount destination is `/workspace`, working dir is `/workspace`
- Windows: `LOCAL_HOME` is `/home/developer` (not Windows home path)
- Unix: behavior unchanged (same-path mount, host home)
  </action>
  <verify>
```bash
# File loads without errors
bb -e "(require '[aishell.docker.run])"

# parse-mount-string exists and works
bb -e "(require '[aishell.docker.run]) (println ((resolve 'aishell.docker.run/parse-mount-string) \"~/.ssh\"))"
# Expected: [~/.ssh nil] (private fn — test via indirect means if resolve fails)

# Verify new functions exist
grep -n "parse-mount-string" src/aishell/docker/run.clj
grep -n "normalize-mount-source" src/aishell/docker/run.clj

# Verify no hardcoded path separators in harness config mounts
grep -n "(str home \"/" src/aishell/docker/run.clj
# Should return NO matches

# Verify fs/unixify is used
grep -n "fs/unixify" src/aishell/docker/run.clj

# Verify /workspace is used for Windows
grep -n "/workspace" src/aishell/docker/run.clj

# Verify container-home pattern
grep -n "container-home" src/aishell/docker/run.clj

# CLI still works
bb aishell.clj --help
```
  </verify>
  <done>
- `parse-mount-string` handles drive letter colons (e.g., `C:\Users\name\.ssh:/home/developer/.ssh` splits correctly)
- `normalize-mount-source` uses `fs/unixify` on Windows, no-op on Unix
- `build-mount-args` uses smart colon parsing, normalizes sources, maps Windows source-only dests under `/home/developer/`
- `build-harness-config-mounts` uses `fs/path` instead of string concatenation with `/`, maps Windows dests under `/home/developer/`
- `build-docker-args-internal` mounts project at `/workspace` on Windows, same-path on Unix; sets `LOCAL_HOME=/home/developer` on Windows
- No `(str home "/...")` patterns remain in run.clj
- `bb aishell.clj --help` succeeds
  </done>
</task>

<task type="auto">
  <name>Task 2: Update check.clj mount parsing for Windows drive letter support</name>
  <files>src/aishell/check.clj</files>
  <action>
Update `check-mounts` in `src/aishell/check.clj` (lines 125-135) to use smart colon parsing consistent with `docker/run.clj`.

The current code at line 131 uses `(first (str/split mount-str #":" 2))` which would split `C:\Users\name\.ssh` incorrectly on the drive letter colon.

Replace the naive split with inline drive letter detection (same logic as `parse-mount-string` in run.clj, but inlined since check.clj shouldn't depend on docker/run.clj):

```clojure
(defn- check-mounts
  "Check if configured mount sources exist."
  [cfg]
  (when-let [mounts (:mounts cfg)]
    (doseq [mount mounts]
      (let [mount-str (str mount)
            ;; Smart colon parsing: detect drive letter to avoid splitting on it
            source (if (re-matches #"^[A-Za-z]:[/\\].*" mount-str)
                     ;; Windows absolute path — extract source (before second colon, or entire string)
                     (if-let [idx (str/index-of mount-str ":" 2)]
                       (subs mount-str 0 idx)
                       mount-str)
                     ;; Unix path — extract before first colon
                     (first (str/split mount-str #":" 2)))
            source (util/expand-path source)]
        (if (fs/exists? source)
          (print-status :ok (str "Mount exists: " source))
          (print-status :warn (str "Mount not found: " source)))))))
```

Alternative: extract `parse-mount-string` into `util.clj` and share it. But since check.clj only needs the source (not dest), and adding a dependency from check.clj to docker/run.clj would be wrong, inlining the source extraction logic is cleaner.
  </action>
  <verify>
```bash
# File loads without errors
bb -e "(require '[aishell.check])"

# Verify drive letter detection exists in check.clj
grep -n "drive letter" src/aishell/check.clj

# Verify the regex pattern is present
grep -n "A-Za-z" src/aishell/check.clj

# CLI check command works
bb aishell.clj check 2>/dev/null || true  # May warn about config, that's OK

# Full CLI still works
bb aishell.clj --help
```
  </verify>
  <done>
- `check-mounts` uses smart colon parsing matching `parse-mount-string` logic
- Drive letter colons (e.g., `C:`) not confused with mount separator colons
- No functional change on Unix (no drive letters to detect)
- `bb aishell.clj --help` succeeds
  </done>
</task>

</tasks>

<verification>
1. `grep -c "parse-mount-string" src/aishell/docker/run.clj` returns >= 2 (defn + call)
2. `grep -c "normalize-mount-source" src/aishell/docker/run.clj` returns >= 3 (defn + calls)
3. `grep -c "fs/unixify" src/aishell/docker/run.clj` returns >= 1
4. `grep -c "/workspace" src/aishell/docker/run.clj` returns >= 1
5. `grep "(str home \"/" src/aishell/docker/run.clj` returns NO matches (string concat with `/` eliminated)
6. `grep "A-Za-z" src/aishell/check.clj` returns >= 1 (drive letter detection)
7. `bb -e "(require '[aishell.docker.run])"` succeeds
8. `bb -e "(require '[aishell.check])"` succeeds
9. `bb aishell.clj --help` succeeds
</verification>

<success_criteria>
- Docker mount source paths normalized to forward slashes via fs/unixify on Windows
- Mount parsing handles Windows drive letter colons correctly
- Project mounts at /workspace on Windows, same-path on Unix
- LOCAL_HOME set to /home/developer on Windows, host home on Unix
- Source-only mounts on Windows map destination under /home/developer
- Harness config mounts use fs/path instead of string concatenation with hardcoded /
- check.clj mount validation uses smart colon parsing
- No functional regressions on Unix
</success_criteria>

<output>
After completion, create `.planning/phases/54-path-handling/54-02-SUMMARY.md`
</output>
