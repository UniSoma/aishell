#!/bin/bash
# aishell - AI Shell Container Launcher
# Launches an ephemeral container with project mounted at host path

set -e

VERSION="0.1.0"
BASE_IMAGE_NAME="aishell:base"
VERBOSE=false
WITH_CLAUDE=false
WITH_OPENCODE=false
HARNESS_CMD=""
HARNESS_ARGS=()
FORCE_REBUILD=false
BUILD_ARGS=()
IMAGE_TO_RUN=""

# --- Color Support ---
supports_color() {
    [[ ! -t 1 ]] && return 1
    [[ -n "$NO_COLOR" ]] && return 1
    [[ -n "$FORCE_COLOR" ]] && return 0
    local colors
    colors=$(tput colors 2>/dev/null) || return 1
    [[ "$colors" -ge 8 ]]
}

if supports_color; then
    RED='\033[0;31m'
    YELLOW='\033[0;33m'
    NC='\033[0m'
else
    RED=''
    YELLOW=''
    NC=''
fi

# --- Output Functions ---
error() {
    echo -e "${RED}Error:${NC} $1" >&2
    exit 1
}

warn() {
    echo -e "${YELLOW}Warning:${NC} $1" >&2
}

verbose() {
    [[ "$VERBOSE" == true ]] && echo "$1" >&2 || true
}

# --- Spinner for Long Operations ---
spinner_pid=""

start_spinner() {
    local msg="$1"
    local spin='|/-\'
    local i=0

    # Only show spinner if stderr is a TTY
    [[ ! -t 2 ]] && return

    while true; do
        printf "\r%s %c " "$msg" "${spin:i++%${#spin}:1}" >&2
        sleep 0.1
    done &
    spinner_pid=$!
}

stop_spinner() {
    [[ -n "$spinner_pid" ]] && kill "$spinner_pid" 2>/dev/null
    spinner_pid=""
    printf "\r\033[K" >&2  # Clear line
}

trap 'stop_spinner' EXIT

# --- Git Identity ---
read_git_identity() {
    local project_dir="$1"

    # Check if git is installed on host
    if ! command -v git &> /dev/null; then
        echo ""
        echo ""
        return 0
    fi

    # Read effective config (local overrides global)
    # git -C runs command as if started in <path>
    local name email
    name=$(git -C "$project_dir" config user.name 2>/dev/null) || name=""
    email=$(git -C "$project_dir" config user.email 2>/dev/null) || email=""

    echo "$name"
    echo "$email"
}

# --- Harness Config Mounts ---
build_config_mounts() {
    # Output mount flags, one per line as "-v src:dst"
    # Claude Code configs
    [[ -d "$HOME/.claude" ]] && echo "-v $HOME/.claude:$HOME/.claude"
    [[ -f "$HOME/.claude.json" ]] && echo "-v $HOME/.claude.json:$HOME/.claude.json"

    # OpenCode configs
    [[ -d "$HOME/.config/opencode" ]] && echo "-v $HOME/.config/opencode:$HOME/.config/opencode"

    # OpenCode credentials (auth.json from /connect)
    [[ -d "$HOME/.local/share/opencode" ]] && echo "-v $HOME/.local/share/opencode:$HOME/.local/share/opencode"
}

# --- API Key Environment Variables ---
build_api_env() {
    # Output env flags, one per line as "-e VAR=value"
    # API keys for various providers (only pass if set, avoid empty override)
    local api_vars=(
        ANTHROPIC_API_KEY
        OPENAI_API_KEY
        GEMINI_API_KEY
        GROQ_API_KEY
        GITHUB_TOKEN
        AWS_ACCESS_KEY_ID
        AWS_SECRET_ACCESS_KEY
        AWS_REGION
        AWS_PROFILE
        AZURE_OPENAI_API_KEY
        AZURE_OPENAI_ENDPOINT
        GOOGLE_CLOUD_PROJECT
        GOOGLE_APPLICATION_CREDENTIALS
    )

    for var in "${api_vars[@]}"; do
        [[ -n "${!var:-}" ]] && echo "-e $var=${!var}"
    done

    # Recommended container settings for Claude Code
    echo "-e DISABLE_AUTOUPDATER=1"
}

# --- Docker Checks ---
check_docker() {
    if ! command -v docker &> /dev/null; then
        error "Docker is not installed. Please install Docker and try again."
    fi

    if ! docker info >/dev/null 2>&1; then
        error "Docker is not running. Please start Docker and try again."
    fi
}

# --- Argument Parsing ---
usage() {
    cat << EOF
Usage: aishell [OPTIONS] [COMMAND] [ARGS...]

Launch an ephemeral container with the current directory mounted.

Commands:
    claude      Run Claude Code (requires --with-claude at build)
    opencode    Run OpenCode (requires --with-opencode at build)
    update      Rebuild image with latest harness versions
    (none)      Enter interactive shell (default)

Options:
    --with-claude       Include Claude Code in image (build-time)
    --with-opencode     Include OpenCode in image (build-time)
    --rebuild           Force rebuild of images (ignore cache)
    --build-arg KEY=VAL Pass build argument to Dockerfile (can repeat)
    -v, --verbose       Show detailed output
    -h, --help          Show this help message
    --version           Show version

Project Extensions:
    Place a Dockerfile at .aishell/Dockerfile to extend the base image
    with project-specific dependencies. The extended image is cached
    and rebuilt automatically when the base image or Dockerfile changes.

Examples:
    aishell                           # Enter shell
    aishell claude                    # Run Claude Code
    aishell opencode                  # Run OpenCode
    aishell --with-claude             # Rebuild with Claude Code, then shell
    aishell --build-arg NODE_VERSION=20   # Pass build arg to extension
    aishell --rebuild                 # Force rebuild of all images

EOF
}

parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --with-claude)
                WITH_CLAUDE=true
                shift
                ;;
            --with-opencode)
                WITH_OPENCODE=true
                shift
                ;;
            --rebuild)
                FORCE_REBUILD=true
                shift
                ;;
            --build-arg)
                if [[ -z "${2:-}" ]] || [[ "$2" == -* ]]; then
                    error "--build-arg requires a KEY=VALUE argument"
                fi
                BUILD_ARGS+=("$2")
                shift 2
                ;;
            --build-arg=*)
                BUILD_ARGS+=("${1#--build-arg=}")
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            --version)
                echo "aishell $VERSION"
                exit 0
                ;;
            claude|opencode)
                HARNESS_CMD="$1"
                shift
                HARNESS_ARGS=("$@")
                break
                ;;
            update)
                HARNESS_CMD="update"
                shift
                break
                ;;
            -*)
                error "Unknown option: $1"
                ;;
            *)
                # Unknown positional - treat as command to run in shell
                HARNESS_CMD="exec"
                HARNESS_ARGS=("$1" "${@:2}")
                break
                ;;
        esac
    done
}

# --- Project Extension Functions ---
extension_dockerfile() {
    local project_dir="$1"
    local dockerfile="$project_dir/.aishell/Dockerfile"

    if [[ -f "$dockerfile" ]]; then
        echo "$dockerfile"
        return 0
    fi

    return 1
}

get_base_image_id() {
    docker inspect --format='{{.Id}}' "$BASE_IMAGE_NAME" 2>/dev/null
}

needs_extended_rebuild() {
    local extended_tag="$1"
    local current_base_id="$2"

    # Extended image doesn't exist
    if ! docker image inspect "$extended_tag" >/dev/null 2>&1; then
        return 0
    fi

    # Check stored base ID against current
    local stored_base_id
    stored_base_id=$(docker inspect --format='{{index .Config.Labels "aishell.base.id"}}' "$extended_tag" 2>/dev/null)

    if [[ "$stored_base_id" != "$current_base_id" ]]; then
        return 0  # Base changed, need rebuild
    fi

    return 1  # Use cache
}

build_extended_image() {
    local dockerfile="$1"
    local project_dir="$2"
    local image_tag="$3"
    local base_id="$4"
    local force_rebuild="$5"

    local -a build_args=(
        -f "$dockerfile"
        -t "$image_tag"
        --label "aishell.base.id=$base_id"
    )

    # Add --no-cache if force rebuild
    [[ "$force_rebuild" == true ]] && build_args+=(--no-cache)

    # Pass through BUILD_ARGS array
    for arg in "${BUILD_ARGS[@]}"; do
        build_args+=(--build-arg "$arg")
    done

    if [[ "$VERBOSE" == true ]]; then
        if ! docker build "${build_args[@]}" --progress=plain "$project_dir"; then
            error "Build failed"
        fi
    else
        local build_log
        build_log=$(mktemp)
        # shellcheck disable=SC2064
        trap "rm -f '$build_log'" RETURN

        start_spinner "Building project image"
        if docker build "${build_args[@]}" "$project_dir" > "$build_log" 2>&1; then
            stop_spinner
        else
            stop_spinner
            error "Build failed:
$(cat "$build_log")"
        fi
    fi
}

ensure_image_with_extension() {
    local project_dir="$1"

    # First ensure base image exists
    ensure_image

    # Check for extension
    local dockerfile
    if ! dockerfile=$(extension_dockerfile "$project_dir"); then
        # No extension, use base
        IMAGE_TO_RUN="$BASE_IMAGE_NAME"
        return 0
    fi

    # Calculate extended tag (hash of project path for isolation)
    local hash
    hash=$(echo -n "$project_dir" | sha256sum | cut -c1-12)
    local extended_tag="aishell:ext-$hash"

    # Get current base image ID
    local base_id
    base_id=$(get_base_image_id)

    # Determine if rebuild needed
    local force_rebuild=false
    if needs_extended_rebuild "$extended_tag" "$base_id"; then
        force_rebuild=true
    fi

    # User requested --rebuild
    [[ "$FORCE_REBUILD" == true ]] && force_rebuild=true

    # Build (Docker cache handles efficiency if force_rebuild=false)
    build_extended_image "$dockerfile" "$project_dir" "$extended_tag" "$base_id" "$force_rebuild"

    IMAGE_TO_RUN="$extended_tag"
}

# --- Image Management ---
ensure_image() {
    local needs_build=false
    local -a build_args=()

    # Check if image exists
    if ! docker image inspect "$BASE_IMAGE_NAME" >/dev/null 2>&1; then
        needs_build=true
    fi

    # Check if build flags request harnesses not in current image
    # (For now, rebuild if any --with-* flag passed)
    if [[ "$WITH_CLAUDE" == true ]] || [[ "$WITH_OPENCODE" == true ]]; then
        needs_build=true
    fi

    if [[ "$needs_build" == true ]]; then
        verbose "Building image..."
        start_spinner "Building image"

        local script_dir
        script_dir="$(dirname "$(readlink -f "$0")")"

        [[ "$WITH_CLAUDE" == true ]] && build_args+=(--build-arg WITH_CLAUDE=true)
        [[ "$WITH_OPENCODE" == true ]] && build_args+=(--build-arg WITH_OPENCODE=true)

        if ! docker build "${build_args[@]}" -t "$BASE_IMAGE_NAME" "$script_dir" >/dev/null 2>&1; then
            stop_spinner
            error "Failed to build image"
        fi

        stop_spinner
        verbose "Image built successfully"
    fi
}

# --- Update Command ---
do_update() {
    check_docker

    verbose "Rebuilding image with latest harness versions..."
    start_spinner "Updating image"

    local script_dir
    script_dir="$(dirname "$(readlink -f "$0")")"

    # Force rebuild with no cache for harness layers
    local -a build_args=(--no-cache)
    [[ "$WITH_CLAUDE" == true ]] && build_args+=(--build-arg WITH_CLAUDE=true)
    [[ "$WITH_OPENCODE" == true ]] && build_args+=(--build-arg WITH_OPENCODE=true)

    if ! docker build "${build_args[@]}" -t "$BASE_IMAGE_NAME" "$script_dir" >/dev/null 2>&1; then
        stop_spinner
        error "Failed to update image"
    fi

    stop_spinner
    echo "Image updated successfully"
}

# --- Main ---
main() {
    parse_args "$@"

    # Handle update command before docker checks
    if [[ "$HARNESS_CMD" == "update" ]]; then
        do_update
        exit 0
    fi

    check_docker

    local project_dir
    project_dir="$(pwd)"

    # Ensure image (base + extension if .aishell/Dockerfile exists)
    ensure_image_with_extension "$project_dir"

    # Read git identity from host
    local identity git_name git_email
    identity=$(read_git_identity "$project_dir")
    git_name=$(echo "$identity" | head -1)
    git_email=$(echo "$identity" | tail -1)

    if [[ -z "$git_name" ]] || [[ -z "$git_email" ]]; then
        warn "Git identity not found on host"
    fi

    verbose "Launching container..."
    verbose "  Project: $project_dir"
    verbose "  UID/GID: $(id -u):$(id -g)"
    if [[ -n "$git_name" ]] && [[ -n "$git_email" ]]; then
        verbose "  Git identity: $git_name <$git_email>"
    fi
    [[ -n "$HARNESS_CMD" ]] && verbose "  Command: $HARNESS_CMD ${HARNESS_ARGS[*]}"

    # Build docker run arguments
    local -a docker_args=(
        --rm -it
        -v "$project_dir:$project_dir"
        -w "$project_dir"
        -e "LOCAL_UID=$(id -u)"
        -e "LOCAL_GID=$(id -g)"
        -e "LOCAL_HOME=$HOME"
        -e "TERM=${TERM:-xterm-256color}"
    )

    # Add git identity env vars
    if [[ -n "$git_name" ]] && [[ -n "$git_email" ]]; then
        docker_args+=(
            -e "GIT_AUTHOR_NAME=$git_name"
            -e "GIT_AUTHOR_EMAIL=$git_email"
            -e "GIT_COMMITTER_NAME=$git_name"
            -e "GIT_COMMITTER_EMAIL=$git_email"
        )
    fi

    # Add config mounts (using mapfile for robustness)
    local config_mounts
    config_mounts=$(build_config_mounts)
    if [[ -n "$config_mounts" ]]; then
        while IFS= read -r mount; do
            [[ -n "$mount" ]] && docker_args+=($mount)
        done <<< "$config_mounts"
    fi

    # Add API environment variables
    local api_envs
    api_envs=$(build_api_env)
    if [[ -n "$api_envs" ]]; then
        while IFS= read -r env; do
            [[ -n "$env" ]] && docker_args+=($env)
        done <<< "$api_envs"
    fi

    # Dispatch based on command
    case "$HARNESS_CMD" in
        claude)
            exec docker run "${docker_args[@]}" "$IMAGE_TO_RUN" claude "${HARNESS_ARGS[@]}"
            ;;
        opencode)
            exec docker run "${docker_args[@]}" "$IMAGE_TO_RUN" opencode "${HARNESS_ARGS[@]}"
            ;;
        exec)
            exec docker run "${docker_args[@]}" "$IMAGE_TO_RUN" "${HARNESS_ARGS[@]}"
            ;;
        *)
            exec docker run "${docker_args[@]}" "$IMAGE_TO_RUN" /bin/bash
            ;;
    esac
}

main "$@"
